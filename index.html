<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>SPIC V15 - Infinite Flow</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; }
        
        /* è§†é¢‘åé¦ˆï¼šå·¦ä¸‹è§’å¾®ç¼© */
        #video-element { position: absolute; bottom: 10px; left: 10px; width: 120px; z-index: 2; transform: scaleX(-1); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; opacity: 0.4; pointer-events: none; }
        
        /* UI å¸ƒå±€ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .header { position: absolute; top: 30px; width: 100%; text-align: center; }
        h1 { margin: 0; font-size: 32px; color: #fff; letter-spacing: 6px; font-weight: 300; text-shadow: 0 0 30px rgba(0,191,255,0.6); }
        .subtitle { font-size: 14px; color: #00ffff; letter-spacing: 3px; margin-top: 5px; opacity: 0.8; text-transform: uppercase; }
        
        /* çŠ¶æ€æŒ‡ç¤ºæ¡ */
        #status-bar { 
            position: absolute; top: 110px; left: 50%; transform: translateX(-50%);
            background: rgba(0,20,40,0.8); padding: 8px 24px; border-radius: 30px; 
            border: 1px solid rgba(0,255,255,0.3);
            color: #FFD700; font-size: 14px; letter-spacing: 1px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: all 0.3s;
        }

        /* äº¤äº’æç¤º */
        .controls { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 12px; letter-spacing: 2px; }
        
        /* ä¸Šä¼ æŒ‰é’® */
        #upload-btn {
            position: absolute; right: 30px; top: 30px; pointer-events: auto;
            background: rgba(0,0,0,0.5); border: 1px solid #00ffff; color: #00ffff;
            padding: 10px 20px; border-radius: 4px; cursor: pointer;
            font-size: 12px; transition: all 0.3s;
        }
        #upload-btn:hover { background: #00ffff; color: #000; box-shadow: 0 0 20px #00ffff; }
        input[type="file"] { display: none; }
        
        /* å‡†æ˜Ÿ */
        #cursor-ring {
            position: fixed; top: 50%; left: 50%; width: 40px; height: 40px;
            border: 1px solid rgba(255,255,255,0.3); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 20;
        }
        #cursor-ring.hover { width: 60px; height: 60px; border-color: #00ffff; border-width: 2px; box-shadow: 0 0 15px #00ffff; background: rgba(0,255,255,0.1); }
        #cursor-ring.grab { width: 30px; height: 30px; background: #00ffff; border-color: #fff; }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="header">
            <h1>SPIC èƒ½æºè§†ç•Œ</h1>
            <div class="subtitle">Procedural Generation Engine</div>
        </div>
        <div id="status-bar">ç³»ç»Ÿåˆå§‹åŒ–...</div>
        <div class="controls">âœŠèšåˆ(åˆ‡æ¢) | ğŸ–ç”»å»Šæ¨¡å¼ | ğŸ‘Œ/ç‚¹å‡» æŠ“å–ç…§ç‰‡ | ğŸ–±ï¸é¼ æ ‡ä¹Ÿå¯æ§åˆ¶</div>
        
        <label id="upload-btn">
            + æ³¨å…¥å›¾åº“
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <div id="cursor-ring"></div>
    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="genCanvas" width="2048" height="1024" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- é…ç½®å‚æ•° ---
        const CONFIG = {
            particleCount: 20000, // 2ä¸‡ç²’å­ï¼Œæé«˜å¯†åº¦
            colors: {
                tower: [new THREE.Color(0x00BFFF), new THREE.Color(0x1E90FF), new THREE.Color(0x00FF7F)], // è“ç»¿æ¸å˜
                totem: [new THREE.Color(0xFFD700), new THREE.Color(0xFF4500), new THREE.Color(0xC71585)], // é‡‘çº¢ç´«
                wind: [new THREE.Color(0x00FA9A), new THREE.Color(0x98FB98)], // è§å…‰ç»¿
                text: [new THREE.Color(0xE0FFFF)] // å†°é›ªç™½
            }
        };

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer;
        let particles, geometry, material;
        let photoGroup, photos = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2(0, 0); // å½’ä¸€åŒ–åæ ‡ (-1 to 1)
        let virtualMouse = new THREE.Vector2(0.5, 0.5); // å±å¹•åæ ‡ (0 to 1), ç”¨äºæ‰‹åŠ¿/é¼ æ ‡ç»Ÿä¸€

        // çŠ¶æ€
        const STATE = {
            mode: 'SCATTER', // SCATTER (ç”»å»Š), SHAPE (å½¢æ€), ZOOM (æŠ“å–)
            shapeIndex: 0,   // 0:å‡‰æ°´å¡”, 1:é£å…‰äº’è¡¥, 2:å›¾è…¾, 3:æ–‡å­—
            isHandActive: false,
            gesture: 'NONE',
            autoRotate: true
        };

        // æ•°æ®ç¼“å­˜ (æ‰€æœ‰ä½ç½®æ•°æ®)
        const POSITIONS = { TOWER:[], WIND:[], TOTEM:[], TEXT:[], SCATTER:[] };
        let currentPositions = []; 

        // äº¤äº’
        let hoveredPhoto = null;
        let grabbedPhoto = null;

        init();

        function init() {
            // 1. åˆå§‹åŒ–åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 5000);
            camera.position.set(0, 0, 400);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 2. è¾‰å…‰ç‰¹æ•ˆ (Bloom)
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // 3. ç²’å­ç³»ç»Ÿ (æ ¸å¿ƒ)
            createParticleSystem();

            // 4. ç…§ç‰‡å®¹å™¨
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            // 5. ç”Ÿæˆæ‰€æœ‰å½¢æ€ (çº¯è®¡ç®—ï¼Œ0å»¶è¿Ÿ)
            generateAllShapes();
            
            // 6. é»˜è®¤è¿›å…¥å‡‰æ°´å¡”å½¢æ€
            switchShape(0); 

            // 7. äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);
            document.getElementById('file-input').addEventListener('change', handleUpload);

            // 8. å¯åŠ¨AI
            initMediaPipe();
            
            // 9. åŠ¨ç”»å¾ªç¯
            animate();
        }

        // --- æ ¸å¿ƒï¼šç¨‹åºåŒ–å‡ ä½•ç”Ÿæˆ (Math Art) ---

        function generateAllShapes() {
            // A. å‡‰æ°´å¡” (åŒæ›²çº¿ç»“æ„)
            POSITIONS.TOWER = createCoolingTower();
            
            // B. é£å…‰äº’è¡¥ (å‡ ä½•æ‹¼æ¥)
            POSITIONS.WIND = createIndustrialScene();

            // C. èƒ½é‡å›¾è…¾ (é©¬çš„æ›¿ä»£å“ï¼Œæ•°å­¦å‡ ä½•ä½“)
            POSITIONS.TOTEM = createEnergyTotem();

            // D. æ–‡å­—
            POSITIONS.TEXT = createText("é£å…‰æ— é™  å›½å®¶ç”µæŠ•");

            // E. æ•£å¼€ (æ˜Ÿç©º)
            POSITIONS.SCATTER = new Float32Array(CONFIG.particleCount * 3);
            for(let i=0; i<CONFIG.particleCount*3; i++) POSITIONS.SCATTER[i] = (Math.random()-0.5)*1500;
        }

        function createCoolingTower() {
            const arr = new Float32Array(CONFIG.particleCount * 3);
            const h = 320; 
            for(let i=0; i<CONFIG.particleCount; i++) {
                const ratio = i / CONFIG.particleCount; // 0-1
                const y = (ratio - 0.5) * h;
                const v = (y + h/2) / h; 
                // åŒæ›²çº¿å…¬å¼
                let r = 80 * Math.sqrt(1 + Math.pow(v*2 - 0.9, 2) * 0.6);
                const angle = ratio * Math.PI * 120 + Math.random()*Math.PI; // èºæ—‹æ’åˆ—
                
                // åŠ ä¸€ç‚¹éšæœºåšåº¦
                r += (Math.random()-0.5) * 5;

                arr[i*3] = Math.cos(angle) * r;
                arr[i*3+1] = y;
                arr[i*3+2] = Math.sin(angle) * r;
            }
            return arr;
        }

        function createIndustrialScene() {
            const arr = new Float32Array(CONFIG.particleCount * 3);
            let idx = 0;
            const push = (x,y,z) => { if(idx<arr.length) { arr[idx++]=x; arr[idx++]=y; arr[idx++]=z; } };

            // 1. é£æœº (ä¸¤ä¸ª)
            const addWind = (ox, oz, scale) => {
                const h = 220 * scale;
                // å¡”ç­’
                for(let i=0; i<1500; i++) {
                    const y = (Math.random()-0.5)*h;
                    const r = 6 * scale * (1 - (y+h/2)/h * 0.5);
                    const a = Math.random()*6.28;
                    push(ox + Math.cos(a)*r, y, oz + Math.sin(a)*r);
                }
                // å¶ç‰‡ (ä¸‰å¶)
                for(let k=0; k<3; k++) {
                    const ang = k/3 * 6.28 + Date.now()*0.001; // é™æ€ç”Ÿæˆï¼Œä¸åšæ—‹è½¬äº†
                    for(let j=0; j<600; j++) {
                        const l = Math.random() * 100 * scale;
                        const bx = Math.cos(ang) * l;
                        const by = Math.sin(ang) * l;
                        push(ox + bx, h/2 + by, oz + (Math.random()-0.5)*5);
                    }
                }
            };
            addWind(-100, -50, 1);
            addWind(120, 50, 0.7);

            // 2. å…‰ä¼æ¿ (åœ°é¢é˜µåˆ—)
            while(idx < arr.length) {
                const row = Math.floor(Math.random()*6);
                const col = Math.floor(Math.random()*12);
                const cx = (col - 6) * 45;
                const cz = (row - 3) * 35 + 80;
                const px = (Math.random()-0.5)*40;
                const pz = (Math.random()-0.5)*30;
                const py = pz * Math.sin(0.5) - 120; // å€¾æ–œ
                const realZ = pz * Math.cos(0.5) + cz;
                push(cx + px, py, realZ);
            }
            return arr;
        }

        function createEnergyTotem() {
            // æ›¿ä»£é©¬çš„æ¨¡å‹ï¼šä¸€ä¸ªå¤æ‚çš„ç¯å½¢ç»“ï¼Œçœ‹èµ·æ¥å¾ˆæœ‰ç§‘æŠ€æ„Ÿ
            const arr = new Float32Array(CONFIG.particleCount * 3);
            for(let i=0; i<CONFIG.particleCount; i++) {
                const t = (i / CONFIG.particleCount) * Math.PI * 2 * 20; // 20åœˆ
                // Torus Knot å‚æ•°
                const p = 3, q = 7; 
                const r = 80 + Math.cos(q*t)*20;
                
                const x = r * Math.cos(p*t);
                const y = r * Math.sin(p*t);
                const z = 50 * Math.sin(q*t);
                
                // å¢åŠ ä½“ç§¯å™ªç‚¹
                const noise = 10;
                arr[i*3] = x + (Math.random()-0.5)*noise;
                arr[i*3+1] = y + (Math.random()-0.5)*noise;
                arr[i*3+2] = z + (Math.random()-0.5)*noise;
            }
            return arr;
        }

        function createText(txt) {
            const ctx = document.getElementById('genCanvas').getContext('2d');
            ctx.clearRect(0,0,2048,1024);
            ctx.font = "bold 220px 'Microsoft YaHei'"; ctx.fillStyle = "#fff";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(txt, 1024, 512);
            const data = ctx.getImageData(0,0,2048,1024).data;
            const valid = [];
            for(let y=0; y<1024; y+=8) for(let x=0; x<2048; x+=8) {
                if(data[(y*2048+x)*4+3] > 100) valid.push({x,y});
            }
            const arr = new Float32Array(CONFIG.particleCount * 3);
            for(let i=0; i<CONFIG.particleCount; i++) {
                const p = valid[i % valid.length];
                arr[i*3] = (p.x - 1024) * 0.4;
                arr[i*3+1] = -(p.y - 512) * 0.4;
                arr[i*3+2] = (Math.random()-0.5) * 20;
            }
            return arr;
        }


        // --- ç²’å­ç³»ç»Ÿ ---
        function createParticleSystem() {
            // å…‰æ™•è´´å›¾
            const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            const tex = new THREE.CanvasTexture(canvas);

            geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.particleCount*3);
            const col = new Float32Array(CONFIG.particleCount*3);
            
            // åˆå§‹å…¨é›¶
            for(let i=0; i<pos.length; i++) pos[i]=0;

            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));

            material = new THREE.PointsMaterial({
                size: 2.0,
                map: tex,
                vertexColors: true,
                blending: THREE.AdditiveBlending, // å åŠ å‘å…‰
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // åˆå§‹åŒ– currentPositions ä¸ºä¹±åº
            currentPositions = new Float32Array(CONFIG.particleCount*3);
        }

        // --- æ ¸å¿ƒé€»è¾‘ ---

        function switchShape(idx) {
            STATE.shapeIndex = idx;
            STATE.mode = 'SHAPE';
            
            let targetArr, colors;
            let title = "";

            if(idx === 0) {
                targetArr = POSITIONS.TOWER; colors = CONFIG.colors.tower; title = "ğŸ­ ç»¿è‰²ç«ç”µ (Cooling Tower)";
            } else if(idx === 1) {
                targetArr = POSITIONS.WIND; colors = CONFIG.colors.wind; title = "âš¡ é£å…‰äº’è¡¥ (Wind & Solar)";
            } else if(idx === 2) {
                targetArr = POSITIONS.TOTEM; colors = CONFIG.colors.totem; title = "ğŸŒ€ èƒ½æºå›¾è…¾ (Energy Core)";
            } else {
                targetArr = POSITIONS.TEXT; colors = CONFIG.colors.text; title = "ğŸ’ å“ç‰Œæ„¿æ™¯ (Vision)";
            }

            updateStatus(title);

            // è®¾ç½®ç›®æ ‡ä½ç½®
            for(let i=0; i<CONFIG.particleCount*3; i++) {
                currentPositions[i] = targetArr[i];
            }

            // é‡æ–°è®¡ç®—é¢œè‰²
            const colAttr = geometry.attributes.color;
            for(let i=0; i<CONFIG.particleCount; i++) {
                // ç®€å•çš„é¢œè‰²åˆ†é…é€»è¾‘
                let c;
                if(idx === 0) { // å‡‰æ°´å¡”æ¸å˜
                    const y = targetArr[i*3+1];
                    const t = (y + 160) / 320;
                    c = colors[0].clone().lerp(colors[1], t); // è“åˆ°ç»¿
                } else if(idx === 1) { // é£å…‰
                    const y = targetArr[i*3+1];
                    c = y > -100 ? colors[0] : new THREE.Color(0xFFA500); // ä¸Šé¢é£æœºç»¿ï¼Œä¸‹é¢å…‰ä¼æ©™
                } else {
                    c = colors[Math.floor(Math.random()*colors.length)];
                }
                colAttr.setXYZ(i, c.r, c.g, c.b);
            }
            colAttr.needsUpdate = true;

            // ç…§ç‰‡å½’ä½ (éšè—åˆ°åœ°åº•)
            photos.forEach(p => {
                p.targetPos.set(0, -2000, 0);
            });
        }

        function switchScatter() {
            STATE.mode = 'SCATTER';
            updateStatus("ğŸ– ç”»å»Šæ¨¡å¼ (Gallery Mode)");
            
            // ç²’å­æ•£å¼€
            for(let i=0; i<CONFIG.particleCount*3; i++) {
                currentPositions[i] = POSITIONS.SCATTER[i];
            }
            
            // ç…§ç‰‡ç¯ç»•å¸ƒå±€
            const count = photos.length;
            photos.forEach((p, i) => {
                const angle = (i / count) * Math.PI * 2;
                const r = 220;
                p.targetPos.set(Math.cos(angle)*r, (Math.random()-0.5)*100, Math.sin(angle)*r);
                p.mesh.lookAt(0,0,0); // é¢å‘ä¸­å¿ƒ
                p.baseRot.copy(p.mesh.quaternion); // è®°å½•åŸºç¡€æ—‹è½¬
            });
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. ç²’å­è¿åŠ¨ (Lerp)
            const pos = geometry.attributes.position.array;
            for(let i=0; i<CONFIG.particleCount; i++) {
                const idx = i*3;
                pos[idx] += (currentPositions[idx] - pos[idx]) * 0.08;
                pos[idx+1] += (currentPositions[idx+1] - pos[idx+1]) * 0.08;
                pos[idx+2] += (currentPositions[idx+2] - pos[idx+2]) * 0.08;
                
                // æ¼‚æµ®ç‰¹æ•ˆ
                if(STATE.mode === 'SCATTER') pos[idx+1] += Math.sin(Date.now()*0.002 + i)*0.2;
            }
            geometry.attributes.position.needsUpdate = true;

            // 2. åœºæ™¯æ—‹è½¬
            if(STATE.mode === 'SHAPE') {
                // æ‰‹åŠ¿æ§åˆ¶æ—‹è½¬
                const tx = (virtualMouse.x - 0.5) * 2;
                const ty = (virtualMouse.y - 0.5) * 2;
                particles.rotation.y += (tx - particles.rotation.y) * 0.05;
                particles.rotation.x += (ty - particles.rotation.x) * 0.05;
            } else {
                // æ•£å¼€æ—¶è‡ªåŠ¨æ…¢æ—‹
                if(STATE.autoRotate) particles.rotation.y += 0.001;
            }

            // 3. ç…§ç‰‡é€»è¾‘ (ç£å¸å…‰æ ‡)
            updatePhotos();

            composer.render();
        }

        function updatePhotos() {
            if(STATE.mode !== 'SCATTER' && STATE.mode !== 'ZOOM') return;

            // å°„çº¿æ£€æµ‹
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera); // å§‹ç»ˆä»å±å¹•ä¸­å¿ƒå°„å‡º
            // æˆ–è€…ä½¿ç”¨é¼ æ ‡ä½ç½®
            // raycaster.setFromCamera(mouse, camera);

            // æ‰¾å‡ºé¼ æ ‡/å‡†æ˜ŸæŒ‡å‘çš„æ–¹å‘
            const camDir = new THREE.Vector3(); 
            camera.getWorldDirection(camDir);

            // å¯»æ‰¾æœ€è¿‘çš„ç…§ç‰‡
            let bestPhoto = null;
            let maxDot = 0.96; // è§’åº¦é˜ˆå€¼ (coså€¼)

            photos.forEach(p => {
                // åŸºç¡€ç§»åŠ¨
                p.mesh.position.lerp(p.targetPos, 0.1);
                
                if(p === grabbedPhoto) {
                    // è¢«æŠ“å–çŠ¶æ€
                    const target = camera.position.clone().add(camDir.clone().multiplyScalar(20)); // çœ¼å‰20ç±³
                    p.targetPos.copy(target);
                    p.mesh.lookAt(camera.position);
                    p.mesh.scale.lerp(new THREE.Vector3(1.5, 1.5, 1.5), 0.1);
                } else {
                    // æ‚¬åœ/å¸¸æ€
                    // è®¡ç®—è§†çº¿å¤¹è§’
                    const dirToPhoto = p.mesh.position.clone().sub(camera.position).normalize();
                    const dot = camDir.dot(dirToPhoto);
                    
                    if(STATE.mode === 'SCATTER' && dot > maxDot) {
                        maxDot = dot;
                        bestPhoto = p;
                    }

                    p.mesh.scale.lerp(new THREE.Vector3(0.5, 0.5, 0.5), 0.1);
                    // æ¢å¤æœå‘åœ†å¿ƒ
                    p.mesh.quaternion.slerp(p.baseRot, 0.1);
                }
            });

            // å¤„ç†é«˜äº®
            const cursor = document.getElementById('cursor-ring');
            if(bestPhoto && !grabbedPhoto) {
                hoveredPhoto = bestPhoto;
                hoveredPhoto.mesh.scale.lerp(new THREE.Vector3(0.7, 0.7, 0.7), 0.2); // å¾®å¾®æ”¾å¤§
                hoveredPhoto.mesh.lookAt(camera.position); // å¾®å¾®è½¬èº«
                cursor.className = 'hover';
            } else if(grabbedPhoto) {
                cursor.className = 'grab';
            } else {
                hoveredPhoto = null;
                cursor.className = '';
            }
        }

        // --- äº¤äº’äº‹ä»¶ ---
        function onMouseMove(e) {
            // é¼ æ ‡ä½ç½® (-1 to 1)
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            // è™šæ‹Ÿé¼ æ ‡ (0 to 1) ç”¨äºæ§åˆ¶æ—‹è½¬
            if(!STATE.isHandActive) {
                virtualMouse.x = 1 - (e.clientX / window.innerWidth);
                virtualMouse.y = e.clientY / window.innerHeight;
            }
        }

        function onMouseClick() {
            if(grabbedPhoto) {
                grabbedPhoto = null; // é‡Šæ”¾
                STATE.mode = 'SCATTER';
                updateStatus("ğŸ– é‡Šæ”¾ç…§ç‰‡");
            } else if(hoveredPhoto) {
                grabbedPhoto = hoveredPhoto; // æŠ“å–
                STATE.mode = 'ZOOM';
                updateStatus("ğŸ‘Œ å·²æŠ“å–");
            } else if(STATE.mode === 'SCATTER') {
                // ç‚¹å‡»ç©ºç™½å¤„åˆ‡æ¢å½¢æ€
                STATE.shapeIndex = (STATE.shapeIndex + 1) % 4;
                switchShape(STATE.shapeIndex);
            } else {
                switchScatter();
            }
        }

        function handleUpload(e) {
            const files = e.target.files;
            if(!files.length) return;
            // æ¸…ç†
            photos.forEach(p => photoGroup.remove(p.mesh)); photos = [];
            
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => {
                    const img = new Image(); img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.colorSpace = THREE.SRGBColorSpace;
                        const ar = img.width/img.height;
                        const mesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(10*ar, 10),
                            new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide })
                        );
                        // åŠ ä¸ªå‘å…‰è¾¹æ¡†
                        const border = new THREE.Mesh(
                            new THREE.PlaneGeometry(10*ar+0.5, 10.5),
                            new THREE.MeshBasicMaterial({ color: 0x00ffff })
                        );
                        border.position.z = -0.1;
                        mesh.add(border);
                        
                        photoGroup.add(mesh);
                        photos.push({
                            mesh: mesh,
                            targetPos: new THREE.Vector3(0, -2000, 0),
                            baseRot: new THREE.Quaternion(),
                            focus: false
                        });
                    }
                }
                r.readAsDataURL(f);
            });
            updateStatus(`å›¾åº“å·²æ›´æ–°: ${files.length} å¼ `);
            if(STATE.mode === 'SCATTER') switchScatter(); // ç«‹å³åˆ·æ–°å¸ƒå±€
        }

        function updateStatus(text) {
            document.getElementById('status-bar').innerText = text;
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- AI æ‰‹åŠ¿ ---
        function initMediaPipe() {
            const v = document.getElementById('video-element');
            const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6});
            
            hands.onResults(res => {
                if(!res.multiHandLandmarks.length) {
                    STATE.isHandActive = false;
                    return;
                }
                STATE.isHandActive = true;
                const lm = res.multiHandLandmarks[0];
                
                // 1. æ›´æ–°è™šæ‹Ÿé¼ æ ‡ä½ç½® (ç”¨äºæ—‹è½¬)
                // å¹³æ»‘æ’å€¼
                const tx = 1 - lm[9].x; 
                const ty = lm[9].y;
                virtualMouse.x += (tx - virtualMouse.x) * 0.2;
                virtualMouse.y += (ty - virtualMouse.y) * 0.2;

                // 2. è¯†åˆ«æ‰‹åŠ¿
                const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;
                let openCount = 0;
                [8,12,16,20].forEach(t => { if(lm[t].y < lm[t-2].y) openCount++; });

                // 3. é€»è¾‘è§¦å‘
                if(pinch) {
                    // æåˆï¼šå¦‚æœæœ‰æ‚¬åœç…§ç‰‡ï¼Œåˆ™æŠ“å–
                    if(STATE.mode === 'SCATTER' && hoveredPhoto) {
                        grabbedPhoto = hoveredPhoto;
                        STATE.mode = 'ZOOM';
                        updateStatus("ğŸ‘Œ æ‰‹åŠ¿æŠ“å–æˆåŠŸ");
                    }
                } else if(openCount >= 4) {
                    // å¼ å¼€ï¼šé‡Šæ”¾ç…§ç‰‡ æˆ– åˆ‡æ¢åˆ°æ•£å¼€
                    if(grabbedPhoto) {
                        grabbedPhoto = null;
                        STATE.mode = 'SCATTER';
                        updateStatus("ğŸ– ç…§ç‰‡é‡Šæ”¾");
                    } else if(STATE.mode === 'SHAPE') {
                        switchScatter();
                    }
                } else if(openCount <= 1) {
                    // æ¡æ‹³ï¼šèšåˆ / åˆ‡æ¢å½¢æ€
                    if(STATE.mode === 'SCATTER') {
                        STATE.shapeIndex = (STATE.shapeIndex + 1) % 4;
                        switchShape(STATE.shapeIndex);
                    }
                }
            });

            const cam = new Camera(v, {
                onFrame: async () => await hands.send({image: v}),
                width: 320, height: 240
            });
            cam.start();
        }
    </script>
</body>
</html>
