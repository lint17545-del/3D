<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D Interactive Horse - Final</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Arial', sans-serif; }
        
        /* è§†é¢‘æ¡†ç¨å¾®å¤§ä¸€ç‚¹ï¼Œæ–¹ä¾¿çœ‹æ‰‹åŠ¿ */
        #video-element { position: absolute; top: 20px; left: 20px; width: 200px; height: 150px; z-index: 2; transform: scaleX(-1); border: 2px solid #FFD700; border-radius: 12px; opacity: 0.6; }
        
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 28px; color: #FFD700; letter-spacing: 4px; text-shadow: 0 0 20px #C41E3A; }
        .status { font-size: 20px; color: #00ff00; margin-top: 15px; font-weight: bold; text-shadow: 0 0 5px #00ff00; }
        .tips { font-size: 14px; color: #aaa; margin-top: 5px; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; z-index: 20; font-size: 24px; text-align: center; background: rgba(0,0,0,0.8); padding: 40px; border-radius: 10px; border: 1px solid #FFD700;}
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åŠ è½½èµ„æº...<br><span style="font-size:16px; color:#fff">æ¨¡å‹æ”¾å¤§ä¸­ | ç²’å­ç³»ç»Ÿåˆå§‹åŒ–</span></div>
    
    <div id="ui-layer">
        <h1>å¾¡é©¬ Â· å¹»å¢ƒ</h1>
        <div class="status" id="status-text">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤...</div>
        <div class="tips">ğŸ– å¼ å¼€æ‰‹æŒï¼šæ“æ§æ˜Ÿäº‘æ—‹è½¬</div>
        <div class="tips">âœŠ æ¡ç´§æ‹³å¤´ï¼šèšåˆå¬å”¤æˆ˜é©¬</div>
    </div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- é…ç½®å‚æ•° ---
        const CONFIG = {
            particleCount: 5000, // ç²’å­æ•°é‡å¢åŠ 
            colors: [0x0F52BA, 0xFFD700, 0xC41E3A], // è“ã€é‡‘ã€çº¢
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb',
            scaleFactor: 0.6 // æ¨¡å‹æ”¾å¤§å€æ•° (åŸæ¥æ˜¯0.2)
        };

        let scene, camera, renderer, composer;
        let particles = [];
        let group;
        let state = 'CONVERGED';
        let time = 0;
        
        // æ‰‹åŠ¿äº¤äº’å˜é‡
        let handPosition = { x: 0.5, y: 0.5 }; // å½’ä¸€åŒ–åæ ‡ (0-1)
        let targetRotation = { x: 0, y: 0 };   // ç›®æ ‡æ—‹è½¬è§’åº¦

        init();
        animate();
        initMediaPipe();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.002);

            // ç›¸æœºæ›´è¿‘ï¼Œè§†é‡æ›´æœ‰å†²å‡»åŠ›
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 100); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç¯å…‰ç³»ç»Ÿ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 20);
            scene.add(dirLight);

            // è¾‰å…‰æ•ˆæœ
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.0;
            bloomPass.radius = 0.6;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            loadModel();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function loadModel() {
            const loader = new GLTFLoader();
            loader.load(CONFIG.modelUrl, (gltf) => {
                const model = gltf.scene;
                let mesh = null;
                model.traverse((child) => {
                    if (child.isMesh) mesh = child;
                });

                if(mesh) {
                    createParticlesFromMesh(mesh);
                }
                document.getElementById('loading').style.display = 'none';
            });
        }

        function createParticlesFromMesh(mesh) {
            group = new THREE.Group();
            scene.add(group);

            const posAttr = mesh.geometry.attributes.position;
            const count = posAttr.count;
            const targetPoints = [];
            const tempVec = new THREE.Vector3();

            // é‡‡æ · & æ”¾å¤§
            for(let i=0; i<count; i++) {
                tempVec.fromBufferAttribute(posAttr, i);
                
                // æ ¸å¿ƒä¿®æ”¹ï¼šæ”¾å¤§æ¨¡å‹å°ºå¯¸
                tempVec.multiplyScalar(CONFIG.scaleFactor);
                // è°ƒæ•´ä½ç½®å±…ä¸­
                tempVec.y -= 25; 

                targetPoints.push(tempVec.clone());
            }

            // æˆªå–ç‚¹ä½ï¼Œç¡®ä¿æ€§èƒ½
            // éšæœºæ‰“ä¹±æ•°ç»„ï¼Œè®©ç²’å­åˆ†å¸ƒæ›´å‡åŒ€
            targetPoints.sort(() => Math.random() - 0.5);
            const finalPoints = targetPoints.slice(0, CONFIG.particleCount);

            const geom = new THREE.BoxGeometry(0.8, 0.8, 0.8); // ç²’å­æœ¬èº«ä¹Ÿå˜å¤§
            const materials = CONFIG.colors.map(c => new THREE.MeshBasicMaterial({ color: c }));

            finalPoints.forEach((pt, i) => {
                const mat = materials[Math.floor(Math.random() * materials.length)];
                const pMesh = new THREE.Mesh(geom, mat);
                
                // æ•£å¼€ä½ç½®ï¼šç»™æ¯ä¸ªç²’å­ä¸€ä¸ªéšæœºçš„â€œå®¶â€
                const scatterPos = new THREE.Vector3(
                    (Math.random()-0.5) * 120,
                    (Math.random()-0.5) * 80,
                    (Math.random()-0.5) * 50
                );

                // ç»™æ¯ä¸ªç²’å­åˆ†é…ä¸€ä¸ªéšæœºçš„æ¼‚æµ®å‚æ•°ï¼Œè®©å®ƒä»¬åŠ¨èµ·æ¥ä¸ä¸€æ ·
                pMesh.userData = {
                    randomOffset: Math.random() * 100,
                    speed: 0.02 + Math.random() * 0.03
                };

                pMesh.position.copy(scatterPos);
                group.add(pMesh);

                particles.push({
                    mesh: pMesh,
                    targetPos: pt,
                    scatterPos: scatterPos
                });
            });
            
            // åˆå§‹çŠ¶æ€
            updateState('DISPERSED');
        }

        function updateState(newState) {
            if (state === newState) return;
            state = newState;
            
            const statusEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                statusEl.innerText = "çŠ¶æ€: âœŠ æˆ˜é©¬å½¢æ€";
                statusEl.style.color = "#FFD700";

                // é©¬å½¢æ€ï¼šè¿…é€Ÿå½’ä½
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.targetPos.x,
                        y: p.targetPos.y,
                        z: p.targetPos.z,
                        duration: 1.0,
                        ease: "back.out(1.2)" // å¸¦æœ‰å¼¹æ€§çš„åŠ¨ä½œ
                    });
                    gsap.to(p.mesh.rotation, { x: 0, y: 0, z: 0, duration: 1});
                });
                
                // é©¬å½¢æ€ä¸‹ï¼Œæ¨¡å‹è‡ªåŠ¨æ—‹è½¬å±•ç¤º
                gsap.to(group.rotation, { x: 0, z: 0, duration: 1 });

            } else if (state === 'DISPERSED') {
                statusEl.innerText = "çŠ¶æ€: ğŸ– çµèƒ½æ˜Ÿäº‘ (è·Ÿéšæ‰‹åŠ¿)";
                statusEl.style.color = "#00ffff";

                // æ•£å¼€æ€ï¼šé£å›éšæœºä½ç½®
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.scatterPos.x,
                        y: p.scatterPos.y,
                        z: p.scatterPos.z,
                        duration: 1.5,
                        ease: "power2.out"
                    });
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            if (!group) return;

            if (state === 'DISPERSED') {
                // --- 1. ç²’å­æ´»æ€§åŒ– (è®©ç²’å­å³ä½¿ä¸åŠ¨æ‰‹ä¹Ÿåœ¨æ¸¸åŠ¨) ---
                particles.forEach(p => {
                    const offset = p.mesh.userData.randomOffset;
                    const speed = p.mesh.userData.speed;
                    // åœ¨æ•£å¼€ä½ç½®çš„åŸºç¡€ä¸Šç”±äºæ­£å¼¦æ³¢è¿›è¡Œå¾®è°ƒ
                    // æˆ‘ä»¬åªåœ¨æ¸²æŸ“å±‚ä¿®æ”¹ä½ç½®ï¼Œä¸æ”¹å˜scatterPosæ•°æ®
                    // è¿™é‡Œç›´æ¥æ“ä½œmeshä½ç½®ä¸å¤ªå¥½ï¼Œå› ä¸ºGSAPåœ¨æ§åˆ¶å®ƒã€‚
                    // æ›´å¥½çš„åšæ³•æ˜¯ï¼šGSAPæ§åˆ¶å®¹å™¨ï¼Œæˆ‘ä»¬å¾®è°ƒå®¹å™¨ï¼Ÿæˆ–è€…åªåœ¨GSAPåŠ¨ç”»ç»“æŸåå¾®è°ƒã€‚
                    // ä¸ºäº†ç®€å•æœ‰æ•ˆï¼Œæˆ‘ä»¬å åŠ ä¸€ä¸ªå¾®å°çš„åç§»é‡ç»™ group æˆ–è€…å•ç‹¬è®¡ç®—
                    
                    // ç®€å•æ–¹æ¡ˆï¼šå¦‚æœåŠ¨ç”»æ²¡åœ¨è·‘ï¼Œå°±åŠ ä¸€ç‚¹å™ªéŸ³
                    if(!gsap.isTweening(p.mesh.position)) {
                         p.mesh.position.y += Math.sin(time * speed + offset) * 0.05;
                         p.mesh.position.x += Math.cos(time * speed + offset) * 0.05;
                    }
                });

                // --- 2. æ‰‹åŠ¿è·Ÿéš (æ ¸å¿ƒé€»è¾‘) ---
                // è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦ï¼šæ‰‹åœ¨å·¦è¾¹ï¼Œé©¬å¾€å·¦è½¬ï¼›æ‰‹åœ¨ä¸Šé¢ï¼Œé©¬å¾€ä¸Šçœ‹
                // handPosition.x: 0(å·¦) -> 1(å³)
                // handPosition.y: 0(ä¸Š) -> 1(ä¸‹)
                
                // ç›®æ ‡ Y è½´æ—‹è½¬ (å·¦å³): -1 åˆ° 1 å¼§åº¦
                const targetRotY = (handPosition.x - 0.5) * 3; 
                // ç›®æ ‡ X è½´æ—‹è½¬ (ä¸Šä¸‹): -0.5 åˆ° 0.5 å¼§åº¦
                const targetRotX = (handPosition.y - 0.5) * 1.5;

                // ä½¿ç”¨ lerp å¹³æ»‘è¿‡æ¸¡ï¼Œé¿å…æŠ–åŠ¨
                group.rotation.y = THREE.MathUtils.lerp(group.rotation.y, targetRotY, 0.05);
                group.rotation.x = THREE.MathUtils.lerp(group.rotation.x, targetRotX, 0.05);

            } else {
                // èšåˆæ€ï¼šè‡ªåŠ¨æ…¢æ…¢æ—‹è½¬å±•ç¤º
                group.rotation.y += 0.005;
            }

            composer.render();
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('video-element');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) return;
                
                const lm = results.multiHandLandmarks[0];
                
                // 1. æ›´æ–°æ‰‹æŒä¸­å¿ƒä½ç½® (ç”¨äºæ§åˆ¶æ–¹å‘)
                // å– 0(æ‰‹è…•) å’Œ 9(ä¸­æŒ‡æ ¹éƒ¨) çš„ä¸­é—´ç‚¹ä½œä¸ºæ‰‹æŒä¸­å¿ƒï¼Œæ¯”å•çº¯å–æŸä¸ªç‚¹æ›´ç¨³
                const palmX = (lm[0].x + lm[9].x) / 2;
                const palmY = (lm[0].y + lm[9].y) / 2;
                
                // MediaPipe çš„ x åæ ‡ä¹Ÿæ˜¯åçš„(å› ä¸ºæˆ‘ä»¬é•œåƒäº†è§†é¢‘)ï¼Œæ‰€ä»¥å¯èƒ½éœ€è¦åè½¬
                // ä½†æˆ‘ä»¬åœ¨CSSé‡Œ transform: scaleX(-1) åªæ˜¯è§†è§‰é•œåƒï¼Œæ•°æ®å¯èƒ½æ˜¯åŸå§‹çš„
                // é€šå¸¸ MediaPipe è¾“å‡ºï¼šx=0 æ˜¯ç”»é¢å·¦è¾¹ã€‚
                // æˆ‘ä»¬ç›´æ¥æ˜ å°„ç»™ handPosition
                handPosition.x = 1 - palmX; // åè½¬ä¸€ä¸‹ç¬¦åˆç›´è§‰ï¼ˆæ‰‹å¾€å³ç§»ï¼Œç”»é¢å¾€å³è½¬ï¼‰
                handPosition.y = palmY;

                // 2. çŠ¶æ€åˆ¤å®š (å¼ å¼€ vs æ¡æ‹³)
                const tips = [8, 12, 16, 20];
                const bases = [5, 9, 13, 17];
                let openCount = 0;
                tips.forEach((tip, i) => {
                    if (lm[tip].y < lm[bases[i]].y) openCount++;
                });

                if (openCount >= 3) {
                    updateState('DISPERSED');
                } else if (openCount <= 1) { // ä¸¥æ ¼ä¸€ç‚¹ï¼Œåªå‰©ä¸€ä¸ªæ‰‹æŒ‡æˆ–å…¨æ¡
                    updateState('CONVERGED');
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start();
        }
    </script>
</body>
</html>
