<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>SPIC V13 - Native Smooth Interaction</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010103; font-family: 'Microsoft YaHei', sans-serif; }
        
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 2px solid rgba(255, 215, 0, 0.4); border-radius: 8px; opacity: 0.6; }
        
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; user-select: none; }
        h1 { margin: 0; font-size: 26px; color: #FFD700; letter-spacing: 2px; text-shadow: 0 0 15px rgba(255, 69, 0, 0.6); }
        .cycle-info { font-size: 22px; margin-top: 10px; color: #fff; font-weight: bold; transition: color 0.5s; text-shadow: 0 0 10px currentColor; }
        .status { font-size: 16px; color: rgba(255,255,255,0.8); margin-top: 8px; background: rgba(0,0,0,0.6); padding: 4px 12px; border-radius: 20px; display: inline-block;}
        
        #upload-container { pointer-events: auto; display: inline-block; margin-top: 25px; }
        input[type="file"] { display: none; }
        .btn { background: linear-gradient(135deg, #FFD700, #FF4500); border: none; padding: 10px 25px; color: #fff; font-size: 14px; font-weight: bold; cursor: pointer; border-radius: 30px; box-shadow: 0 0 20px rgba(255, 69, 0, 0.3); }
        .btn:hover { transform: scale(1.05); background: linear-gradient(135deg, #FFD700, #FF0000); }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; z-index: 20; font-size: 18px; text-align: center; }
        #hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 13px; pointer-events: none; }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨å¤åˆ»äº¤äº’å†…æ ¸...<br>ç”Ÿæˆ SPIC å·¥ä¸šåœºæ™¯</div>

    <div id="ui-layer">
        <h1>SPIC èƒ½æºè§†ç•Œ V13</h1>
        <div class="cycle-info" id="shape-name" style="color:#FFD700">ğŸ æˆ˜é©¬å½¢æ€</div>
        <div class="status" id="gesture-status">ç­‰å¾…æ‘„åƒå¤´...</div>
        <div id="upload-container">
            <label class="btn">+ æ³¨å…¥ç…§ç‰‡ <input type="file" id="file-input" multiple accept="image/*"></label>
        </div>
    </div>
    <div id="hint">âœŠæ¡æ‹³:èšåˆ | ğŸ–å¼ å¼€:æ•£å¼€/é‡Šæ”¾ | ğŸ‘Œæåˆ:ç£å¸æŠ“å–</div>
    
    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="genCanvas" width="2048" height="1024" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- é…ç½® ---
        const CONFIG = {
            particleCount: 16000,
            cameraZ: 400, // é€‚åº”å¤§åœºæ™¯
            colors: {
                horse: [0xD4AF37, 0xC41E3A, 0xFFD700, 0x8B0000],
                text: [0x88CCFF],
                towerTop: new THREE.Color(0x87CEEB), towerBottom: new THREE.Color(0x228B22),
                wind: 0x00FF7F, solar: 0xFFA500
            }
        };

        // --- æ ¸å¿ƒçŠ¶æ€ ---
        const STATE = { 
            mode: 'CONVERGED', // CONVERGED (èšåˆ), SCATTER (æ•£å¼€), ZOOM (æŠ“å–)
            handVisible: false, 
            handX: 0.5, handY: 0.5, 
            gesture: 'NONE',
            shapeIndex: 0 // 0:Horse, 1:Text, 2:Tower, 3:WindSolar
        };

        let scene, camera, renderer, composer;
        let particlesData = []; // { mesh, cur, targets: [], speed }
        let photosData = [];    // { mesh, cur, home, scatter, focus, velocity }
        let mainGroup, photoGroup;
        
        // ä½ çš„é˜²æ™•ç›¸æœºå˜é‡
        let lookAtTarget = new THREE.Vector3(0, 0, 0);
        let currentLookAt = new THREE.Vector3(0, 0, 0);
        let raycaster = new THREE.Raycaster();
        
        // å½¢çŠ¶æ•°æ®ç¼“å­˜
        const SHAPES = { HORSE:[], TEXT:[], TOWER:[], WIND_SOLAR:[] };

        initThree();
        initMediaPipe();

        async function initThree() {
            const container = document.getElementById('canvas-container');
            
            // 1. åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x010103, 0.0008);

            // 2. ç›¸æœº (æ²¿ç”¨ä½ çš„é€»è¾‘)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 5000);
            camera.position.set(0, 0, CONFIG.cameraZ);

            // 3. æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // å¢åŠ ç”µå½±æ„Ÿ
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            // 4. ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const sun = new THREE.DirectionalLight(0xFFD700, 1.5); sun.position.set(100, 100, 100); scene.add(sun);
            const blue = new THREE.PointLight(0x0088FF, 2, 600); blue.position.set(-100, 0, 100); scene.add(blue);

            // 5. åå¤„ç† (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; bloomPass.strength = 1.0; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 6. åˆ†ç»„
            mainGroup = new THREE.Group();
            photoGroup = new THREE.Group();
            scene.add(mainGroup);
            scene.add(photoGroup);

            // 7. ç”Ÿæˆå†…å®¹ (æ ¸å¿ƒé€»è¾‘ç§»å…¥)
            await generateAllShapes();
            createParticles();

            // 8. äº‹ä»¶
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            });
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            document.getElementById('loading').style.display = 'none';
            
            animate();
        }

        // --- å½¢æ€ç”Ÿæˆé€»è¾‘ (V12 Procedural + Horse Fallback) ---
        async function generateAllShapes() {
            // A. é©¬ (å°è¯•åŠ è½½)
            try {
                await new Promise((resolve, reject) => {
                    const loader = new GLTFLoader();
                    const t = setTimeout(() => reject("timeout"), 4000);
                    loader.load('https://threejs.org/examples/models/gltf/Horse.glb', (gltf) => {
                        clearTimeout(t);
                        SHAPES.HORSE = samplePoints(getPointsFromMesh(gltf.scene.children[0], 1.4), CONFIG.particleCount);
                        resolve();
                    }, undefined, reject);
                });
            } catch(e) {
                console.warn("Using fallback horse");
                SHAPES.HORSE = generateSphereFallback(CONFIG.particleCount);
            }
            // B. æ–‡å­—
            SHAPES.TEXT = generateTextPoints("é£å…‰æ— é™  å›½å®¶ç”µæŠ•");
            // C. å‡‰æ°´å¡” (åŒæ›²çº¿)
            SHAPES.TOWER = generateProceduralTower(CONFIG.particleCount);
            // D. é£å…‰äº’è¡¥
            SHAPES.WIND_SOLAR = generateProceduralWindSolar(CONFIG.particleCount);
        }

        // (å¤ç”¨ä¹‹å‰çš„ç”Ÿæˆå‡½æ•°ï¼Œç¡®ä¿ 0 å»¶è¿Ÿ)
        function generateProceduralTower(count) {
            const pts=[]; const h=300;
            for(let i=0; i<count; i++) {
                const y=(Math.random()-0.5)*h; const v=y/(h/2);
                let r=60 * Math.sqrt(1 + Math.pow(v,2)*0.5); if(v<0) r*=(1+Math.abs(v)*0.4);
                const ang=Math.random()*Math.PI*2;
                const p=new THREE.Vector3(r*Math.cos(ang), y, r*Math.sin(ang));
                p.ratio = (y+h/2)/h; pts.push(p);
            }
            return samplePoints(pts, count);
        }

        function generateProceduralWindSolar(count) {
            const pts=[];
            const addCyl = (x,z,r,h,isW) => { for(let i=0;i<h*2;i++){ const py=(Math.random()-0.5)*h; const a=Math.random()*6.28; const cr=r*(1-(py+h/2)/h*0.4); pts.push({pos:new THREE.Vector3(x+Math.cos(a)*cr,py,z+Math.sin(a)*cr),isW});}};
            const addBld = (x,y,z,sz) => { for(let k=0;k<3;k++){ for(let i=0;i<300;i++){ const l=Math.random()*sz; const a=(k/3)*6.28; pts.push({pos:new THREE.Vector3(x+Math.cos(a)*l,y+Math.sin(a)*l,z+(Math.random()-0.5)*5),isW:true});}}};
            const addPnl = (x,y,z,w,h) => { for(let i=0;i<60;i++){ const px=(Math.random()-0.5)*w; const pz=(Math.random()-0.5)*h; pts.push({pos:new THREE.Vector3(x+px, y+pz*0.5, z+pz*0.866),isS:true});}};
            
            addCyl(-120,-50,8,200,true); addBld(-120,100,-45,110);
            addCyl(100,80,5,150,true); addBld(100,75,85,80);
            for(let r=0;r<4;r++) for(let c=0;c<6;c++) addPnl((c-3)*50, -120, (r-2)*40+50, 40, 25);
            return samplePoints(pts.map(p=>{let v=p.pos;v.isW=p.isW;v.isS=p.isS;return v;}), count);
        }

        function generateTextPoints(t){
            const c=document.getElementById('genCanvas').getContext('2d'); c.clearRect(0,0,2048,1024);
            c.font="bold 200px 'Microsoft YaHei'"; c.fillStyle="white"; c.textAlign="center"; c.textBaseline="middle"; c.fillText(t,1024,512);
            const d=c.getImageData(0,0,2048,1024).data; const p=[];
            for(let y=0;y<1024;y+=6)for(let x=0;x<2048;x+=6)if(d[(y*2048+x)*4+3]>128)p.push(new THREE.Vector3((x-1024)*0.3,-(y-512)*0.3,(Math.random()-0.5)*15));
            return samplePoints(p, CONFIG.particleCount);
        }
        function generateSphereFallback(c){const p=[];for(let i=0;i<c;i++)p.push(new THREE.Vector3((Math.random()-0.5)*200,(Math.random()-0.5)*200,(Math.random()-0.5)*200));return p;}
        function getPointsFromMesh(m,s){const p=[];const a=m.geometry.attributes.position;const v=new THREE.Vector3();for(let i=0;i<a.count;i++)p.push(v.fromBufferAttribute(a,i).multiplyScalar(s).clone());return p;}
        function samplePoints(s,c){if(!s.length)return[];const b=new THREE.Box3().setFromPoints(s);const ct=b.getCenter(new THREE.Vector3());s.forEach(p=>p.sub(ct));const r=[];for(let i=0;i<c;i++){const p=s[i%s.length].clone(); Object.assign(p,s[i%s.length]); r.push(p);}return r.sort(()=>Math.random()-0.5);}

        // --- ç²’å­ç³»ç»Ÿ ---
        function createParticles() {
            const geom = new THREE.SphereGeometry(0.5, 6, 6);
            for(let i=0; i<CONFIG.particleCount; i++) {
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const mesh = new THREE.Mesh(geom, mat);
                const scatter = new THREE.Vector3((Math.random()-0.5)*1000, (Math.random()-0.5)*800, (Math.random()-0.5)*1000);
                mesh.position.copy(scatter);
                mainGroup.add(mesh);
                
                particlesData.push({
                    mesh: mesh,
                    cur: scatter.clone(),
                    targets: [SHAPES.HORSE[i], SHAPES.TEXT[i], SHAPES.TOWER[i], SHAPES.WIND_SOLAR[i]],
                    scat: scatter,
                    speed: 0.01 + Math.random() * 0.04 // ä½ çš„åŸç”Ÿæ‰‹æ„Ÿæ ¸å¿ƒï¼šéšæœºé€Ÿåº¦ Lerp
                });
            }
            updateParticleColors(0);
        }

        function updateParticleColors(idx) {
            const ui = document.getElementById('shape-name');
            let colors;
            if(idx===0) { ui.innerText="ğŸ æˆ˜é©¬å½¢æ€ (çº¢é‡‘)"; ui.style.color="#FFD700"; colors=CONFIG.colors.horse; }
            else if(idx===1) { ui.innerText="ğŸ’ æ–‡å­—å½¢æ€ (æ˜Ÿå…‰è“)"; ui.style.color="#88CCFF"; colors=CONFIG.colors.text; }
            else if(idx===2) { ui.innerText="ğŸ­ å‡‰æ°´å¡” (å½©ç»˜æ¸å˜)"; ui.style.color="#00BFFF"; colors=CONFIG.colors.towerBottom; }
            else { ui.innerText="âš¡ é£å…‰äº’è¡¥ (ç»¿è‰²èƒ½æº)"; ui.style.color="#00FF00"; colors=CONFIG.colors.wind; }

            particlesData.forEach((d, i) => {
                let hex;
                if(idx===2) { // å‡‰æ°´å¡”æ¸å˜
                    const r = d.targets[2].ratio || 0.5;
                    d.mesh.material.color.lerpColors(CONFIG.colors.towerBottom, CONFIG.colors.towerTop, r);
                } else if(idx===3) { // é£å…‰
                    d.mesh.material.color.setHex(d.targets[3].isS ? CONFIG.colors.solar : CONFIG.colors.wind);
                } else {
                    d.mesh.material.color.setHex(colors[Math.floor(Math.random()*colors.length)]);
                }
            });
        }

        // --- ä½ çš„ç…§ç‰‡é€»è¾‘ (å®Œç¾å¤åˆ») ---
        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            // æ¸…ç†æ—§ç…§ç‰‡
            photosData.forEach(p => photoGroup.remove(p.mesh)); photosData = [];
            
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { 
                    const img = new Image(); img.src = ev.target.result; 
                    img.onload = () => createPhoto(img); 
                };
                r.readAsDataURL(f);
            });
            document.getElementById('gesture-status').innerText = `Loaded ${files.length} photos`;
        }

        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.colorSpace = THREE.SRGBColorSpace;
            const aspect = img.width/img.height;
            // ä½ çš„åŸç‰ˆç…§ç‰‡æ¡†é€»è¾‘
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(10*aspect, 10), mat);
            const frame = new THREE.Mesh(new THREE.BoxGeometry(10*aspect+0.5, 10.5, 0.2), new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.4}));
            mesh.position.z = 0.11; frame.add(mesh);

            // åˆå§‹ä½ç½®
            const scatter = new THREE.Vector3((Math.random()-0.5)*900, (Math.random()-0.5)*700, (Math.random()-0.5)*900);
            frame.position.copy(scatter);
            
            // å½’ä½ä½ç½® (å›´ç»•ä¸­å¿ƒ)
            const angle = Math.random() * Math.PI * 2;
            const r = 180 + Math.random()*50;
            const home = new THREE.Vector3(Math.cos(angle)*r, (Math.random()-0.5)*150, Math.sin(angle)*r);

            photoGroup.add(frame);
            photosData.push({
                mesh: frame,
                cur: scatter.clone(),
                home: home,
                scat: scatter,
                focus: false // æ˜¯å¦è¢«æŠ“å–
            });
        }

        // --- æ ¸å¿ƒåŠ¨ç”»å¾ªç¯ (å¤åˆ»ä½ çš„ Lerp é€»è¾‘) ---
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.0005;

            // 1. ç²’å­è¿åŠ¨
            // è¿™é‡Œæˆ‘ä»¬ä¸ä½¿ç”¨ GSAPï¼Œè€Œæ˜¯ç”¨ä½ å–œæ¬¢çš„æ¯å¸§ lerpï¼Œè¿™æ ·æ‰‹æ„Ÿæ‰â€œç²˜æ»â€
            for(let i=0; i<CONFIG.particleCount; i++) {
                const d = particlesData[i];
                let tgt;
                if(STATE.mode === 'CONVERGED') tgt = d.targets[STATE.shapeIndex];
                else tgt = d.scat;

                // æ•£å¼€æ—¶åŠ ç‚¹æµåŠ¨
                if(STATE.mode !== 'CONVERGED') d.cur.y += Math.sin(time + i*0.1) * 0.05;

                // æ ¸å¿ƒï¼šLerp
                d.cur.lerp(tgt, d.speed);
                d.mesh.position.copy(d.cur);
            }

            // 2. ç…§ç‰‡è¿åŠ¨
            photosData.forEach(p => {
                let tgt;
                let scale = 1;
                
                if(p.focus) {
                    // æŠ“å–çŠ¶æ€ï¼šé£åˆ°ç›¸æœºæ­£å‰æ–¹ 20 å•ä½å¤„
                    const v = new THREE.Vector3(0, 0, -20).applyQuaternion(camera.quaternion);
                    tgt = camera.position.clone().add(v);
                    p.mesh.lookAt(camera.position); // å¼ºåˆ¶å¯¹é½
                    scale = 4.0; // æ”¾å¤§
                } else {
                    // æ­£å¸¸çŠ¶æ€
                    tgt = (STATE.mode === 'CONVERGED') ? p.home : p.scat;
                    p.mesh.lookAt(camera.position); // å§‹ç»ˆé¢å‘è§‚ä¼—
                }

                // æ ¸å¿ƒï¼šLerp
                p.cur.lerp(tgt, 0.04); // 0.04 æ˜¯ä½ ä¹‹å‰ä»£ç é‡Œçš„â€œè½¯â€ç³»æ•°
                p.mesh.position.copy(p.cur);
                p.mesh.scale.lerp(new THREE.Vector3(scale, scale, scale), 0.1);
            });

            // 3. ç›¸æœºæ§åˆ¶ (ä½ çš„ Anti-Dizzy é€»è¾‘)
            updateCamera();

            composer.render();
        }

        function updateCamera() {
            // å¦‚æœæ‰‹åŠ¿æ•£å¼€ï¼Œæ‰‹å¯ä»¥æ§åˆ¶è§†è§’
            if(STATE.mode === 'SCATTER' && STATE.handVisible) {
                // æ‰‹å¾€å·¦ç§»(x<0.5)ï¼Œçœ‹å‘å·¦è¾¹(xè´Ÿå€¼)
                // ä½ çš„ä»£ç é‡Œæ˜¯ (x-0.5)*100
                lookAtTarget.x = (STATE.handX - 0.5) * 150; 
                lookAtTarget.y = (0.5 - STATE.handY) * 100;
                lookAtTarget.z = -50;
            } else {
                // èšåˆæ€ï¼Œå›æ­£
                lookAtTarget.set(0, 0, 0);
            }

            // å¹³æ»‘ LookAtï¼Œè¿™æ‰æ˜¯é˜²æ™•çš„å…³é”®
            currentLookAt.lerp(lookAtTarget, 0.05);
            camera.lookAt(currentLookAt);
        }

        // --- MediaPipe & å°„çº¿æŠ“å– ---
        function initMediaPipe() {
            const v = document.getElementById('video-element');
            const h = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            h.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6});
            
            h.onResults(res => {
                const st = document.getElementById('gesture-status');
                if(res.multiHandLandmarks.length) {
                    STATE.handVisible = true;
                    const lm = res.multiHandLandmarks[0];
                    // å¹³æ»‘æ‰‹åŠ¿åæ ‡
                    STATE.handX = STATE.handX * 0.8 + (1 - lm[0].x) * 0.2;
                    STATE.handY = STATE.handY * 0.8 + lm[0].y * 0.2;

                    const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;
                    let open=0; [8,12,16,20].forEach((t,i)=>{if(lm[t].y < lm[5+i*4].y) open++});

                    if(pinch) {
                        STATE.gesture = 'PINCH';
                        st.innerText = "ğŸ‘Œ æåˆæŠ“å– (ç„å‡†ç…§ç‰‡)";
                        raycastGrab(); // ä½ çš„å®½å®¹æŠ“å–é€»è¾‘
                    } else if(open >= 4) {
                        STATE.gesture = 'OPEN';
                        // é€»è¾‘ï¼šå¦‚æœæ˜¯æŠ“å–ä¸­å¼ å¼€ï¼Œåˆ™é‡Šæ”¾ï¼›å¦åˆ™åˆ‡æ¢åˆ°æ•£å¼€
                        if(STATE.mode === 'ZOOM') {
                            STATE.mode = 'SCATTER'; resetPhoto();
                        } else if(STATE.mode !== 'SCATTER') {
                            STATE.mode = 'SCATTER';
                            // æ•£å¼€æ—¶ä¹Ÿé¡ºä¾¿åˆ‡æ¢ä¸‹ä¸€ä¸ªå½¢çŠ¶ï¼Œä¸ºä¸‹æ¬¡èšåˆåšå‡†å¤‡
                            STATE.shapeIndex = (STATE.shapeIndex + 1) % 4;
                            updateParticleColors(STATE.shapeIndex);
                        }
                        st.innerText = "ğŸ– å¼ å¼€ (æ•£å¼€/é‡Šæ”¾)";
                    } else if(open <= 1) {
                        STATE.gesture = 'FIST';
                        if(STATE.mode !== 'CONVERGED') {
                            STATE.mode = 'CONVERGED'; resetPhoto();
                        }
                        st.innerText = "âœŠ æ¡æ‹³ (èšåˆ)";
                    }
                } else {
                    STATE.handVisible = false;
                    st.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                }
            });
            new Camera(v, {onFrame: async()=>{await h.send({image:v})}, width:320, height:240}).start();
        }

        // ä½ çš„å®½å®¹æŠ“å–é€»è¾‘ (Easy Grab)
        function raycastGrab() {
            if(STATE.mode === 'ZOOM' || photosData.length === 0) return;
            
            // 1. å°è¯•ç²¾å‡†å°„çº¿
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera); // æ°¸è¿œä»å±å¹•ä¸­å¿ƒå°„å‡º
            const intersects = raycaster.intersectObjects(photoGroup.children, true);
            if(intersects.length > 0) {
                activatePhoto(intersects[0].object.parent || intersects[0].object);
                return;
            }

            // 2. å°è¯•æ¨¡ç³Šå¸é™„ (ä½ çš„é€»è¾‘)
            let closest = null; let minAngle = Infinity;
            const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
            
            photosData.forEach(p => {
                const toPhoto = p.mesh.position.clone().sub(camera.position).normalize();
                const angle = camDir.angleTo(toPhoto);
                // åªè¦åœ¨è§†çº¿å¤¹è§’ 0.3 å¼§åº¦(çº¦17åº¦)å†…ï¼Œå°±ç®—ç„å‡†äº†
                if(angle < 0.3 && angle < minAngle) {
                    minAngle = angle; closest = p;
                }
            });
            
            if(closest) activatePhoto(closest.mesh);
        }

        function activatePhoto(mesh) {
            resetPhoto();
            STATE.mode = 'ZOOM';
            // æ‰¾åˆ°å¯¹åº”çš„æ•°æ®å¯¹è±¡
            const data = photosData.find(p => p.mesh === mesh);
            if(data) data.focus = true;
            document.getElementById('gesture-status').innerText = "å·²æŠ“å–! (å¼ æ‰‹é‡Šæ”¾)";
        }

        function resetPhoto() {
            photosData.forEach(p => p.focus = false);
        }
    </script>
</body>
</html>
