<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>SPIC Interactive V11 - Model Based Final</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010103; font-family: 'Microsoft YaHei', sans-serif; }
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 2px solid rgba(0, 200, 255, 0.4); border-radius: 8px; opacity: 0.5; }
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 26px; color: #FFD700; letter-spacing: 2px; text-shadow: 0 0 20px rgba(0, 100, 255, 0.6); font-weight: bold; }
        .cycle-info { font-size: 22px; margin-top: 10px; color: #fff; font-weight: bold; transition: all 0.5s; text-shadow: 0 0 10px currentColor; }
        .status { font-size: 16px; color: rgba(255,255,255,0.8); margin-top: 8px; background: rgba(0,0,0,0.6); padding: 4px 12px; border-radius: 20px; display: inline-block;}
        #upload-container { pointer-events: auto; display: inline-block; margin-top: 25px; }
        input[type="file"] { display: none; }
        .btn { background: linear-gradient(135deg, #FFD700, #FF4500); border: none; padding: 12px 25px; color: #fff; font-size: 14px; font-weight: bold; cursor: pointer; border-radius: 30px; box-shadow: 0 0 20px rgba(255, 69, 0, 0.4); transition: transform 0.2s; }
        .btn:hover { transform: scale(1.05); }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ffff; z-index: 20; font-size: 18px; text-align: center; letter-spacing: 1px; line-height: 1.5; }
        #hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 14px; pointer-events: none; letter-spacing: 1px; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loading">æ­£åœ¨åŠ è½½é«˜ç²¾åº¦å·¥ä¸šæ¨¡å‹...<br>è¿™å¯èƒ½éœ€è¦åå‡ ç§’é’Ÿï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚</div>
    
    <div id="ui-layer">
        <h1>SPIC èƒ½æºè§†ç•Œ V11</h1>
        <div class="cycle-info" id="shape-name" style="color:#FFD700">ğŸ æˆ˜é©¬å½¢æ€</div>
        <div class="status" id="status-text">ç­‰å¾…æ‰‹åŠ¿...</div>
        <div id="upload-container">
            <label class="btn">+ æ³¨å…¥è®°å¿†ç…§ç‰‡ <input type="file" id="file-input" multiple accept="image/*"></label>
        </div>
    </div>
    <div id="hint">âœŠèšåˆ(æ—‹è½¬) | ğŸ–å¼ å¼€(æ•£å¼€/é‡Šæ”¾ç…§ç‰‡) | ğŸ‘Œæåˆ(æŠ“å–ç…§ç‰‡è‡³çœ¼å‰)</div>
    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="genCanvas" width="2048" height="1024" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- æ ¸å¿ƒé…ç½® (ä½¿ç”¨å…¬å…±æ¨¡å‹åº“) ---
        const CONFIG = {
            particleCount: 16000,
            maxPhotos: 30,
            // ä½¿ç”¨å…¬å…±å¯è®¿é—®çš„ GLB æ¨¡å‹é“¾æ¥
            urls: {
                horse: 'https://threejs.org/examples/models/gltf/Horse.glb',
                // ä½¿ç”¨ github raw æˆ–å…¶ä»– CDN æ‰˜ç®¡çš„ä½æ¨¡
                tower: 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMilkTruck/glTF-Binary/CesiumMilkTruck.glb', // ä¸´æ—¶æ›¿æ¢ä¸ºå¿…å®šèƒ½åŠ è½½çš„æ¨¡å‹æµ‹è¯•ï¼Œç¨åæ›¿æ¢çœŸå®é“¾æ¥
                wind: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/LittlestTokyo.glb', // ä¸´æ—¶æ›¿æ¢
                solar: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/ferrari.glb' // ä¸´æ—¶æ›¿æ¢
            },
            colors: {
                horse: [0xD4AF37, 0xC41E3A, 0xFFD700, 0x8B0000],
                text: [0x88CCFF],
                towerTop: new THREE.Color(0x87CEEB), // å¤©è“
                towerBottom: new THREE.Color(0x228B22), // è‰ç»¿
                wind: 0x00FF7F, solar: 0xFFA500
            }
        };
        
        // **é‡è¦æç¤º**ï¼šç”±äºæ²¡æœ‰æ‰¾åˆ°æå…¶åˆé€‚çš„ã€æ— éœ€è·¨åŸŸçš„å…è´¹å…¬å…±å‡‰æ°´å¡”/é£æœº/å…‰ä¼ GLB ç›´é“¾ï¼Œ
        // ä¸ºäº†ä¿è¯ä»£ç èƒ½ç›´æ¥è¿è¡Œæ¼”ç¤ºæ•ˆæœï¼Œæˆ‘æš‚æ—¶ä½¿ç”¨äº† Three.js å®˜æ–¹ç¤ºä¾‹ä¸­çš„å…¶ä»–æ¨¡å‹ä½œä¸ºå ä½ç¬¦æ¥æ¼”ç¤ºåŠ è½½é€»è¾‘ã€‚
        // **æ­£å¼ä½¿ç”¨æ—¶ï¼Œè¯·åŠ¡å¿…ä¸‹è½½çœŸå®çš„å‡‰æ°´å¡”ã€é£æœºã€å…‰ä¼ GLB æ–‡ä»¶ï¼Œæ”¾åˆ°æœ¬åœ°é¡¹ç›®ç›®å½•ï¼Œå¹¶ä¿®æ”¹ CONFIG.urls æŒ‡å‘æœ¬åœ°æ–‡ä»¶ã€‚**
        // ä¾‹å¦‚: tower: './assets/cooling_tower.glb'

        let scene, camera, renderer, composer, mainGroup, photoGroup;
        let particles = []; let photoClouds = [];
        let state = 'CONVERGED'; let time = 0;
        let handPosition = { x: 0.5, y: 0.5 };
        
        // 3Dç…§ç‰‡æŠ“å–ç›¸å…³
        let activeZoomPhoto = null;
        let isZoomLocked = false;

        let currentShapeIndex = 0;
        const SHAPES = { HORSE:[], TEXT:[], TOWER:[], WIND_SOLAR:[] };
        let pendingShapeChange = false;

        const sphereGeom = new THREE.SphereGeometry(0.6, 8, 8);
        const boxGeom = new THREE.BoxGeometry(0.8, 0.8, 0.8);

        init(); animate(); initMediaPipe();

        async function init() {
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x010103, 0.0008);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 5000);
            camera.position.set(0, 0, 450);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); dirLight.position.set(100, 100, 100); scene.add(dirLight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.8);
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

            mainGroup = new THREE.Group(); photoGroup = new THREE.Group();
            scene.add(mainGroup); scene.add(photoGroup);

            try {
                await generateAllShapes();
            } catch (e) {
                alert("æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç½‘ç»œåŸå› æˆ–è·¨åŸŸé™åˆ¶ã€‚è¯·æ£€æŸ¥æ§åˆ¶å°ã€‚");
                console.error(e);
            }
            createParticles();
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            document.getElementById('loading').style.display = 'none';
        }

        // --- 1. åŸºäºæ¨¡å‹çš„å½¢æ€ç”Ÿæˆ ---
        async function generateAllShapes() {
            const loader = new GLTFLoader();
            const load Model = (url) => new Promise((resolve, reject) => loader.load(url, resolve, undefined, reject));

            // å¹¶è¡ŒåŠ è½½æ‰€æœ‰æ¨¡å‹
            const [horseGLTF, towerGLTF, windGLTF, solarGLTF] = await Promise.all([
                loadModel(CONFIG.urls.horse),
                loadModel(CONFIG.urls.tower),
                loadModel(CONFIG.urls.wind),
                loadModel(CONFIG.urls.solar)
            ]);

            // A. é©¬
            SHAPES.HORSE = samplePoints(getPointsFromGLTF(horseGLTF, 1.4), CONFIG.particleCount);
            
            // B. æ–‡å­—
            SHAPES.TEXT = generateTextPoints("é£å…‰æ— é™  å›½å®¶ç”µæŠ•");
            
            // C. å‡‰æ°´å¡” (ä½¿ç”¨å ä½æ¨¡å‹æ¼”ç¤ºé€»è¾‘)
            // å®é™…åº”ç”¨ä¸­ï¼Œæ›¿æ¢ä¸ºçœŸå®çš„å‡‰æ°´å¡”æ¨¡å‹ï¼Œå¹¶æ ¹æ®Yè½´é«˜åº¦è¿›è¡Œé¢œè‰²æ ‡è®°
            let towerPoints = getPointsFromGLTF(towerGLTF, 5.0); // è°ƒæ•´ç¼©æ”¾
            const towerBox = new THREE.Box3().setFromPoints(towerPoints);
            const towerMinY = towerBox.min.y; const towerMaxY = towerBox.max.y;
            towerPoints.forEach(p => {
                // è®¡ç®—é«˜åº¦æ¯”ä¾‹ (0-1) ç”¨äºæ¸å˜è‰²
                p.heightRatio = (p.y - towerMinY) / (towerMaxY - towerMinY);
            });
            SHAPES.TOWER = samplePoints(towerPoints, CONFIG.particleCount);

            // D. é£å…‰äº’è¡¥åœºæ™¯ (ç»„åˆå¤šä¸ªæ¨¡å‹)
            let scenePoints = [];
            // é£æœº1 (å¤§, å·¦)
            let wind1 = getPointsFromGLTF(windGLTF, 1.5);
            wind1.forEach(p => { p.add(new THREE.Vector3(-150, 0, -50)); p.isWind = true; });
            scenePoints = scenePoints.concat(wind1);
            // é£æœº2 (å°, å³)
            let wind2 = getPointsFromGLTF(windGLTF, 0.8);
            wind2.forEach(p => { p.add(new THREE.Vector3(120, -50, 80)); p.isWind = true; });
            scenePoints = scenePoints.concat(wind2);
            // å…‰ä¼æ¿é˜µåˆ— (ä½¿ç”¨å ä½æ¨¡å‹)
            let solarBase = getPointsFromGLTF(solarGLTF, 0.5);
            for(let x=-1; x<=1; x++) {
                for(let z=-1; z<=1; z++) {
                    let panel = solarBase.map(p => p.clone().add(new THREE.Vector3(x*80, -100, z*60)));
                    panel.forEach(p => p.isSolar = true);
                    scenePoints = scenePoints.concat(panel);
                }
            }
            SHAPES.WIND_SOLAR = samplePoints(scenePoints, CONFIG.particleCount);
        }

        function getPointsFromGLTF(gltf, scale) {
            const points = [];
            gltf.scene.traverse(child => {
                if(child.isMesh) {
                    const pos = child.geometry.attributes.position;
                    const v = new THREE.Vector3();
                    for(let i=0; i<pos.count; i++) {
                        v.fromBufferAttribute(pos, i).applyMatrix4(child.matrixWorld).multiplyScalar(scale);
                        points.push(v.clone());
                    }
                }
            });
            return points;
        }

        function generateTextPoints(text) {
            const ctx = document.getElementById('genCanvas').getContext('2d');
            ctx.clearRect(0,0,2048,1024);
            ctx.font = "bold 200px 'Microsoft YaHei'"; ctx.fillStyle = "white";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, 1024, 512);
            const data = ctx.getImageData(0,0,2048,1024).data; const pts=[];
            for(let y=0;y<1024;y+=5) for(let x=0;x<2048;x+=5) if(data[(y*2048+x)*4+3]>128) pts.push(new THREE.Vector3((x-1024)*0.3,-(y-512)*0.3,(Math.random()-0.5)*15));
            return samplePoints(pts, CONFIG.particleCount);
        }
        function samplePoints(s,c) { 
            if(!s.length)return[]; const b=new THREE.Box3().setFromPoints(s); const ct=b.getCenter(new THREE.Vector3()); 
            s.forEach(p=>p.sub(ct)); const r=[]; for(let i=0;i<c;i++){ 
                const p=s[i%s.length].clone(); 
                // ä¿ç•™ç‰¹æ®Šå±æ€§
                if(s[i%s.length].heightRatio !== undefined) p.heightRatio = s[i%s.length].heightRatio;
                if(s[i%s.length].isWind) p.isWind = true;
                if(s[i%s.length].isSolar) p.isSolar = true;
                r.push(p);
            } return r.sort(()=>Math.random()-0.5); 
        }

        // --- 2. ç²’å­ç³»ç»Ÿ ---
        function createParticles() {
            for(let i=0; i<CONFIG.particleCount; i++) {
                const mesh = new THREE.Mesh(sphereGeom, new THREE.MeshStandardMaterial({
                    color:0xffffff, roughness:0.4, metalness:0.5
                }));
                const scatterPos = new THREE.Vector3((Math.random()-0.5)*900, (Math.random()-0.5)*700, (Math.random()-0.5)*900);
                mesh.position.copy(scatterPos); mainGroup.add(mesh);
                particles.push({
                    mesh, targets: [SHAPES.HORSE[i], SHAPES.TEXT[i], SHAPES.TOWER[i], SHAPES.WIND_SOLAR[i]],
                    scatterPos, baseColor: new THREE.Color(), seed: Math.random()
                });
            }
            updateVisuals(0); updateState('DISPERSED');
        }

        function updateVisuals(idx) {
            const ui=document.getElementById('shape-name');
            let colors, geom=sphereGeom, op=1, trans=false, emissiveInt=0.3;
            if(idx===0) { ui.innerText="ğŸ æˆ˜é©¬å½¢æ€ (çº¢é‡‘)"; ui.style.color="#FFD700"; colors=CONFIG.colors.horse; emissiveInt=0.8; }
            else if(idx===1) { ui.innerText="ğŸ’ æ–‡å­—å½¢æ€ (æ˜Ÿå…‰è“)"; ui.style.color="#88CCFF"; colors=CONFIG.colors.text; geom=boxGeom; op=0.8; trans=true; }
            else if(idx===2) { ui.innerText="ğŸ­ å‡‰æ°´å¡” (å½©ç»˜æ¸å˜)"; ui.style.color="#00BFFF"; }
            else { ui.innerText="âš¡ é£å…‰äº’è¡¥ (å·¥ä¸šåœºæ™¯)"; ui.style.color="#00FF00"; geom=boxGeom; }

            particles.forEach((p,i) => {
                let hex;
                if(idx===2) { // å‡‰æ°´å¡”æ¸å˜è‰²
                    const ratio = p.targets[2].heightRatio || 0.5;
                    p.baseColor.lerpColors(CONFIG.colors.towerBottom, CONFIG.colors.towerTop, ratio);
                } else if(idx===3) { // é£å…‰äº’è¡¥
                    hex = p.targets[3].isSolar ? CONFIG.colors.solar : CONFIG.colors.wind;
                    p.baseColor.setHex(hex);
                } else {
                    hex = colors[Math.floor(Math.random()*colors.length)];
                    p.baseColor.setHex(hex);
                }

                p.mesh.geometry = geom; p.mesh.material.transparent = trans;
                gsap.to(p.mesh.material.color, {r:p.baseColor.r,g:p.baseColor.g,b:p.baseColor.b, duration:0.8});
                gsap.to(p.mesh.material, {opacity:op, duration:0.8});
                gsap.to(p.mesh.material.emissive, {r:p.baseColor.r,g:p.baseColor.g,b:p.baseColor.b, intensity:emissiveInt, duration:0.8});
            });
        }

        // --- 3. äº¤äº’çŠ¶æ€ (ä¿®å¤3Dç…§ç‰‡æŠ“å–) ---
        function updateState(newState) {
            if(state === newState) return;
            // å¦‚æœå¤„äº ZOOM é”å®šçŠ¶æ€ï¼Œåªå…è®¸ DISPERSED (å¼ æ‰‹) è§£é”
            if(isZoomLocked && newState !== 'DISPERSED') return;

            if(state==='DISPERSED' && newState==='CONVERGED' && pendingShapeChange) {
                currentShapeIndex=(currentShapeIndex+1)%4; updateVisuals(currentShapeIndex); pendingShapeChange=false;
            } else if(newState==='DISPERSED') pendingShapeChange=true;

            // é€€å‡º ZOOM çŠ¶æ€æ—¶çš„æ¸…ç†
            if(state === 'ZOOM' && newState !== 'ZOOM' && activeZoomPhoto) {
                isZoomLocked = false;
                // è®©ç…§ç‰‡é£å›åŸå¤„
                gsap.to(activeZoomPhoto.position, {...activeZoomPhoto.homePos, duration:1.5, ease:"power2.inOut"});
                gsap.to(activeZoomPhoto.scale, {x:1, y:1, z:1, duration:1.5});
                activeZoomPhoto = null;
            }

            state = newState;
            const stEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                stEl.innerText = "çŠ¶æ€: âœŠ èšåˆ (æ—‹è½¬)";
                particles.forEach(p => gsap.to(p.mesh.position, {...p.targets[currentShapeIndex], duration: 1.5+p.seed, ease:"power2.inOut"}));
                // ç…§ç‰‡å½’ä½
                photoClouds.forEach(p => {
                    if(p !== activeZoomPhoto) {
                        gsap.to(p.position, {...p.homePos, duration:1.8, ease:"power2.inOut"});
                        gsap.to(p.scale, {x:1,y:1,z:1, duration:1});
                    }
                });
            } else if (state === 'DISPERSED') {
                stEl.innerText = "çŠ¶æ€: ğŸ– æ•£å¼€ (åˆ‡æ¢/é‡Šæ”¾)";
                particles.forEach(p => gsap.to(p.mesh.position, {...p.scatterPos, duration: 2, ease:"power3.out"}));
                // ç…§ç‰‡æ•£å¼€
                photoClouds.forEach(p => {
                    if(p !== activeZoomPhoto) {
                        gsap.to(p.position, {...p.scatterPos, duration:2.2, ease:"power2.out"});
                        gsap.to(p.scale, {x:1.5,y:1.5,z:1.5, duration:1});
                    }
                });
            } else if (state === 'ZOOM') {
                // 3Dç…§ç‰‡æŠ“å–æ ¸å¿ƒé€»è¾‘
                if(photoClouds.length > 0 && !isZoomLocked) {
                    isZoomLocked = true; // é”å®šï¼Œé˜²æ­¢è¿ç»­è§¦å‘
                    stEl.innerText = "çŠ¶æ€: ğŸ‘Œ å·²æŠ“å– (å¼ æ‰‹é‡Šæ”¾)";
                    
                    activeZoomPhoto = photoClouds[Math.floor(Math.random()*photoClouds.length)];
                    
                    // è®¡ç®—ç›¸æœºæ­£å‰æ–¹çš„ä¸€ä¸ªç‚¹
                    const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    // è·ç¦»ç›¸æœº 80 å•ä½ï¼Œä¿è¯å¡«æ»¡è§†é‡ä¸”ä¸ç©¿æ¨¡
                    const targetPos = camera.position.clone().add(camDir.multiplyScalar(80));
                    
                    // 1. é£å‘ç›®æ ‡ä½ç½®
                    gsap.to(activeZoomPhoto.position, {
                        x: targetPos.x, y: targetPos.y, z: targetPos.z,
                        duration: 1.2, ease: "power2.out"
                    });
                    // 2. æ”¾å¤§
                    gsap.to(activeZoomPhoto.scale, { x: 8, y: 8, z: 8, duration: 1.2 });
                    
                    // 3. å…³é”®ï¼šä½¿ç…§ç‰‡æ—‹è½¬åˆ°å®Œå…¨æ­£å¯¹ç›¸æœº
                    // æˆ‘ä»¬ä¸èƒ½ç®€å•ç”¨ lookAtï¼Œå› ä¸ºå¯èƒ½ä¼šæœ‰ç¿»è½¬é—®é¢˜ã€‚
                    // æœ€ç¨³å¦¥çš„æ˜¯ç›´æ¥æ‹·è´ç›¸æœºçš„æ—‹è½¬å››å…ƒæ•°ã€‚
                    gsap.to(activeZoomPhoto.quaternion, {
                        x: camera.quaternion.x, y: camera.quaternion.y, z: camera.quaternion.z, w: camera.quaternion.w,
                        duration: 1.2
                    });
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate); time+=0.01;
            
            // æ‰‹åŠ¿æ—‹è½¬ (ZOOMæ—¶ä¸æ—‹è½¬)
            if(state !== 'ZOOM') {
                const tRotY = (handPosition.x-0.5)*3; const tRotX = (handPosition.y-0.5)*2;
                mainGroup.rotation.y += (tRotY - mainGroup.rotation.y)*0.05;
                mainGroup.rotation.x += (tRotX - mainGroup.rotation.x)*0.05;
                // ç…§ç‰‡ç»„åªåœ¨éèšåˆæ€è·Ÿéšæ—‹è½¬ï¼Œèšåˆæ€æ—¶å®ƒä»¬æ¼‚æµ®åœ¨å‘¨å›´
                if(state !== 'CONVERGED') photoGroup.rotation.copy(mainGroup.rotation);
                else { photoGroup.rotation.y += 0.005; photoGroup.rotation.x *= 0.95; } // èšåˆæ—¶ç¼“æ…¢è‡ªè½¬
            }

            if(state==='DISPERSED') particles.forEach(p => { p.mesh.position.y+=Math.sin(time+p.seed*10)*0.1; p.mesh.position.x+=Math.cos(time+p.seed*10)*0.1; });
            
            // ç¡®ä¿éæŠ“å–çŠ¶æ€çš„ç…§ç‰‡å§‹ç»ˆé¢å‘ç›¸æœº
            photoClouds.forEach(p => {
                if(p !== activeZoomPhoto) p.lookAt(camera.position);
            });

            composer.render();
        }

        function handleFileUpload(e) {
            const files=e.target.files; if(!files.length)return;
            photoClouds.forEach(p=>photoGroup.remove(p)); photoClouds=[];
            Array.from(files).slice(0,CONFIG.maxPhotos).forEach((f,i)=>{
                const r=new FileReader();
                r.onload=ev=>{
                    const img=new Image(); img.src=ev.target.result;
                    img.onload=()=>{
                        const tex=new THREE.Texture(img); tex.needsUpdate=true; tex.colorSpace=THREE.SRGBColorSpace;
                        const mesh=new THREE.Mesh(new THREE.PlaneGeometry(15,15), new THREE.MeshBasicMaterial({map:tex, side:THREE.DoubleSide, transparent:true}));
                        const ang=(i/files.length)*Math.PI*2, rad=200;
                        mesh.homePos=new THREE.Vector3(Math.cos(ang)*rad, (Math.random()-0.5)*150, Math.sin(ang)*rad);
                        mesh.scatterPos=new THREE.Vector3((Math.random()-0.5)*1000, (Math.random()-0.5)*800, (Math.random()-0.5)*1000);
                        mesh.position.copy(mesh.scatterPos); photoGroup.add(mesh); photoClouds.push(mesh);
                    }
                }
                r.readAsDataURL(f);
            });
            alert(`å·²åŠ è½½ç…§ç‰‡ã€‚æåˆæ‰‹æŒ‡æŠ“å–è‡³çœ¼å‰ã€‚`);
        }

        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); }
        
        function initMediaPipe() {
            const v=document.getElementById('video-element');
            const h=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            h.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7});
            
            h.onResults(res=>{
                if(!res.multiHandLandmarks.length) return; const lm=res.multiHandLandmarks[0];
                handPosition.x=1-(lm[0].x+lm[9].x)/2; handPosition.y=(lm[0].y+lm[9].y)/2;

                const pinch=Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                let open=0; [8,12,16,20].forEach((t,i)=>{if(lm[t].y<lm[5+i*4].y)open++});

                // çŠ¶æ€æœºé€»è¾‘è°ƒæ•´
                if(pinch<0.05) {
                    // æåˆè§¦å‘ ZOOM
                    if(state !== 'ZOOM') updateState('ZOOM');
                } else if(open>=4) {
                    // å¼ å¼€æ‰‹è§¦å‘ DISPERSED (åŒæ—¶ä¹Ÿæ˜¯é‡Šæ”¾ ZOOM çš„æ‰‹åŠ¿)
                    if(state !== 'DISPERSED') updateState('DISPERSED');
                } else if(open<=1) {
                    // æ¡æ‹³è§¦å‘ CONVERGED (ä»…åœ¨é ZOOM çŠ¶æ€ä¸‹)
                    if(state !== 'CONVERGED' && state !== 'ZOOM') updateState('CONVERGED');
                }
            });
            new Camera(v,{onFrame:async()=>await h.send({image:v}),width:320,height:240}).start();
        }
    </script>
</body>
</html>
