<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>SPIC Interactive V10 - The Final Form</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010103; font-family: 'Microsoft YaHei', sans-serif; }
        
        /* è§†é¢‘æ¡† */
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 2px solid rgba(0, 255, 255, 0.3); border-radius: 8px; opacity: 0.5; }
        
        /* UI å±‚ */
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 26px; color: #FFD700; letter-spacing: 2px; text-shadow: 0 0 15px rgba(0, 100, 255, 0.5); font-weight: bold; }
        .cycle-info { font-size: 22px; margin-top: 10px; color: #fff; font-weight: bold; transition: all 0.5s; }
        .status { font-size: 16px; color: rgba(255,255,255,0.8); margin-top: 8px; background: rgba(0,0,0,0.6); padding: 4px 12px; border-radius: 20px; display: inline-block;}
        
        #upload-container { pointer-events: auto; display: inline-block; margin-top: 25px; }
        input[type="file"] { display: none; }
        .btn { background: linear-gradient(135deg, #00c6ff, #0072ff); border: none; padding: 12px 25px; color: #fff; font-size: 14px; font-weight: bold; cursor: pointer; border-radius: 30px; box-shadow: 0 0 20px rgba(0, 114, 255, 0.4); transition: transform 0.2s; }
        .btn:hover { transform: scale(1.05); }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ffff; z-index: 20; font-size: 20px; text-align: center; letter-spacing: 2px; }
        #hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 14px; pointer-events: none; }

        /* --- æ ¸å¿ƒå‡çº§ï¼šç…§ç‰‡å¼¹çª—å±‚ --- */
        #photo-popup {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.85); z-index: 100;
            display: none; /* åˆå§‹éšè— */
            justify-content: center; align-items: center;
            flex-direction: column; backdrop-filter: blur(10px);
            opacity: 0; transition: opacity 0.5s;
        }
        #photo-popup.active { display: flex; opacity: 1; }
        #popup-img {
            max-width: 80%; max-height: 80%;
            border: 3px solid #fff; box-shadow: 0 0 50px rgba(255,255,255,0.2);
            border-radius: 4px; transform: scale(0.8); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #photo-popup.active #popup-img { transform: scale(1); }
        #popup-hint { color: #fff; margin-top: 20px; font-size: 18px; letter-spacing: 2px; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loading">æ­£åœ¨æ„å»ºå¤æ‚å·¥ä¸šå½¢æ€...</div>
    
    <div id="photo-popup">
        <img id="popup-img" src="">
        <div id="popup-hint">ğŸ‘‹ å·¦å³æŒ¥æ‰‹å…³é—­å¼¹çª—</div>
    </div>

    <div id="ui-layer">
        <h1>SPIC èƒ½æºè§†ç•Œ</h1>
        <div class="cycle-info" id="shape-name" style="color:#FFD700">ğŸ æˆ˜é©¬å½¢æ€</div>
        <div class="status" id="status-text">ç­‰å¾…æ‰‹åŠ¿...</div>
        <div id="upload-container">
            <label class="btn">+ æ³¨å…¥è®°å¿†ç…§ç‰‡ <input type="file" id="file-input" multiple accept="image/*"></label>
        </div>
    </div>
    <div id="hint">âœŠèšåˆ | ğŸ–æ•£å¼€(åˆ‡æ¢) | ğŸ‘Œæåˆ(å¼¹çª—) | ğŸ‘‹æŒ¥æ‰‹(å…³é—­)</div>
    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="genCanvas" width="2048" height="1024" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        const CONFIG = {
            particleCount: 16000,
            maxPhotos: 30,
            colors: {
                horse: [0xD4AF37, 0xC41E3A, 0xFFD700, 0x8B0000],
                text: [0x88CCFF],
                tower: [0x00BFFF, 0x1E90FF, 0x0000FF], // è“ç³»æ¸å˜
                wind: [0x00FF00, 0x32CD32], // ç»¿è‰²ç³»
                solar: [0xFFA500, 0xFF4500] // æ©™è‰²ç³»
            },
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb'
        };

        let scene, camera, renderer, composer, mainGroup, photoGroup;
        let particles = []; let photoClouds = [];
        let state = 'CONVERGED'; let time = 0;
        let handPosition = { x: 0.5, y: 0.5 };
        
        // æŒ¥æ‰‹æ£€æµ‹å˜é‡
        let lastPalmX = 0.5; let waveVelocity = 0;

        // å½¢æ€
        let currentShapeIndex = 0;
        // 0:Horse, 1:Text, 2:Tower, 3:WindSolar
        const SHAPES = { HORSE:[], TEXT:[], TOWER:[], WIND_SOLAR:[] };
        let pendingShapeChange = false;

        const sphereGeom = new THREE.SphereGeometry(0.6, 8, 8);
        const boxGeom = new THREE.BoxGeometry(0.8, 0.8, 0.8);

        init(); animate(); initMediaPipe();

        async function init() {
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x010103, 0.0008);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 5000);
            camera.position.set(0, 0, 450);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); dirLight.position.set(100, 100, 100); scene.add(dirLight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.8);
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

            mainGroup = new THREE.Group(); photoGroup = new THREE.Group();
            scene.add(mainGroup); scene.add(photoGroup);

            await generateAllShapes(); createParticles();
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            document.getElementById('loading').style.display = 'none';
        }

        // --- 1. æ–°å½¢æ€ç”Ÿæˆ ---
        async function generateAllShapes() {
            // A. é©¬
            await new Promise(r => new GLTFLoader().load(CONFIG.modelUrl, g => {
                SHAPES.HORSE = samplePoints(getPointsFromMesh(g.scene.children[0], 1.4), CONFIG.particleCount); r();
            }));
            // B. æ–‡å­—
            SHAPES.TEXT = generateTextPoints("é£å…‰æ— é™  å›½å®¶ç”µæŠ•");
            // C. å‡‰æ°´å¡” (åŒæ›²çº¿ç»“æ„)
            SHAPES.TOWER = generateCoolingTower(CONFIG.particleCount);
            // D. é£å…‰äº’è¡¥ (é£æœº+å…‰ä¼)
            SHAPES.WIND_SOLAR = generateWindSolar(CONFIG.particleCount);
        }

        function generateCoolingTower(count) {
            const points = [];
            const height = 350; const baseRad = 120; const topRad = 70;
            for(let i=0; i<count; i++) {
                const v = Math.random(); // é«˜åº¦æ¯”ä¾‹ 0-1
                const y = (v - 0.5) * height;
                // åŒæ›²çº¿åŠå¾„å…¬å¼
                const r = baseRad * (1 - v) + topRad * v + Math.pow(v - 0.5, 2) * 80; 
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                points.push(new THREE.Vector3(x, y, z));
            }
            return samplePoints(points, count);
        }

        function generateWindSolar(count) {
            const points = [];
            // 1. é£æœº (ä¸¤ä¸ªï¼Œä¸€å¤§ä¸€å°)
            const createTurbine = (offsetX, offsetZ, scale) => {
                const h = 250 * scale; const r = 10 * scale;
                // å¡”ç­’
                for(let i=0; i<count*0.15*scale; i++) {
                    const y = (Math.random()-0.5)*h; const ang = Math.random()*Math.PI*2;
                    points.push(new THREE.Vector3(Math.cos(ang)*r + offsetX, y, Math.sin(ang)*r + offsetZ));
                }
                // å¶ç‰‡ä¸­å¿ƒ
                const centerY = h/2;
                for(let k=0; k<3; k++) { // 3ä¸ªå¶ç‰‡
                    const bladeAng = (k/3)*Math.PI*2;
                    for(let i=0; i<count*0.05*scale; i++) {
                        const l = Math.random() * 120 * scale; // å¶ç‰‡é•¿åº¦
                        const bx = Math.cos(bladeAng) * l;
                        const by = Math.sin(bladeAng) * l;
                        points.push(new THREE.Vector3(bx + offsetX, by + centerY, offsetZ + (Math.random()-0.5)*5));
                    }
                }
            };
            createTurbine(-100, -50, 1.0); // å·¦ä¾§å¤§é£æœº
            createTurbine(120, 80, 0.7);  // å³ä¾§å°é£æœº

            // 2. å…‰ä¼æ¿ (åœ°é¢é˜µåˆ—)
            const rows = 4; const cols = 8;
            const panelW = 40; const panelH = 25;
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    const cx = (c - cols/2 + 0.5) * (panelW+10);
                    const cz = (r - rows/2 + 0.5) * (panelH+20);
                    for(let i=0; i<count*0.005; i++) {
                        const px = (Math.random()-0.5)*panelW;
                        const pz = (Math.random()-0.5)*panelH;
                        // å€¾æ–œæ”¾ç½®
                        const y = pz * Math.sin(Math.PI*0.2) - 150; // åœ¨åœ°é¢ä¸‹æ–¹
                        const z = pz * Math.cos(Math.PI*0.2) + cz;
                        points.push(new THREE.Vector3(px + cx, y, z));
                        // æ ‡è®°ä¸ºå…‰ä¼ï¼Œç”¨äºä¸Šè‰²
                        points[points.length-1].isSolar = true;
                    }
                }
            }
            return samplePoints(points, count);
        }

        function generateTextPoints(text) {
            const ctx = document.getElementById('genCanvas').getContext('2d');
            ctx.clearRect(0,0,2048,1024);
            ctx.font = "bold 200px 'Microsoft YaHei'"; ctx.fillStyle = "white";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, 1024, 512);
            return scanCanvas(ctx, 2048, 1024, 5);
        }
        function scanCanvas(ctx, w, h, step) {
            const data = ctx.getImageData(0,0,w,h).data; const pts=[];
            for(let y=0;y<h;y+=step) for(let x=0;x<w;x+=step) if(data[(y*w+x)*4+3]>128) pts.push(new THREE.Vector3((x-1024)*0.3,-(y-512)*0.3,(Math.random()-0.5)*15));
            return samplePoints(pts, CONFIG.particleCount);
        }
        function getPointsFromMesh(m,s) { const p=m.geometry.attributes.position; const pts=[]; const v=new THREE.Vector3(); for(let i=0;i<p.count;i++) pts.push(v.fromBufferAttribute(p,i).multiplyScalar(s).clone()); return pts; }
        function samplePoints(s,c) { if(!s.length)return[]; const b=new THREE.Box3().setFromPoints(s); const ct=b.getCenter(new THREE.Vector3()); s.forEach(p=>p.sub(ct)); const r=[]; for(let i=0;i<c;i++){ const p=s[i%s.length].clone(); if(s[i%s.length].isSolar) p.isSolar=true; r.push(p);} return r.sort(()=>Math.random()-0.5); }

        // --- 2. ç²’å­ç³»ç»Ÿ ---
        function createParticles() {
            for(let i=0; i<CONFIG.particleCount; i++) {
                const mesh = new THREE.Mesh(sphereGeom, new THREE.MeshStandardMaterial({
                    color:0xffffff, roughness:0.3, metalness:0.6
                }));
                const scatterPos = new THREE.Vector3((Math.random()-0.5)*800, (Math.random()-0.5)*600, (Math.random()-0.5)*800);
                mesh.position.copy(scatterPos); mainGroup.add(mesh);
                particles.push({
                    mesh, targets: [SHAPES.HORSE[i], SHAPES.TEXT[i], SHAPES.TOWER[i], SHAPES.WIND_SOLAR[i]],
                    scatterPos, baseColor: new THREE.Color(), seed: Math.random()
                });
            }
            updateVisuals(0); updateState('DISPERSED');
        }

        function updateVisuals(idx) {
            const ui=document.getElementById('shape-name');
            let colors, geom=sphereGeom, op=1, trans=false;
            if(idx===0) { ui.innerText="ğŸ æˆ˜é©¬å½¢æ€ (çº¢é‡‘)"; ui.style.color="#FFD700"; colors=CONFIG.colors.horse; }
            else if(idx===1) { ui.innerText="ğŸ’ æ–‡å­—å½¢æ€ (æ˜Ÿå…‰è“)"; ui.style.color="#88CCFF"; colors=CONFIG.colors.text; geom=boxGeom; op=0.85; trans=true; }
            else if(idx===2) { ui.innerText="ğŸ­ å‡‰æ°´å¡” (æ¸å˜è“)"; ui.style.color="#1E90FF"; colors=CONFIG.colors.tower; }
            else { ui.innerText="âš¡ é£å…‰äº’è¡¥ (ç»¿èƒ½+å…‰ä¼)"; ui.style.color="#00FF00"; }

            particles.forEach((p,i) => {
                let hex;
                if(idx===3) { // é£å…‰äº’è¡¥ç‰¹æ®Šé…è‰²
                    hex = p.targets[3].isSolar ? 
                          CONFIG.colors.solar[Math.floor(Math.random()*CONFIG.colors.solar.length)] : 
                          CONFIG.colors.wind[Math.floor(Math.random()*CONFIG.colors.wind.length)];
                } else {
                    hex = colors[Math.floor(Math.random()*colors.length)];
                }
                if(idx===2) { // å‡‰æ°´å¡”æ¸å˜
                    const h = p.targets[2].y;
                    const t = (h + 175) / 350; // 0-1
                    p.baseColor.lerpColors(new THREE.Color(colors[0]), new THREE.Color(colors[2]), t);
                } else {
                    p.baseColor.setHex(hex);
                }

                p.mesh.geometry = geom; p.mesh.material.transparent = trans;
                gsap.to(p.mesh.material.color, {r:p.baseColor.r,g:p.baseColor.g,b:p.baseColor.b, duration:0.8});
                gsap.to(p.mesh.material, {opacity:op, duration:0.8});
                gsap.to(p.mesh.material.emissive, {r:p.baseColor.r,g:p.baseColor.g,b:p.baseColor.b, intensity:0.4, duration:0.8});
            });
        }

        // --- 3. äº¤äº’çŠ¶æ€ (å«å¼¹çª—é€»è¾‘) ---
        function updateState(newState) {
            if(state === newState) return;
            // å¦‚æœæ­£åœ¨æ˜¾ç¤ºå¼¹çª—ï¼Œç¦æ­¢å…¶ä»–çŠ¶æ€åˆ‡æ¢
            if(state === 'PHOTO_POPUP' && newState !== 'DISPERSED' && newState !== 'CONVERGED') return;

            if(state==='DISPERSED' && newState==='CONVERGED' && pendingShapeChange) {
                currentShapeIndex=(currentShapeIndex+1)%4; updateVisuals(currentShapeIndex); pendingShapeChange=false;
            } else if(newState==='DISPERSED') pendingShapeChange=true;

            state = newState;
            const stEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                stEl.innerText = "çŠ¶æ€: âœŠ èšåˆ";
                particles.forEach(p => gsap.to(p.mesh.position, {...p.targets[currentShapeIndex], duration: 1.5+p.seed, ease:"power2.inOut"}));
                photoClouds.forEach(p => { gsap.to(p.position, {...p.homePos, duration:1.8, ease:"power2.inOut"}); gsap.to(p.scale, {x:1,y:1,z:1, duration:1}); });
            } else if (state === 'DISPERSED') {
                stEl.innerText = "çŠ¶æ€: ğŸ– æ•£å¼€";
                particles.forEach(p => gsap.to(p.mesh.position, {...p.scatterPos, duration: 2, ease:"power3.out"}));
                photoClouds.forEach(p => { gsap.to(p.position, {...p.scatterPos, duration:2.2, ease:"power2.out"}); gsap.to(p.scale, {x:1.5,y:1.5,z:1.5, duration:1}); });
            } else if (state === 'PHOTO_POPUP') {
                // è§¦å‘ç…§ç‰‡å¼¹çª—
                if(photoClouds.length > 0) {
                    const targetPhoto = photoClouds[Math.floor(Math.random()*photoClouds.length)];
                    showPhotoPopup(targetPhoto.material.map.image.src);
                    stEl.innerText = "çŠ¶æ€: ğŸ“¸ ç…§ç‰‡å¼¹çª— (æŒ¥æ‰‹å…³é—­)";
                } else {
                    // æ²¡æœ‰ç…§ç‰‡åˆ™é€€å›
                    updateState('CONVERGED');
                }
            }
        }

        // --- æ ¸å¿ƒï¼šç…§ç‰‡å¼¹çª—æ§åˆ¶ ---
        function showPhotoPopup(src) {
            const popup = document.getElementById('photo-popup');
            const img = document.getElementById('popup-img');
            img.src = src;
            popup.classList.add('active');
        }

        function hidePhotoPopup() {
            const popup = document.getElementById('photo-popup');
            popup.classList.remove('active');
            // å…³é—­åå›åˆ°ä¸Šä¸€ä¸ªç¨³å®šçŠ¶æ€
            updateState(currentShapeIndex === 0 ? 'CONVERGED' : 'CONVERGED');
        }

        function animate() {
            requestAnimationFrame(animate); time+=0.01;
            
            // æ‰‹åŠ¿æ—‹è½¬ (å¼¹çª—æ—¶ç¦ç”¨)
            if(state !== 'PHOTO_POPUP') {
                const tRotY = (handPosition.x-0.5)*3; const tRotX = (handPosition.y-0.5)*2;
                mainGroup.rotation.y += (tRotY - mainGroup.rotation.y)*0.05;
                mainGroup.rotation.x += (tRotX - mainGroup.rotation.x)*0.05;
                photoGroup.rotation.copy(mainGroup.rotation);
            }

            if(state==='DISPERSED') particles.forEach(p => { p.mesh.position.y+=Math.sin(time+p.seed*10)*0.1; p.mesh.position.x+=Math.cos(time+p.seed*10)*0.1; });
            photoClouds.forEach(p => p.lookAt(camera.position));
            composer.render();
        }

        function handleFileUpload(e) {
            const files=e.target.files; if(!files.length)return;
            photoClouds.forEach(p=>photoGroup.remove(p)); photoClouds=[];
            Array.from(files).slice(0,CONFIG.maxPhotos).forEach((f,i)=>{
                const r=new FileReader();
                r.onload=ev=>{
                    const img=new Image(); img.src=ev.target.result;
                    img.onload=()=>{
                        const tex=new THREE.Texture(img); tex.needsUpdate=true; tex.colorSpace=THREE.SRGBColorSpace;
                        const mesh=new THREE.Mesh(new THREE.PlaneGeometry(12,12), new THREE.MeshBasicMaterial({map:tex, side:THREE.DoubleSide, transparent:true}));
                        const ang=(i/files.length)*Math.PI*2, rad=180;
                        mesh.homePos=new THREE.Vector3(Math.cos(ang)*rad, (Math.random()-0.5)*120, Math.sin(ang)*rad);
                        mesh.scatterPos=new THREE.Vector3((Math.random()-0.5)*900, (Math.random()-0.5)*700, (Math.random()-0.5)*900);
                        mesh.position.copy(mesh.scatterPos); photoGroup.add(mesh); photoClouds.push(mesh);
                    }
                }
                r.readAsDataURL(f);
            });
            alert(`å·²åŠ è½½ç…§ç‰‡ã€‚æåˆæ‰‹æŒ‡è§¦å‘å¼¹çª—ã€‚`);
        }

        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); }
        
        // --- MediaPipe & æŒ¥æ‰‹æ£€æµ‹ ---
        function initMediaPipe() {
            const v=document.getElementById('video-element');
            const h=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            h.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7});
            
            h.onResults(res=>{
                if(!res.multiHandLandmarks.length) return; const lm=res.multiHandLandmarks[0];
                const palmX = (lm[0].x+lm[9].x)/2;
                handPosition.x=1-palmX; handPosition.y=(lm[0].y+lm[9].y)/2;

                // æŒ¥æ‰‹æ£€æµ‹ (è®¡ç®—æ‰‹æŒXè½´ç§»åŠ¨é€Ÿåº¦)
                const velocity = palmX - lastPalmX;
                // ä½¿ç”¨æŒ‡æ•°å¹³æ»‘å¹³å‡
                waveVelocity = waveVelocity * 0.8 + velocity * 0.2;
                lastPalmX = palmX;

                const pinch=Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                let open=0; [8,12,16,20].forEach((t,i)=>{if(lm[t].y<lm[5+i*4].y)open++});

                // çŠ¶æ€æœº
                if(state === 'PHOTO_POPUP') {
                    // åœ¨å¼¹çª—æ¨¡å¼ä¸‹ï¼Œæ£€æµ‹å¿«é€ŸæŒ¥æ‰‹ (é€Ÿåº¦è¶…è¿‡é˜ˆå€¼)
                    if(Math.abs(waveVelocity) > 0.08) {
                        hidePhotoPopup();
                    }
                } else {
                    // æ­£å¸¸æ¨¡å¼
                    if(pinch<0.04) updateState('PHOTO_POPUP');
                    else if(open>=4) updateState('DISPERSED');
                    else if(open<=1) updateState('CONVERGED');
                }
            });
            new Camera(v,{onFrame:async()=>await h.send({image:v}),width:320,height:240}).start();
        }
    </script>
</body>
</html>
