<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Future Energy Landscape (V14.0 Stable)</title>
    <style>
        /* èƒŒæ™¯ï¼šç§‘æŠ€æ„Ÿè“é»‘æ¸å˜ */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center bottom, #001a33 0%, #000000 80%); font-family: "Microsoft YaHei", sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #00f0ff; pointer-events: none; user-select: none;
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
        }
        h1 { margin: 0; font-weight: bold; letter-spacing: 3px; font-size: 28px; color: #ffffff; }
        .subtitle { font-size: 14px; color: #00aaff; letter-spacing: 1px; margin-top: 5px; }
        .version-tag { font-size: 10px; color: #00ff00; margin-top: 10px; border: 1px solid #00ff00; display: inline-block; padding: 2px 6px; background: rgba(0,0,0,0.6);}
        
        /* åŠ è½½é¡µ */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020205; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #00f0ff;
            flex-direction: column; transition: opacity 0.8s;
        }
        
        #start-btn {
            margin-top: 30px; padding: 15px 50px; 
            background: rgba(0, 240, 255, 0.2); color: #00f0ff;
            border: 2px solid #00f0ff; cursor: pointer;
            font-size: 18px; letter-spacing: 4px; font-weight: bold;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.3);
            border-radius: 50px; transition: 0.3s;
            display: none; 
        }
        #start-btn:hover { background: #00f0ff; color: #000; box-shadow: 0 0 50px rgba(0, 240, 255, 0.8); }

        #loading-text { margin-top: 10px; color: #6688aa; font-size: 12px; }
        
        /* ä¸Šä¼ æŒ‰é’® */
        #upload-btn {
            pointer-events: auto; background: rgba(0, 50, 100, 0.6);
            border: 1px solid #00aaff; color: #00aaff; padding: 6px 12px;
            cursor: pointer; margin-top: 15px; display: inline-block;
            font-size: 12px; border-radius: 2px;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
    </style>
</head>
<body>
    <div id="loader">
        <div style="font-size: 24px; letter-spacing: 3px; color: #ffffff;">æœªæ¥èƒ½æºæ™¯è±¡</div>
        <div style="font-size: 16px; letter-spacing: 2px; color: #00f0ff; margin-top:5px;">Future Energy Landscape</div>
        <div id="loading-text">æ­£åœ¨æ„å»ºå·¥ä¸šç²’å­ (Building Assets)...</div>
        <button id="start-btn">å¯åŠ¨å¼•æ“ (ENGAGE)</button>
    </div>

    <div id="ui-layer">
        <h1>ç«ç”µä¸æ–°èƒ½æº</h1>
        <div class="subtitle">Interactive Particle Scene V14.0</div>
        <div class="version-tag">Stable Network</div>
        <div class="status" id="gesture-status">ç­‰å¾…æŒ‡ä»¤...</div>
        <div style="margin-top:15px; font-size:12px; color:#88aabb; line-height: 1.8;">
            äº¤äº’æŒ‡å—ï¼š<br>
            âœŒï¸ å‰ªåˆ€æ‰‹ï¼šå…¨é¢è¿è¡Œ (Operating)<br>
            âœŠ æ¡æ‹³ï¼šé™æ€å±•ç¤º (Static)<br>
            ğŸ– å¼ å¼€æ‰‹ï¼šæ•£å¼€æ¼«æ¸¸ (Scatter)<br>
            ğŸ‘Œ æåˆï¼šæŠ“å–ç…§ç‰‡ (Grab Photo)
        </div>
        <label id="upload-btn">
            ä¸Šä¼ ä¼ä¸šç…§ç‰‡
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        // partType: 0=é™æ€ç»“æ„, 1=é£æœºå¶ç‰‡, 2=å…‰ä¼æ¿, 3=è’¸æ±½
        attribute float partType; 
        // initialPos: è®°å½•åˆå§‹ä½ç½®ç”¨äºæ—‹è½¬è®¡ç®—
        attribute vec3 initialPos;

        uniform float time;
        uniform float operateFactor; // è¿è¡Œå¼ºåº¦ 0~1
        uniform float scatter;       // æ•£å¼€å¼ºåº¦ 0~1
        
        varying vec3 vColor;
        varying float vAlpha;

        // æ—‹è½¬å‡½æ•°
        vec3 rotateZ(vec3 v, float angle) {
            float c = cos(angle); float s = sin(angle);
            return vec3(v.x*c - v.y*s, v.x*s + v.y*c, v.z);
        }

        void main() {
            vColor = customColor;
            vAlpha = 1.0;
            vec3 pos = position;

            // --- å·¥ä¸šåŠ¨ç”» ---
            float speed = 1.0 + operateFactor * 3.0; // è¿è¡Œé€Ÿåº¦å€ç‡

            if (partType > 0.5 && partType < 1.5) { 
                // Type 1: é£æœºå¶ç‰‡æ—‹è½¬ (ç»•Zè½´)
                // å¶ç‰‡ä¸­å¿ƒå¤§çº¦åœ¨ y=25, x=-15
                vec3 center = vec3(-15.0, 25.0, -5.0);
                vec3 relativePos = pos - center;
                // æ ¹æ®è¿è¡Œå› å­åŠ é€Ÿæ—‹è½¬
                float angle = -time * speed * 2.0; 
                pos = center + rotateZ(relativePos, angle);

            } else if (partType > 1.5 && partType < 2.5) {
                // Type 2: å…‰ä¼æ¿ (èƒ½é‡å¾®å…‰é—ªçƒ)
                vAlpha = 0.8 + sin(time * 3.0 + pos.x) * 0.2 * operateFactor;

            } else if (partType > 2.5) {
                // Type 3: å‡‰æ°´å¡”è’¸æ±½ (ä¸Šå‡å¹¶æ¶ˆæ•£)
                float steamCycle = mod(time * speed + initialPos.y * 0.1, 6.0); // 6ç§’ä¸€ä¸ªå‘¨æœŸ
                pos.y += steamCycle * 5.0; // ä¸Šå‡
                pos.x += sin(time + pos.y*0.5) * 2.0 * (steamCycle/6.0); // éšé£é£˜åŠ¨
                pos.z += cos(time + pos.y*0.5) * 2.0 * (steamCycle/6.0);
                
                // è¶Šé«˜è¶Šé€æ˜
                vAlpha = 1.0 - (steamCycle / 6.0);
                if (vAlpha < 0.0) vAlpha = 0.0;
                // è¿è¡ŒçŠ¶æ€ä¸‹è’¸æ±½æ›´å¤šæ›´æ˜æ˜¾
                vAlpha *= (0.3 + operateFactor * 0.7);
            }

            // --- æ•£å¼€æ¨¡å¼ ---
            if (scatter > 0.0) {
                // ç®€å•çš„å¾„å‘æ•£å¼€
                vec3 dir = normalize(initialPos); 
                pos = mix(pos, initialPos + dir * 100.0, scatter);
                // æ•£å¼€æ—¶å¢åŠ éšæœºæ‰°åŠ¨
                pos.x += sin(time + initialPos.y)*10.0*scatter;
                vAlpha *= (1.0 - scatter * 0.5);
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor; varying float vAlpha;
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            // æŸ”å’Œè¾¹ç¼˜
            float glow = 1.0 - r;
            gl_FragColor = vec4(vColor, vAlpha * glow * 1.2);
        }
    </script>

    <script>
        // --- é…ç½®ä¸çŠ¶æ€ ---
        const CONFIG = {
            cameraZ: 70,
            colors: {
                techBlue: new THREE.Color(0x0088ff), // ç§‘æŠ€è“
                brightCyan: new THREE.Color(0x00ffff), // äº®é’
                energyGold: new THREE.Color(0xffaa00), // èƒ½é‡é‡‘
                white: new THREE.Color(0xffffff),
                steamGrey: new THREE.Color(0xaaaaaa)
            }
        };
        const STATE = { mode: 'ENERGY', handVisible: false, handX:0.5, handY:0.5, gesture:'NONE' };

        let scene, camera, renderer, composer;
        let particles, uniforms;
        let photoGroup, raycaster = new THREE.Raycaster();
        let photosData = [];

        // --- å¯åŠ¨é€»è¾‘ ---
        window.onload = function() {
            const btn = document.getElementById('start-btn');
            const txt = document.getElementById('loading-text');
            if (typeof THREE === 'undefined') {
                txt.innerText = "âŒ æ ¸å¿ƒåº“åŠ è½½å¤±è´¥ (è¯·åˆ·æ–°)"; return;
            }
            txt.style.display = 'none'; btn.style.display = 'block';
            btn.onclick = () => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 800);
                init();
                try { startAI(); } catch(e) { console.log("AI skipped"); }
            };
        };

        // --- åˆå§‹åŒ– 3D åœºæ™¯ ---
        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // ç§‘æŠ€æ„Ÿé›¾æ°”
            scene.fog = new THREE.FogExp2(0x000510, 0.0015);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, CONFIG.cameraZ);
            camera.lookAt(0, 5, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // ç¯å…‰
            scene.add(new THREE.AmbientLight(0x112233, 0.5));
            const blueLight = new THREE.PointLight(0x0088ff, 2, 150); blueLight.position.set(20, 30, 20); scene.add(blueLight);
            const goldLight = new THREE.PointLight(0xffaa00, 1.5, 150); goldLight.position.set(-20, 10, 10); scene.add(goldLight);

            // è¾‰å…‰åæœŸ
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.3; bloomPass.strength = 1.2; bloomPass.radius = 0.8;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene); composer.addPass(bloomPass);
            } catch(e) { composer = null; }

            // åˆ›å»ºç²’å­åœºæ™¯
            createEnergyParticles();

            // ç…§ç‰‡ç»„
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            // äº‹ä»¶
            document.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('resize', onResize, false);
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            animate();
        }

        // --- æ ¸å¿ƒï¼šåˆ›å»ºèƒ½æºåœºæ™¯ç²’å­ ---
        function createEnergyParticles() {
            const positions = []; const colors = []; const sizes = []; const partTypes = []; const initialPos = [];
            const tempVec = new THREE.Vector3();
            const tempCol = new THREE.Color();

            // è¾…åŠ©å‡½æ•°ï¼šæ·»åŠ ç²’å­ç°‡
            function addParticleCluster(geometry, colorBase, type, count, posOffset, scaleMult=1) {
                const posAttr = geometry.attributes.position;
                for(let i=0; i<count; i++) {
                    // éšæœºé‡‡æ ·é¡¶ç‚¹
                    const idx = Math.floor(Math.random() * posAttr.count);
                    tempVec.fromBufferAttribute(posAttr, idx);
                    // åº”ç”¨å˜æ¢
                    tempVec.multiplyScalar(scaleMult);
                    tempVec.add(posOffset);
                    // ç¨å¾®æŠ–åŠ¨å¢åŠ ä½“ç§¯æ„Ÿ
                    tempVec.x += (Math.random()-0.5)*0.5;
                    tempVec.y += (Math.random()-0.5)*0.5;
                    tempVec.z += (Math.random()-0.5)*0.5;

                    positions.push(tempVec.x, tempVec.y, tempVec.z);
                    initialPos.push(tempVec.x, tempVec.y, tempVec.z);

                    // é¢œè‰²å˜å¥
                    tempCol.copy(colorBase);
                    if(Math.random()>0.7) tempCol.lerp(CONFIG.colors.white, Math.random()*0.5); // é«˜å…‰
                    colors.push(tempCol.r, tempCol.g, tempCol.b);
                    
                    sizes.push(0.6 + Math.random()*0.8);
                    partTypes.push(type);
                }
            }

            // 1. å‡‰æ°´å¡” (Cooling Tower) - é™æ€ (Type 0)
            // ä½¿ç”¨ä¸¤ä¸ªåœ†å°æ‹¼æ¥æ¨¡æ‹ŸåŒæ›²çº¿
            const towerBotGeo = new THREE.CylinderGeometry(7, 10, 12, 32, 10, true);
            towerBotGeo.translate(0, 6, 0);
            const towerTopGeo = new THREE.CylinderGeometry(8, 7, 10, 32, 10, true);
            towerTopGeo.translate(0, 17, 0);
            addParticleCluster(towerBotGeo, CONFIG.colors.techBlue, 0, 1500, new THREE.Vector3(0,0,-10));
            addParticleCluster(towerTopGeo, CONFIG.colors.techBlue, 0, 1200, new THREE.Vector3(0,0,-10));

            // 2. è’¸æ±½ (Steam) - åŠ¨æ€ (Type 3)
            const steamGeo = new THREE.CylinderGeometry(8, 2, 5, 16);
            addParticleCluster(steamGeo, CONFIG.colors.steamGrey, 3, 800, new THREE.Vector3(0, 22, -10));

            // 3. é£æœº (Wind Turbine)
            // å¡”ç­’ (Static Type 0)
            const poleGeo = new THREE.CylinderGeometry(0.8, 1.5, 25, 16);
            poleGeo.translate(0, 12.5, 0);
            addParticleCluster(poleGeo, CONFIG.colors.white, 0, 800, new THREE.Vector3(-15, 0, -5));
            // æœºèˆ± (Static Type 0)
            const nacelleGeo = new THREE.BoxGeometry(3, 2, 4);
            addParticleCluster(nacelleGeo, CONFIG.colors.white, 0, 200, new THREE.Vector3(-15, 25, -5));
            // å¶ç‰‡ (Dynamic Type 1)
            const bladeGeo = new THREE.BoxGeometry(0.8, 14, 0.5);
            bladeGeo.translate(0, 7, 0); // è½´å¿ƒåœ¨æ ¹éƒ¨
            for(let i=0; i<3; i++) {
                 const bladeRot = bladeGeo.clone();
                 bladeRot.rotateZ(i * Math.PI * 2 / 3);
                 addParticleCluster(bladeRot, CONFIG.colors.brightCyan, 1, 400, new THREE.Vector3(-15, 25, -5));
            }

            // 4. å…‰ä¼æ¿ (PV Panels) - åŠ¨æ€é—ªçƒ (Type 2)
            const panelGeo = new THREE.PlaneGeometry(5, 3);
            panelGeo.rotateX(-Math.PI/2 * 0.7); // å€¾æ–œ
            for(let x=-20; x<=20; x+=6) {
                for(let z=5; z<=15; z+=4) {
                    addParticleCluster(panelGeo, CONFIG.colors.energyGold, 2, 150, new THREE.Vector3(x, 1, z));
                }
            }

            // åˆå¹¶å‡ ä½•ä½“
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('initialPos', new THREE.Float32BufferAttribute(initialPos, 3));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('partType', new THREE.Float32BufferAttribute(partTypes, 1));

            uniforms = {
                time: { value: 0.0 },
                operateFactor: { value: 0.0 },
                scatter: { value: 0.0 }
            };

            const mat = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        // --- äº¤äº’ä¸åŠ¨ç”» ---
        function onMouseMove(e) {
            if (!STATE.handVisible && STATE.mode === 'SCATTER') {
                // ç®€å•çš„é¼ æ ‡è§†è§’æ§åˆ¶
                const x = (e.clientX / window.innerWidth) * 2 - 1;
                const y = -(e.clientY / window.innerHeight) * 2 + 1;
                camera.position.x = x * 20;
                camera.position.y = 20 + y * 5;
                camera.lookAt(0, 5, 0);
            }
        }
        function onResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); if(composer) composer.setSize(window.innerWidth, window.innerHeight);}
        
        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }
        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.encoding=THREE.sRGBEncoding;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(6*aspect, 6), mat);
            const frame = new THREE.Mesh(new THREE.BoxGeometry(6*aspect+0.2, 6.2, 0.1), new THREE.MeshStandardMaterial({color:0x00aaff}));
            mesh.position.z = 0.06; frame.add(mesh);
            // éšæœºå‡ºç°åœ¨å…‰ä¼æ¿ä¸Šæ–¹
            const x = (Math.random()-0.5)*40; const z = 5 + Math.random()*10;
            frame.position.set(x, 15, z);
            frame.userData = { 
                home: frame.position.clone(), 
                scat: new THREE.Vector3((Math.random()-0.5)*150, (Math.random()-0.5)*100, (Math.random()-0.5)*150),
                focus: false 
            };
            photoGroup.add(frame); photosData.push(frame);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            if(uniforms) {
                uniforms.time.value = time;
                // çŠ¶æ€å¹³æ»‘
                let to = (STATE.mode === 'OPERATING') ? 1.0 : 0.0;
                let ts = (STATE.mode === 'SCATTER') ? 1.0 : 0.0;
                uniforms.operateFactor.value += (to - uniforms.operateFactor.value) * 0.05;
                uniforms.scatter.value += (ts - uniforms.scatter.value) * 0.05;
            }

            // ç…§ç‰‡åŠ¨ç”»
            photosData.forEach(p => {
                const d = p.userData; let tgt = (STATE.mode === 'SCATTER') ? d.scat : d.home;
                if(d.focus) {
                    const v = new THREE.Vector3(0,0,-15).applyQuaternion(camera.quaternion); tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position); 
                } else {
                    p.lookAt(camera.position);
                    if(STATE.mode === 'OPERATING') tgt.y = d.home.y + Math.sin(time*2 + p.id)*1.5; // è¿è¡Œæ—¶ä¸Šä¸‹æµ®åŠ¨
                }
                p.position.lerp(tgt, 0.05);
            });

            if(STATE.mode !== 'SCATTER') {
                 camera.position.lerp(new THREE.Vector3(0, 20, CONFIG.cameraZ), 0.05);
                 camera.lookAt(0, 5, 0);
            }

            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        // --- AI æ‰‹åŠ¿ ---
        async function startAI() {
            const video = document.getElementsByClassName('input_video')[0];
            const stat = document.getElementById('gesture-status');
            if(typeof Hands === 'undefined') { stat.innerText = "ä»…é¼ æ ‡æ¨¡å¼"; return; }
            const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults(res => {
                if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    STATE.handVisible = true; const lm = res.multiHandLandmarks[0];
                    // Væ‰‹åŠ¿
                    if (lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y) {
                        STATE.mode = 'OPERATING'; stat.innerText = "âœŒï¸ å…¨é¢è¿è¡Œ (Operating)";
                    } else if (Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05) {
                        STATE.gesture = 'PINCH'; stat.innerText = "ğŸ‘Œ æŠ“å–ç…§ç‰‡ (Grab)";
                        handleGrab();
                    } else if (lm[8].y > lm[5].y) { // æ‹³å¤´
                        STATE.mode = 'ENERGY'; stat.innerText = "âœŠ é™æ€å±•ç¤º (Static)";
                    } else {
                        STATE.mode = 'SCATTER'; stat.innerText = "ğŸ– æ•£å¼€æ¼«æ¸¸ (Scatter)";
                        resetPhoto();
                    }
                } else {
                    STATE.handVisible = false; stat.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                }
            });
            const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
            await cam.start(); stat.innerText = "AI æ¿€æ´»";
        }

        function handleGrab() {
            if(photosData.length === 0 || STATE.mode === 'SCATTER') return;
            // ç®€å•é€»è¾‘ï¼šæŠ“å–æœ€æ–°çš„ç…§ç‰‡
            resetPhoto();
            photosData[photosData.length-1].userData.focus = true;
        }
        function resetPhoto() { photosData.forEach(p=>p.userData.focus=false); }
    </script>
</body>
</html>
