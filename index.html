<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D Morphing Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Arial', sans-serif; }
        
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; opacity: 0.5; }
        
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 24px; color: #FFD700; letter-spacing: 2px; text-shadow: 0 0 20px rgba(196, 30, 58, 0.5); font-weight: 300; }
        .status { font-size: 16px; color: rgba(255,255,255,0.8); margin-top: 10px; font-weight: normal; letter-spacing: 1px;}
        .tips { font-size: 12px; color: #aaa; margin-top: 5px; margin-bottom: 15px;}
        .cycle-indicator { font-size: 14px; color: #00ffff; margin-top: 5px; font-weight: bold; }

        #upload-container { pointer-events: auto; display: inline-block; }
        input[type="file"] { display: none; }
        .btn { 
            background: rgba(255, 215, 0, 0.1); 
            border: 1px solid #FFD700; 
            padding: 8px 15px; 
            color: #FFD700; 
            font-size: 12px;
            cursor: pointer; 
            border-radius: 4px; 
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn:hover { background: #FFD700; color: #000; box-shadow: 0 0 15px #FFD700; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; z-index: 20; font-size: 16px; text-align: center; letter-spacing: 2px; }
        #hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.3); font-size: 12px; pointer-events: none; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨ç”Ÿæˆå¤šé‡å½¢æ€...<br>è§£ææ–‡å­—ä¸Logoæ•°æ®</div>
    
    <div id="ui-layer">
        <h1>å…‰å½±å™äº‹ Â· å¾ªç¯</h1>
        <div class="status" id="status-text">ç­‰å¾…æŒ‡ä»¤...</div>
        <div class="cycle-indicator" id="cycle-text">å½“å‰å½¢æ€: ğŸ çµé©¹</div>
        <div class="tips">ğŸ–å¼ å¼€æ•£å¼€ -> âœŠæ¡æ‹³å˜æ¢å½¢æ€</div>
        
        <div id="upload-container">
            <label class="btn">
                + ä¸Šä¼ ç…§ç‰‡ (Max 30)
                <input type="file" id="file-input" multiple accept="image/*">
            </label>
        </div>
    </div>
    
    <div id="hint">æåˆæ‰‹æŒ‡ (ğŸ‘Œ) å¯å°†ç…§ç‰‡æŠ“åˆ°çœ¼å‰</div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>

    <canvas id="textCanvas" width="1024" height="512" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- é…ç½® ---
        const CONFIG = {
            particleCount: 7000, 
            horseColors: [0x0F52BA, 0xFFD700, 0xC41E3A], // é©¬ï¼šè“é‡‘çº¢
            textColors: [0x88CCFF, 0xAAFFFF, 0x0088AA],   // æ–‡å­—ï¼šæ˜Ÿå…‰è“
            logoColors: [0xCC0000, 0x009900, 0xFFFF00],   // Logoï¼šçº¢ç»¿(ç¨‹åºåŒ–ç”Ÿæˆ)
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb',
            maxPhotos: 30
        };

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer, controls;
        let particles = []; // å­˜å‚¨æ‰€æœ‰ç²’å­å¯¹è±¡
        let group;
        let state = 'CONVERGED';
        let time = 0;
        let handPosition = { x: 0.5, y: 0.5 };
        let activeZoomParticle = null;

        // å½¢æ€ç®¡ç†
        // 0: Horse, 1: Text, 2: Logo
        let currentShapeIndex = 0; 
        const SHAPES = {
            HORSE: [],
            TEXT: [],
            LOGO: []
        };
        // æ ‡è®°æ˜¯å¦å·²ç»ä»æ•£å¼€çŠ¶æ€å›æ¥ï¼Œç”¨äºè§¦å‘å˜æ¢
        let readyToSwitch = false; 

        init();
        animate();
        initMediaPipe();

        async function init() {
            // 1. åœºæ™¯æ­å»º
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.0015);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 400);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(50, 50, 100);
            scene.add(mainLight);

            // è¾‰å…‰
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;
            bloomPass.threshold = 0.1;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // 2. ç”Ÿæˆä¸‰ç§å½¢æ€çš„æ•°æ®
            await generateAllShapes();

            // 3. åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystem();

            // 4. äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            document.getElementById('loading').style.display = 'none';
        }

        // --- æ ¸å¿ƒï¼šå½¢æ€ç”Ÿæˆå™¨ ---
        async function generateAllShapes() {
            // 1. ç”Ÿæˆé©¬çš„æ•°æ® (å¼‚æ­¥åŠ è½½)
            await new Promise(resolve => {
                const loader = new GLTFLoader();
                loader.load(CONFIG.modelUrl, (gltf) => {
                    const mesh = gltf.scene.children[0];
                    const positions = getPointsFromMesh(mesh, CONFIG.particleCount, 1.2); // 1.2 scale
                    // å±…ä¸­
                    centerPoints(positions);
                    SHAPES.HORSE = positions;
                    resolve();
                });
            });

            // 2. ç”Ÿæˆæ–‡å­—æ•°æ® "é£å…‰æ— é™ å›½å®¶ç”µæŠ•"
            SHAPES.TEXT = generateTextPoints("é£å…‰æ— é™", "å›½å®¶ç”µæŠ•", CONFIG.particleCount);
            
            // 3. ç”ŸæˆLogoæ•°æ® (çº¢ç»¿ä¸å¸¦ Logo)
            SHAPES.LOGO = generateLogoPoints(CONFIG.particleCount);
        }

        function getPointsFromMesh(mesh, count, scale) {
            const tempPoints = [];
            const posAttr = mesh.geometry.attributes.position;
            const tempVec = new THREE.Vector3();
            for(let i=0; i<posAttr.count; i++) {
                tempVec.fromBufferAttribute(posAttr, i);
                tempVec.multiplyScalar(scale);
                tempPoints.push(tempVec.clone());
            }
            return samplePoints(tempPoints, count);
        }

        function generateTextPoints(line1, line2, count) {
            const canvas = document.getElementById('textCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,1024,512);
            
            ctx.font = "bold 140px 'Microsoft YaHei', sans-serif";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.fillText(line1, 512, 180);
            ctx.fillText(line2, 512, 380);

            const imageData = ctx.getImageData(0, 0, 1024, 512);
            const data = imageData.data;
            const points = [];
            
            // æ‰«æåƒç´ 
            for(let y=0; y<512; y+=4) { // æ­¥é•¿å½±å“å¯†åº¦
                for(let x=0; x<1024; x+=4) {
                    const alpha = data[(y * 1024 + x) * 4 + 3];
                    if(alpha > 128) {
                        // æ˜ å°„åˆ° 3D ç©ºé—´
                        const pX = (x - 512) * 0.3;
                        const pY = -(y - 256) * 0.3; // Yè½´åè½¬
                        // å¢åŠ åšåº¦ (Zè½´éšæœº)
                        for(let k=0; k<3; k++) { // æ¯ä¸ªåƒç´ ç”Ÿæˆ3ä¸ªç‚¹å¢åŠ åšåº¦
                            points.push(new THREE.Vector3(pX, pY, (Math.random()-0.5) * 20));
                        }
                    }
                }
            }
            return samplePoints(points, count);
        }

        function generateLogoPoints(count) {
            // ç¨‹åºåŒ–ç”Ÿæˆçº¢ç»¿ Logo (Så½¢/8å­—å½¢ä¸å¸¦)
            const points = [];
            // ä¸ŠåŠéƒ¨åˆ† (ç»¿è‰²å€’U)
            for(let i=0; i<count/2; i++) {
                const t = Math.PI + (i / (count/2)) * Math.PI; // PI to 2PI
                const radius = 60;
                const x = Math.cos(t) * radius; // èºæ—‹X
                const y = Math.sin(t) * radius * 0.8 + 30; // èºæ—‹Y + åç§»
                // ä¸å¸¦å®½åº¦
                const width = (Math.random() - 0.5) * 40;
                // ä¸å¸¦åšåº¦
                const depth = (Math.random() - 0.5) * 10;
                
                // ç¨å¾®å€¾æ–œ
                points.push(new THREE.Vector3(x + width*0.5, y, depth + width*0.2));
            }
            // ä¸‹åŠéƒ¨åˆ† (çº¢è‰²U)
            for(let i=0; i<count/2; i++) {
                const t = (i / (count/2)) * Math.PI; // 0 to PI
                const radius = 60;
                const x = Math.cos(t) * radius;
                const y = Math.sin(t) * radius * 0.8 - 30; // ä¸‹ç§»
                const width = (Math.random() - 0.5) * 40;
                const depth = (Math.random() - 0.5) * 10;
                points.push(new THREE.Vector3(x + width*0.5, y, depth - width*0.2));
            }
            
            return samplePoints(points, count);
        }

        // è¾…åŠ©ï¼šä»å¤§é‡ç‚¹ä¸­éšæœºé‡‡æ ·å›ºå®šæ•°é‡ï¼Œå¹¶å±…ä¸­
        function samplePoints(sourcePoints, targetCount) {
            // 1. å±…ä¸­
            const box = new THREE.Box3().setFromPoints(sourcePoints);
            const center = box.getCenter(new THREE.Vector3());
            sourcePoints.forEach(p => p.sub(center));
            
            // 2. é‡‡æ ·
            const result = [];
            // å¦‚æœç‚¹ä¸å¤Ÿï¼Œé‡å¤åˆ©ç”¨
            for(let i=0; i<targetCount; i++) {
                const p = sourcePoints[i % sourcePoints.length];
                result.push(p.clone());
            }
            // æ‰“ä¹±é¡ºåº
            result.sort(() => Math.random() - 0.5);
            return result;
        }
        
        function centerPoints(points) {
             const box = new THREE.Box3().setFromPoints(points);
             const center = box.getCenter(new THREE.Vector3());
             points.forEach(p => p.sub(center));
        }

        function createParticleSystem() {
            group = new THREE.Group();
            scene.add(group);

            // åŸºç¡€å‡ ä½•ä½“ï¼šé©¬å’ŒLogoç”¨åœ†ç‚¹ï¼Œæ–‡å­—ç”¨æ–¹å—
            const geomSphere = new THREE.SphereGeometry(0.5, 6, 6);
            const geomBox = new THREE.BoxGeometry(0.8, 0.8, 0.8);

            // é¢„åˆ›å»ºæ‰€æœ‰ç²’å­
            for(let i=0; i<CONFIG.particleCount; i++) {
                const mesh = new THREE.Mesh(geomSphere, new THREE.MeshBasicMaterial({color: 0xffffff}));
                
                // åˆå§‹æ•£å¼€ä½ç½®
                const scatterPos = new THREE.Vector3(
                    (Math.random()-0.5) * 300,
                    (Math.random()-0.5) * 300,
                    (Math.random()-0.5) * 300
                );
                
                mesh.position.copy(scatterPos);
                group.add(mesh);

                particles.push({
                    mesh: mesh,
                    // å­˜å‚¨ä¸‰ç§å½¢æ€çš„ç›®æ ‡ä½ç½®
                    targetHorse: SHAPES.HORSE[i],
                    targetText: SHAPES.TEXT[i],
                    targetLogo: SHAPES.LOGO[i],
                    currentShapeTarget: SHAPES.HORSE[i], // é»˜è®¤ä¸ºé©¬
                    scatterPos: scatterPos,
                    isPhoto: false,
                    baseColor: new THREE.Color(), // å½“å‰å½¢æ€çš„åŸºç¡€è‰²
                    velocity: new THREE.Vector3(0,0,0)
                });
            }
            
            // åˆå§‹åŒ–ä¸ºé©¬çš„é¢œè‰²
            updateParticleColors(0);
            updateState('DISPERSED');
        }

        // æ›´æ–°ç²’å­é¢œè‰²å’Œæè´¨
        function updateParticleColors(shapeIndex) {
            let palette;
            let isText = (shapeIndex === 1);
            let isLogo = (shapeIndex === 2);

            if (shapeIndex === 0) palette = CONFIG.horseColors;
            else if (shapeIndex === 1) palette = CONFIG.textColors;
            else palette = CONFIG.logoColors;

            particles.forEach((p, i) => {
                if(p.isPhoto) return; // ç…§ç‰‡ç²’å­ä¿æŒåŸæ ·

                // 1. è®¾ç½®é¢œè‰²
                let colorHex;
                if (isLogo) {
                    // Logo ç‰¹æ®Šé€»è¾‘ï¼šçº¢ç»¿åˆ†ç¦»
                    // æ ¹æ® Y è½´ä½ç½®å†³å®šé¢œè‰²
                    if (p.targetLogo.y > 0) {
                        // ä¸ŠåŠéƒ¨åˆ†ç»¿è‰²æ¸å˜
                        colorHex = 0x44aa44; // Green
                    } else {
                        // ä¸‹åŠéƒ¨åˆ†çº¢è‰²æ¸å˜
                        colorHex = 0xdd3333; // Red
                    }
                } else {
                    colorHex = palette[Math.floor(Math.random() * palette.length)];
                }
                
                const c = new THREE.Color(colorHex);
                p.baseColor = c;

                // 2. åŠ¨ç”»è¿‡æ¸¡é¢œè‰²
                gsap.to(p.mesh.material.color, {r: c.r, g: c.g, b: c.b, duration: 1});

                // 3. æè´¨å½¢çŠ¶åˆ‡æ¢
                if(isText) {
                    // æ–‡å­—å½¢æ€ï¼šæ–¹å½¢ç¢ç»ç’ƒ
                    if(p.mesh.geometry.type !== 'BoxGeometry') {
                        p.mesh.geometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                    }
                    // å¢åŠ ä¸€ç‚¹é€æ˜æ„Ÿ
                    p.mesh.material.opacity = 0.8;
                    p.mesh.material.transparent = true;
                } else {
                    // é©¬å’ŒLogoï¼šåœ†ç‚¹
                    if(p.mesh.geometry.type !== 'SphereGeometry') {
                        p.mesh.geometry = new THREE.SphereGeometry(0.5, 6, 6);
                    }
                    p.mesh.material.opacity = 1;
                    p.mesh.material.transparent = false;
                }
            });
        }

        // --- äº¤äº’é€»è¾‘ ---
        function updateState(newState) {
            if (state === newState && state !== 'ZOOM') return;

            // å¦‚æœä» ZOOM é€€å‡ºï¼Œæ¢å¤ activeZoomParticle
            if (state === 'ZOOM' && newState !== 'ZOOM' && activeZoomParticle) {
                // ä¸åšç‰¹æ®Šå¤„ç†ï¼Œè®©ä¸‹é¢çš„å¾ªç¯è‡ªåŠ¨æ¥ç®¡ä½ç½®
                activeZoomParticle = null;
            }

            // çŠ¶æ€æœºæ ¸å¿ƒï¼šæ•£å¼€ -> èšåˆ æ—¶è§¦å‘å½¢æ€åˆ‡æ¢
            if (state === 'DISPERSED' && newState === 'CONVERGED') {
                if (readyToSwitch) {
                    currentShapeIndex = (currentShapeIndex + 1) % 3;
                    updateCycleIndicator();
                    updateParticleColors(currentShapeIndex);
                    readyToSwitch = false; // é‡ç½®å¼€å…³
                }
            } else if (newState === 'DISPERSED') {
                readyToSwitch = true; // å‡†å¤‡å¥½ä¸‹ä¸€æ¬¡åˆ‡æ¢
            }

            state = newState;
            const statusEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                statusEl.innerText = "çŠ¶æ€: èšåˆ";
                statusEl.style.color = "#FFD700";
                
                particles.forEach(p => {
                    // ç¡®å®šå½“å‰ç›®æ ‡
                    let target;
                    if(currentShapeIndex === 0) target = p.targetHorse;
                    else if(currentShapeIndex === 1) target = p.targetText;
                    else target = p.targetLogo;

                    // åŠ¨ç”»
                    gsap.to(p.mesh.position, {
                        x: target.x, y: target.y, z: target.z,
                        duration: 1.5, ease: "power3.inOut"
                    });
                    
                    // æ—‹è½¬å½’é›¶
                    gsap.to(p.mesh.rotation, {x:0, y:0, z:0, duration: 1});

                    // ç…§ç‰‡é€»è¾‘ï¼šåœ¨èšåˆæ€ï¼Œè®©ç…§ç‰‡ç¨å¾®å¾€å¤–é£˜ä¸€ç‚¹ç‚¹ï¼Œä¿è¯å¯è§
                    if (p.isPhoto) {
                        gsap.to(p.mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                        // ç¨å¾®åŠ ä¸€ç‚¹Zè½´åç§»ï¼Œé˜²æ­¢è¢«åŸ‹åœ¨å†…éƒ¨
                        gsap.to(p.mesh.position, {
                            z: target.z + 5, 
                            duration: 1.5,
                            overwrite: "auto"
                        });
                        p.mesh.lookAt(camera.position); // å§‹ç»ˆæœå‘è§‚ä¼—
                    } else {
                         gsap.to(p.mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                    }
                });

            } else if (state === 'DISPERSED') {
                statusEl.innerText = "çŠ¶æ€: æ•£å¼€ (å‡†å¤‡å˜æ¢)";
                statusEl.style.color = "#00ffff";
                
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.scatterPos.x, y: p.scatterPos.y, z: p.scatterPos.z,
                        duration: 2.0, ease: "power2.out"
                    });
                    
                    if (p.isPhoto) {
                        gsap.to(p.mesh.scale, { x: 2, y: 2, z: 1, duration: 1 });
                    }
                });

            } else if (state === 'ZOOM') {
                statusEl.innerText = "çŠ¶æ€: ğŸ“¸ å›å¿†æ•è·";
                statusEl.style.color = "#ff00ff";
                
                const photoParticles = particles.filter(p => p.isPhoto);
                if (photoParticles.length > 0) {
                    // éšæœºæŠ“ä¸€å¼ 
                    const target = photoParticles[Math.floor(Math.random() * photoParticles.length)];
                    activeZoomParticle = target;

                    // è®¡ç®—ç›¸æœºæ­£å‰æ–¹çš„ç‚¹
                    // è·å–ç›¸æœºè§†çº¿æ–¹å‘
                    const vector = new THREE.Vector3(0, 0, -1);
                    vector.applyQuaternion(camera.quaternion);
                    // è·ç¦»ç›¸æœºå¾ˆè¿‘çš„ä½ç½® (ä¾‹å¦‚ 15 ä¸ªå•ä½)
                    const targetPos = camera.position.clone().add(vector.multiplyScalar(20));

                    gsap.to(target.mesh.position, {
                        x: targetPos.x, y: targetPos.y, z: targetPos.z,
                        duration: 0.8, ease: "back.out(1.2)"
                    });
                    // æ”¾å¤§
                    gsap.to(target.mesh.scale, { x: 8, y: 8, z: 1, duration: 0.8 });
                    // é¢å‘ç›¸æœº
                    target.mesh.lookAt(camera.position);
                    // ä¿®æ­£æ—‹è½¬ï¼Œå› ä¸ºlookAtæœ‰æ—¶å€™ä¼šè®©å›¾ç‰‡ä¸Šä¸‹é¢ å€’ï¼Œå¼ºåˆ¶åŒæ­¥ç›¸æœºæ—‹è½¬
                    gsap.to(target.mesh.rotation, {
                        x: camera.rotation.x,
                        y: camera.rotation.y,
                        z: camera.rotation.z,
                        duration: 0.8
                    });

                } else {
                    statusEl.innerText = "æç¤º: è¯·å…ˆä¸Šä¼ ç…§ç‰‡";
                }
            }
        }

        function updateCycleIndicator() {
            const el = document.getElementById('cycle-text');
            if (currentShapeIndex === 0) el.innerText = "å½“å‰å½¢æ€: ğŸ çµé©¹";
            else if (currentShapeIndex === 1) el.innerText = "å½“å‰å½¢æ€: ğŸ’ æ–‡å­— (é£å…‰æ— é™)";
            else el.innerText = "å½“å‰å½¢æ€: ğŸ—ï¸ æ ‡è¯† (Logo)";
        }

        // --- ç…§ç‰‡å¤„ç† ---
        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;

            // é™åˆ¶æœ€å¤š 30 å¼ 
            const limit = Math.min(files.length, CONFIG.maxPhotos);
            const textureLoader = new THREE.TextureLoader();
            
            // é‡ç½®ä¹‹å‰çš„ç…§ç‰‡ç²’å­
            particles.forEach(p => {
                if(p.isPhoto) {
                    p.isPhoto = false;
                    p.mesh.material = new THREE.MeshBasicMaterial({color: p.baseColor});
                }
            });

            // é€‰å–ç²’å­å˜æˆç…§ç‰‡
            const photoIndices = [];
            while(photoIndices.length < limit) {
                const idx = Math.floor(Math.random() * particles.length);
                if(!photoIndices.includes(idx)) photoIndices.push(idx);
            }

            let loadedCount = 0;
            Array.from(files).slice(0, limit).forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        texture.colorSpace = THREE.SRGBColorSpace;

                        const pIndex = photoIndices[i];
                        const p = particles[pIndex];
                        
                        p.isPhoto = true;
                        p.mesh.geometry = new THREE.PlaneGeometry(3, 3); // ç…§ç‰‡ç¨å¾®å¤§ä¸€ç‚¹
                        p.mesh.material = new THREE.MeshBasicMaterial({ 
                            map: texture, 
                            side: THREE.DoubleSide,
                            transparent: true
                        });
                        
                        loadedCount++;
                        if(loadedCount === limit) {
                            alert(`å·²åŠ è½½ ${limit} å¼ ç…§ç‰‡ã€‚\nå°†åœ¨ä¸‰ç§å½¢æ€ä¸­å¾ªç¯å±•ç¤ºã€‚`);
                        }
                    };
                };
                reader.readAsDataURL(file);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            if (!group) return;

            // æ•´ä½“å‘¼å¸
            group.position.y = Math.sin(time * 0.8) * 2; 

            if (state === 'DISPERSED') {
                // æ•£å¼€æ¸¸åŠ¨
                particles.forEach(p => {
                    if (state === 'ZOOM' && p === activeZoomParticle) return;
                    const noise = Math.sin(time + p.scatterPos.x) * 0.2;
                    p.mesh.position.x += Math.cos(time) * 0.02;
                    p.mesh.position.y += Math.sin(time) * 0.02;
                    if(p.isPhoto) p.mesh.lookAt(camera.position);
                });

                // æ‰‹åŠ¿æ§åˆ¶æ—‹è½¬
                const targetRotY = (handPosition.x - 0.5) * 2; 
                const targetRotX = (handPosition.y - 0.5) * 1;
                group.rotation.y += (targetRotY - group.rotation.y) * 0.05;
                group.rotation.x += (targetRotX - group.rotation.x) * 0.05;

            } else if (state === 'CONVERGED') {
                // èšåˆè‡ªè½¬
                group.rotation.y += 0.003;
                // ä¿è¯èšåˆçŠ¶æ€ä¸‹ï¼Œç…§ç‰‡ä¹Ÿæ—¶åˆ»æœå‘è§‚ä¼—
                particles.forEach(p => {
                    if(p.isPhoto) p.mesh.lookAt(camera.position);
                });
            }

            controls.update();
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('video-element');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) return;
                
                const lm = results.multiHandLandmarks[0];
                const palmX = (lm[0].x + lm[9].x) / 2;
                const palmY = (lm[0].y + lm[9].y) / 2;
                handPosition.x = 1 - palmX; 
                handPosition.y = palmY;

                // æåˆè®¡ç®—
                const thumbTip = lm[4];
                const indexTip = lm[8];
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

                // å¼ å¼€è®¡ç®—
                const tips = [8, 12, 16, 20];
                const bases = [5, 9, 13, 17];
                let openCount = 0;
                tips.forEach((tip, i) => { if (lm[tip].y < lm[bases[i]].y) openCount++; });

                if (pinchDist < 0.05) {
                    if (state !== 'ZOOM') updateState('ZOOM');
                } else if (openCount >= 3) {
                    if (state !== 'DISPERSED') updateState('DISPERSED');
                } else if (openCount <= 1) {
                    if (state !== 'CONVERGED') updateState('CONVERGED');
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start();
        }
    </script>
</body>
</html>
