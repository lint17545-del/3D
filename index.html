<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D Particle System V7 - Ultimate Refine</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010103; font-family: 'Microsoft YaHei', sans-serif; }
        
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 1px solid rgba(255, 215, 0, 0.5); border-radius: 8px; opacity: 0.6; }
        
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 28px; color: #FFD700; letter-spacing: 2px; text-shadow: 0 0 15px rgba(255, 0, 0, 0.6); font-weight: bold; }
        .cycle-info { font-size: 22px; margin-top: 10px; color: #fff; font-weight: bold; }
        .status { font-size: 16px; color: rgba(255,255,255,0.7); margin-top: 5px; letter-spacing: 1px;}
        
        #upload-container { pointer-events: auto; display: inline-block; margin-top: 20px; }
        input[type="file"] { display: none; }
        .btn { 
            background: linear-gradient(45deg, #C41E3A, #FFD700);
            border: none; 
            padding: 12px 24px; 
            color: #fff; 
            font-size: 14px;
            font-weight: bold;
            cursor: pointer; 
            border-radius: 30px; 
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            transition: all 0.3s;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(255, 215, 0, 0.6); }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; z-index: 20; font-size: 20px; text-align: center; letter-spacing: 2px; text-shadow: 0 0 10px #C41E3A; }
        
        #hint { position: absolute; bottom: 40px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 14px; letter-spacing: 2px; pointer-events: none; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨æ„å»ºé«˜å¯†åº¦ç²’å­ç³»ç»Ÿ...</div>
    
    <div id="ui-layer">
        <h1>ç²’å­å™äº‹ V7</h1>
        <div class="cycle-info" id="shape-name" style="color:#FFD700">ğŸ æˆ˜é©¬å½¢æ€ (çº¢é‡‘)</div>
        <div class="status" id="status-text">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤...</div>
        
        <div id="upload-container">
            <label class="btn">
                + æ³¨å…¥ç…§ç‰‡è®°å¿† (ç‹¬ç«‹å›¾å±‚)
                <input type="file" id="file-input" multiple accept="image/*">
            </label>
        </div>
    </div>
    
    <div id="hint">âœŠæ¡æ‹³:èšåˆ | ğŸ–å¼ å¼€:æ•£å¼€ | ğŸ‘Œæåˆ:æŠ“å–ç…§ç‰‡ | æ‰‹åŠ¿ç§»åŠ¨:å…¨å±€æ—‹è½¬</div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="textCanvas" width="2048" height="1024" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        const CONFIG = {
            particleCount: 12000, // æå¤§æå‡å¯†åº¦
            maxPhotos: 30,
            colors: {
                horse: [0xD4AF37, 0xC41E3A, 0xFFD700, 0xA50021], // çº¯ç²¹çš„çº¢é‡‘ç³»
                text:  [0x88CCFF], // æ˜Ÿå…‰è“
                spic:  [0x00008B]  // æ·±è“è‰²
            },
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb'
        };

        let scene, camera, renderer, composer;
        let particles = [];
        let photoClouds = []; // ç‹¬ç«‹çš„ç…§ç‰‡ç½‘æ ¼æ•°ç»„
        let mainGroup, photoGroup; // åˆ†ç¦»ç²’å­ç»„å’Œç…§ç‰‡ç»„
        let state = 'CONVERGED';
        let time = 0;
        let handPosition = { x: 0.5, y: 0.5 };
        let activeZoomPhoto = null;

        let currentShapeIndex = 0; 
        const SHAPES = { HORSE: [], TEXT: [], LOGO: [] };
        let pendingShapeChange = false;

        // å‡ ä½•ä½“ç¼“å­˜
        const sphereGeom = new THREE.SphereGeometry(0.5, 8, 8);
        const boxGeom = new THREE.BoxGeometry(0.7, 0.7, 0.7);
        const bigSphereGeom = new THREE.SphereGeometry(0.8, 12, 12); // ç”¨äºLogoå’Œè£…é¥°

        init();
        animate();
        initMediaPipe();

        async function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x010103, 0.0008);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.position.set(0, 20, 400);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç¯å…‰å¢å¼º
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const sunLight = new THREE.DirectionalLight(0xFFD700, 1.5);
            sunLight.position.set(100, 100, 50);
            scene.add(sunLight);
            const redLight = new THREE.PointLight(0xC41E3A, 2, 500);
            redLight.position.set(-100, -50, 50);
            scene.add(redLight);

            // åå¤„ç† (Bloom)
            const renderScene = new RenderPass(scene, camera);
            // å¢å¼ºè¾‰å…‰åŠå¾„ï¼Œè¥é€ æ°›å›´
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.6, 0.6, 0.8);
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            mainGroup = new THREE.Group();
            photoGroup = new THREE.Group();
            scene.add(mainGroup);
            scene.add(photoGroup);

            await generateAllShapes();
            createParticles();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUploadV2);
            document.getElementById('loading').style.display = 'none';
        }

        // --- 1. å½¢æ€ç”Ÿæˆ (å‡çº§ç‰ˆ) ---
        async function generateAllShapes() {
            // A. é©¬ (çº¢é‡‘)
            await new Promise(resolve => {
                new GLTFLoader().load(CONFIG.modelUrl, (gltf) => {
                    const positions = getPointsFromMesh(gltf.scene.children[0], CONFIG.particleCount, 1.3);
                    centerPoints(positions);
                    SHAPES.HORSE = positions;
                    resolve();
                });
            });

            // B. æ–‡å­— (ä¿®å¤æˆªæ–­é—®é¢˜)
            SHAPES.TEXT = generateTextPoints("é£å…‰æ— é™ å›½å®¶ç”µæŠ•", CONFIG.particleCount);

            // C. Logo + SPIC (è”åˆä½“)
            SHAPES.LOGO = generateLogoAndSpic(CONFIG.particleCount);
        }

        function generateTextPoints(text, count) {
            const canvas = document.getElementById('textCanvas');
            const ctx = canvas.getContext('2d');
            // ä½¿ç”¨æ›´å¤§çš„ç”»å¸ƒé«˜åº¦
            ctx.clearRect(0,0,2048,1024);
            ctx.font = "bold 160px 'Microsoft YaHei'";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            // å±…ä¸­ç»˜åˆ¶
            ctx.fillText(text, 1024, 512);

            const data = ctx.getImageData(0,0,2048,1024).data;
            const points = [];
            for(let y=0; y<1024; y+=5) {
                for(let x=0; x<2048; x+=5) {
                    if(data[(y*2048+x)*4+3] > 128) {
                        const px = (x - 1024) * 0.3;
                        const py = -(y - 512) * 0.3;
                        points.push(new THREE.Vector3(px, py, (Math.random()-0.5)*20));
                    }
                }
            }
            return samplePoints(points, count);
        }

        function generateLogoAndSpic(count) {
            const points = [];
            // 1. Så½¢ä¸å¸¦ (å·¦ä¾§)
            const ribbonCount = Math.floor(count * 0.7);
            for(let i=0; i<ribbonCount; i++) {
                const t = (i / ribbonCount) * Math.PI * 2;
                let u = (i / ribbonCount);
                let angle = u * Math.PI * 2;
                let x = Math.sin(angle) * 50 - 80; // å·¦ç§»
                let y = Math.cos(angle * 0.5) * 40;
                let z = Math.sin(angle * 2) * 15;
                let width = (Math.random() - 0.5) * 30;
                points.push(new THREE.Vector3(x + Math.cos(angle)*width, y, z + Math.sin(angle)*width*0.3));
            }

            // 2. SPIC æ–‡å­— (å³ä¾§, æ·±è“è‰²)
            const spicCanvas = document.createElement('canvas');
            spicCanvas.width = 512; spicCanvas.height = 256;
            const ctx = spicCanvas.getContext('2d');
            ctx.font = "bold 120px Arial";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("SPIC", 256, 128);
            const data = ctx.getImageData(0,0,512,256).data;
            const spicPoints = [];
            for(let y=0; y<256; y+=4) {
                for(let x=0; x<512; x+=4) {
                    if(data[(y*512+x)*4+3] > 128) {
                        spicPoints.push(new THREE.Vector3((x-256)*0.5 + 80, -(y-128)*0.5, 0)); // å³ç§»
                    }
                }
            }
            
            const finalSpicPoints = samplePoints(spicPoints, count - ribbonCount);
            // æ ‡è®°è¿™äº›ç‚¹å±äº SPIC éƒ¨åˆ†ï¼Œç”¨äºåç»­ä¸Šè‰²
            finalSpicPoints.forEach(p => p.isSpic = true);
            
            return samplePoints(points.concat(finalSpicPoints), count);
        }

        function getPointsFromMesh(mesh, count, scale) {
            const points = [];
            const posAttr = mesh.geometry.attributes.position;
            const temp = new THREE.Vector3();
            for(let i=0; i<posAttr.count; i++) {
                temp.fromBufferAttribute(posAttr, i).multiplyScalar(scale);
                points.push(temp.clone());
            }
            return samplePoints(points, count);
        }

        function samplePoints(src, count) {
            const res = [];
            if(src.length === 0) return res;
            const box = new THREE.Box3().setFromPoints(src);
            const center = box.getCenter(new THREE.Vector3());
            src.forEach(p => p.sub(center));
            for(let i=0; i<count; i++) res.push(src[i % src.length].clone());
            return res.sort(() => Math.random() - 0.5);
        }

        function centerPoints(points) {
             if(points.length === 0) return;
             const box = new THREE.Box3().setFromPoints(points);
             const center = box.getCenter(new THREE.Vector3());
             points.forEach(p => p.sub(center));
        }

        // --- 2. ç²’å­ç³»ç»Ÿ (ä¸å«ç…§ç‰‡) ---
        function createParticles() {
            for(let i=0; i<CONFIG.particleCount; i++) {
                // çº¦ 20% æ˜¯è£…é¥°ç²’å­ï¼Œæ›´å¤§æ›´äº®
                const isDecorator = Math.random() < 0.2;
                const geom = isDecorator ? bigSphereGeom : (Math.random()>0.5 ? sphereGeom : boxGeom);
                const mat = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.2,
                    metalness: 0.8,
                    emissive: 0x000000,
                    emissiveIntensity: isDecorator ? 1.5 : 0.5 // è£…é¥°ç²’å­è‡ªå‘å…‰æ›´å¼º
                });

                const mesh = new THREE.Mesh(geom, mat);
                
                const scatterPos = new THREE.Vector3(
                    (Math.random()-0.5) * 700,
                    (Math.random()-0.5) * 500,
                    (Math.random()-0.5) * 500
                );
                
                mesh.position.copy(scatterPos);
                mainGroup.add(mesh);

                particles.push({
                    mesh: mesh,
                    targets: {
                        0: SHAPES.HORSE[i],
                        1: SHAPES.TEXT[i],
                        2: SHAPES.LOGO[i]
                    },
                    scatterPos: scatterPos,
                    baseColor: new THREE.Color(),
                    isDecorator: isDecorator,
                    seed: Math.random() // ç”¨äºåŠ¨ç”»çš„éšæœºç§å­
                });
            }
            updateParticleVisuals(0);
            updateState('DISPERSED');
        }

        function updateParticleVisuals(shapeIdx) {
            const isHorse = shapeIdx === 0;
            const isText = shapeIdx === 1;
            const isLogo = shapeIdx === 2;
            const uiName = document.getElementById('shape-name');

            if(isHorse) {
                uiName.innerText = "ğŸ æˆ˜é©¬å½¢æ€ (çº¢é‡‘)";
                uiName.style.color = "#FFD700";
            } else if(isText) {
                uiName.innerText = "ğŸ’ æ–‡å­—å½¢æ€ (æ˜Ÿå…‰è“)";
                uiName.style.color = "#88CCFF";
            } else {
                uiName.innerText = "ğŸ—ï¸ Logoå½¢æ€ (çº¢ç»¿+æ·±è“)";
                uiName.style.color = "#FF0000";
            }

            particles.forEach((p, i) => {
                let colorHex, opacity=1, transparent=false, geom=sphereGeom;

                if(isHorse) {
                    // çº¢é‡‘é…è‰²
                    colorHex = CONFIG.colors.horse[Math.floor(Math.random() * CONFIG.colors.horse.length)];
                    geom = p.isDecorator ? bigSphereGeom : sphereGeom;
                } else if(isText) {
                    // æ˜Ÿå…‰è“ï¼Œæ–¹å—ï¼ŒåŠé€æ˜
                    colorHex = CONFIG.colors.text[0];
                    geom = boxGeom;
                    opacity = 0.8; transparent = true;
                } else if(isLogo) {
                    // Logo ç‰¹æ®Šé…è‰²
                    geom = bigSphereGeom; // å¼ºåˆ¶ç”¨å¤§åœ†çƒ
                    const target = p.targets[2];
                    if(target.isSpic) {
                        colorHex = CONFIG.colors.spic[0]; // æ·±è“ SPIC
                    } else {
                        // çº¢ç»¿ä¸å¸¦
                        if(target.y > 0) colorHex = 0x00FF00; // ç»¿
                        else colorHex = 0xFF0000; // çº¢
                    }
                }

                p.baseColor.setHex(colorHex);
                p.mesh.geometry = geom;
                p.mesh.material.transparent = transparent;
                
                gsap.to(p.mesh.material.color, {r: p.baseColor.r, g: p.baseColor.g, b: p.baseColor.b, duration: 0.8});
                gsap.to(p.mesh.material, {opacity: opacity, duration: 0.8});
                // è£…é¥°ç²’å­åœ¨ä»»ä½•å½¢æ€ä¸‹éƒ½ä¿æŒé«˜äº®
                gsap.to(p.mesh.material.emissive, {
                    r: p.isDecorator ? p.baseColor.r : 0,
                    g: p.isDecorator ? p.baseColor.g : 0,
                    b: p.isDecorator ? p.baseColor.b : 0,
                    duration: 0.8
                });
            });
        }

        // --- 3. äº¤äº’ä¸çŠ¶æ€ ---
        function updateState(newState) {
            if (state === newState && state !== 'ZOOM') return;
            
            // å½¢æ€åˆ‡æ¢é€»è¾‘
            if(state === 'DISPERSED' && newState === 'CONVERGED') {
                if(pendingShapeChange) {
                    currentShapeIndex = (currentShapeIndex + 1) % 3;
                    updateParticleVisuals(currentShapeIndex);
                    pendingShapeChange = false;
                }
            } else if (newState === 'DISPERSED') {
                pendingShapeChange = true;
            }
            
            // ä» ZOOM è¿”å›
            if (state === 'ZOOM' && newState !== 'ZOOM' && activeZoomPhoto) {
                 gsap.to(activeZoomPhoto.scale, {x: 1, y: 1, z: 1, duration: 0.5});
                 activeZoomPhoto = null;
            }

            state = newState;
            const statusEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                statusEl.innerText = "çŠ¶æ€: âœŠ èšåˆ (è·Ÿéšæ‰‹åŠ¿)";
                // ç²’å­èšåˆ
                particles.forEach(p => {
                    const target = p.targets[currentShapeIndex];
                    gsap.to(p.mesh.position, {
                        x: target.x, y: target.y, z: target.z,
                        duration: 1.2 + p.seed * 0.5, ease: "power2.inOut"
                    });
                });
                // ç…§ç‰‡å½’ä½ (æ¼‚æµ®åœ¨ç‰©ä½“å‘¨å›´)
                photoClouds.forEach(p => {
                    gsap.to(p.position, {
                        x: p.homePos.x, y: p.homePos.y, z: p.homePos.z,
                        duration: 1.5, ease: "power2.inOut"
                    });
                    gsap.to(p.scale, {x:1, y:1, z:1, duration: 1});
                });

            } else if (state === 'DISPERSED') {
                statusEl.innerText = "çŠ¶æ€: ğŸ– æ•£å¼€ (ç­‰å¾…åˆ‡æ¢)";
                // ç²’å­æ•£å¼€
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.scatterPos.x, y: p.scatterPos.y, z: p.scatterPos.z,
                        duration: 1.5 + p.seed, ease: "power3.out"
                    });
                });
                // ç…§ç‰‡æ•£å¼€ (æ›´å¤§èŒƒå›´)
                photoClouds.forEach(p => {
                    gsap.to(p.position, {
                        x: p.scatterPos.x, y: p.scatterPos.y, z: p.scatterPos.z,
                        duration: 1.8, ease: "power2.out"
                    });
                    gsap.to(p.scale, {x: 1.5, y: 1.5, z: 1.5, duration: 1});
                });

            } else if (state === 'ZOOM') {
                statusEl.innerText = "çŠ¶æ€: ğŸ‘Œ æŠ“å–è®°å¿†";
                if(photoClouds.length > 0) {
                    // éšæœºæŠ“å–ä¸€å¼ ç…§ç‰‡
                    const targetPhoto = photoClouds[Math.floor(Math.random()*photoClouds.length)];
                    activeZoomPhoto = targetPhoto;

                    // è®¡ç®—é•œå¤´å‰ä½ç½®
                    const vec = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const targetPos = camera.position.clone().add(vec.multiplyScalar(50)); // è·ç¦»é•œå¤´50

                    gsap.to(targetPhoto.position, {
                        x: targetPos.x, y: targetPos.y, z: targetPos.z,
                        duration: 0.8, ease: "back.out(1.2)"
                    });
                    gsap.to(targetPhoto.scale, { x: 8, y: 8, z: 8, duration: 0.8 });
                    // å¼ºåˆ¶é¢å‘ç›¸æœº
                    targetPhoto.lookAt(camera.position);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // æ‰‹åŠ¿è·Ÿéšæ—‹è½¬ç›®æ ‡
            const targetRotY = (handPosition.x - 0.5) * 3; 
            const targetRotX = (handPosition.y - 0.5) * 2;

            // æ— è®ºä»€ä¹ˆçŠ¶æ€ï¼Œä¸»ç»„å’Œç…§ç‰‡ç»„éƒ½è·Ÿéšæ‰‹åŠ¿ç¼“æ…¢æ—‹è½¬
            // ä½¿ç”¨é˜»å°¼è®©åŠ¨ä½œæ›´å¹³æ»‘
            mainGroup.rotation.y += (targetRotY - mainGroup.rotation.y) * 0.05;
            mainGroup.rotation.x += (targetRotX - mainGroup.rotation.x) * 0.05;
            
            // ç…§ç‰‡ç»„è·Ÿéšæ…¢ä¸€ç‚¹ï¼Œåˆ¶é€ å±‚æ¬¡æ„Ÿ
            photoGroup.rotation.y += (targetRotY - photoGroup.rotation.y) * 0.03;
            photoGroup.rotation.x += (targetRotX - photoGroup.rotation.x) * 0.03;

            // ç²’å­è‡ªèº«åŠ¨ç”»
            if(state === 'DISPERSED') {
                particles.forEach(p => {
                    p.mesh.position.y += Math.sin(time + p.seed * 10) * 0.1;
                    p.mesh.position.x += Math.cos(time + p.seed * 10) * 0.1;
                });
            }

            // ç…§ç‰‡å§‹ç»ˆé¢å‘ç›¸æœº (é™¤äº†è¢«æŠ“å–çš„é‚£å¼ )
            photoClouds.forEach(p => {
                if(p !== activeZoomPhoto) {
                     // ä½¿ç”¨ lookAt çš„åå‘æ¥ç¡®ä¿æ­£é¢æœä¸Š
                    p.lookAt(camera.position);
                }
            });

            composer.render();
        }

        // --- å…¨æ–°ç…§ç‰‡ä¸Šä¼ ç³»ç»Ÿ (ç‹¬ç«‹ Mesh) ---
        function handleFileUploadV2(event) {
            const files = event.target.files;
            if(!files.length) return;
            const limit = Math.min(files.length, CONFIG.maxPhotos);
            
            // æ¸…é™¤æ—§ç…§ç‰‡
            photoClouds.forEach(p => photoGroup.remove(p));
            photoClouds = [];

            Array.from(files).slice(0, limit).forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        // é‡è¦ï¼šä½¿ç”¨ SRGB é¢œè‰²ç©ºé—´ï¼Œé¿å…å˜æš—
                        tex.colorSpace = THREE.SRGBColorSpace; 

                        // ä½¿ç”¨çº¯ç™½æè´¨ï¼Œæ— æ»¤é•œ
                        const mat = new THREE.MeshBasicMaterial({
                            map: tex, side: THREE.DoubleSide, transparent: true, color: 0xffffff
                        });
                        const geom = new THREE.PlaneGeometry(10, 10); // è¾ƒå¤§çš„ç…§ç‰‡å°ºå¯¸
                        const photoMesh = new THREE.Mesh(geom, mat);

                        // è®¡ç®—å½’ä½åæ ‡ (å›´ç»•ä¸­å¿ƒæ—‹è½¬åˆ†å¸ƒ)
                        const angle = (i / limit) * Math.PI * 2;
                        const radius = 150; // æ¼‚æµ®åŠå¾„
                        photoMesh.homePos = new THREE.Vector3(
                            Math.cos(angle) * radius,
                            (Math.random()-0.5) * 100,
                            Math.sin(angle) * radius
                        );
                        // è®¡ç®—æ•£å¼€åæ ‡ (æ›´è¿œ)
                        photoMesh.scatterPos = new THREE.Vector3(
                            (Math.random()-0.5) * 800,
                            (Math.random()-0.5) * 600,
                            (Math.random()-0.5) * 800
                        );

                        photoMesh.position.copy(photoMesh.scatterPos);
                        photoGroup.add(photoMesh);
                        photoClouds.push(photoMesh);
                    }
                }
                reader.readAsDataURL(file);
            });
            alert(`å·²åˆ›å»º ${limit} ä¸ªç‹¬ç«‹ç…§ç‰‡å›¾å±‚ã€‚å®ƒä»¬å°†æ¼‚æµ®åœ¨å›¾æ¡ˆå‘¨å›´ã€‚`);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('video-element');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) return;
                const lm = results.multiHandLandmarks[0];
                
                // æ‰‹åŠ¿ä½ç½®æ›´æ–°
                const palmX = (lm[0].x + lm[9].x) / 2;
                const palmY = (lm[0].y + lm[9].y) / 2;
                handPosition.x = 1 - palmX; 
                handPosition.y = palmY;

                // çŠ¶æ€åˆ¤å®š
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                const tips = [8, 12, 16, 20]; const bases = [5, 9, 13, 17];
                let openCount = 0;
                tips.forEach((tip, i) => { if (lm[tip].y < lm[bases[i]].y) openCount++; });

                if (pinchDist < 0.05) {
                    if (state !== 'ZOOM') updateState('ZOOM');
                } else if (openCount >= 3) {
                    if (state !== 'DISPERSED') updateState('DISPERSED');
                } else if (openCount <= 1) {
                    if (state !== 'CONVERGED') updateState('CONVERGED');
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start();
        }
    </script>
</body>
</html>
