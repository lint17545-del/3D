<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D Particle Horse - High Visibility</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 2px solid #FFD700; border-radius: 8px; opacity: 0.8; }
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 24px; color: #FFD700; text-shadow: 0 0 10px #C41E3A; }
        .status { font-size: 18px; color: #00ff00; margin-top: 10px; font-weight: bold; }
        .instruction { font-size: 14px; color: #aaa; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 4px; margin-top: 5px; border-left: 3px solid #0F52BA; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; z-index: 20; font-size: 24px; text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;}
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨æ„å»ºé«˜ç²¾åº¦æ¨¡å‹...<br><span style="font-size:16px">è¯·ç¨å€™ (çº¦5-10ç§’)</span></div>
    
    <div id="ui-layer">
        <h1>ç²’å­çµé©¹ Â· è§†è§‰å¢å¼ºç‰ˆ</h1>
        <div class="status" id="status-text">å½“å‰çŠ¶æ€: â³ ç­‰å¾…æ‰‹åŠ¿</div>
        <div class="instruction">âœŠ æ¡æ‹³ = èšåˆ (çœ‹åˆ°é©¬)</div>
        <div class="instruction">ğŸ– å¼ å¼€ = çˆ†ç‚¸ (æ•£æˆçƒŸèŠ±)</div>
    </div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        const CONFIG = {
            particleCount: 4000, 
            colors: [0x0F52BA, 0xFFD700, 0xC41E3A], 
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb' 
        };

        let scene, camera, renderer, composer, controls;
        let particles = [];
        let wireframeMesh = null; // æ–°å¢ï¼šçº¿æ¡†é©¬
        let state = 'CONVERGED';
        let group;
        let time = 0;

        init();
        animate();
        initMediaPipe();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.002); // ç¨å¾®äº®ä¸€ç‚¹çš„èƒŒæ™¯é›¾

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 30, 160); // ç›¸æœºæ‹‰è¿‘ä¸€ç‚¹

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // æ€§èƒ½ä¼˜åŒ–
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç¯å…‰å¢å¼º
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const pLight = new THREE.PointLight(0xFFD700, 2, 200);
            pLight.position.set(50, 50, 50);
            scene.add(pLight);

            // åå¤„ç†ï¼ˆå‘å…‰ï¼‰
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.autoRotate = true;
            controls.autoRotateSpeed = 2.0;

            loadModel();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function loadModel() {
            const loader = new GLTFLoader();
            loader.load(CONFIG.modelUrl, (gltf) => {
                const model = gltf.scene;
                let mesh = null;
                
                model.traverse((child) => {
                    if (child.isMesh) mesh = child;
                });

                if(mesh) {
                    // 1. åˆ›å»ºçº¿æ¡†è¾…åŠ©æ¨¡å‹ (Ghost)
                    createWireframeHorse(mesh);
                    // 2. åˆ›å»ºç²’å­
                    createParticlesFromMesh(mesh);
                }
                
                document.getElementById('loading').style.display = 'none';
            });
        }

        function createWireframeHorse(originalMesh) {
            // å…‹éš†å‡ ä½•ä½“å¹¶åº”ç”¨ç¼©æ”¾
            const geometry = originalMesh.geometry.clone();
            geometry.scale(0.2, 0.2, 0.2);
            geometry.rotateY(Math.PI); // è°ƒæ•´æœå‘
            geometry.translate(0, -10, 0); // å±…ä¸­

            // åˆ›å»ºçº¿æ¡†æè´¨
            const wireMat = new THREE.MeshBasicMaterial({
                color: 0x1E90FF, // äº®è“è‰²çº¿æ¡
                wireframe: true,
                transparent: true,
                opacity: 0.15, // åŠé€æ˜ï¼Œä¸è¦æŠ¢äº†ç²’å­çš„é£å¤´
                depthWrite: false
            });

            wireframeMesh = new THREE.Mesh(geometry, wireMat);
            group = new THREE.Group();
            group.add(wireframeMesh);
            scene.add(group);
        }

        function createParticlesFromMesh(mesh) {
            const posAttr = mesh.geometry.attributes.position;
            const count = posAttr.count;
            const targetPoints = [];
            const tempVec = new THREE.Vector3();

            // é‡‡æ ·ç‚¹
            for(let i=0; i<count; i++) {
                // æ¯éš”1ä¸ªç‚¹é‡‡ä¸€æ¬¡ï¼Œå¢åŠ å¯†åº¦
                if(i % 2 !== 0) continue; 

                tempVec.fromBufferAttribute(posAttr, i);
                // æ‰‹åŠ¨åº”ç”¨ç¼©æ”¾å’Œåç§»ï¼Œä¸çº¿æ¡†ä¿æŒä¸€è‡´
                tempVec.multiplyScalar(0.2); 
                tempVec.applyAxisAngle(new THREE.Vector3(0,1,0), Math.PI);
                tempVec.y -= 10;

                targetPoints.push(tempVec.clone());
            }

            // æˆªå–æœ€å¤§æ•°é‡
            const finalPoints = targetPoints.slice(0, CONFIG.particleCount);
            
            // ç²’å­æè´¨ - ä½¿ç”¨ BasicMaterial æ›´äº®
            const materials = CONFIG.colors.map(c => new THREE.MeshBasicMaterial({ color: c }));
            const geom = new THREE.BoxGeometry(0.6, 0.6, 0.6); // ç²’å­æ”¹å¤§ï¼

            finalPoints.forEach(pt => {
                const mat = materials[Math.floor(Math.random() * materials.length)];
                const pMesh = new THREE.Mesh(geom, mat);
                
                // åˆå§‹ä½ç½®ï¼ˆæ•£å¼€ï¼‰
                const scatterPos = new THREE.Vector3(
                    (Math.random()-0.5)*150,
                    (Math.random()-0.5)*150,
                    (Math.random()-0.5)*150
                );

                pMesh.position.copy(scatterPos);
                group.add(pMesh);

                particles.push({
                    mesh: pMesh,
                    targetPos: pt,
                    scatterPos: scatterPos,
                    velocity: new THREE.Vector3(0,0,0)
                });
            });
        }

        function updateState(newState) {
            if (state === newState) return;
            state = newState;
            
            const statusEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                statusEl.innerText = "çŠ¶æ€: âœŠ èšåˆ (é©¬)";
                statusEl.style.color = "#FFD700";

                // 1. ç²’å­å½’ä½
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.targetPos.x,
                        y: p.targetPos.y,
                        z: p.targetPos.z,
                        duration: 1.2,
                        ease: "power2.inOut"
                    });
                });
                // 2. çº¿æ¡†æ˜¾ç°
                if(wireframeMesh) {
                    gsap.to(wireframeMesh.material, { opacity: 0.2, duration: 1 });
                    gsap.to(wireframeMesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                }
                controls.autoRotate = true;

            } else if (state === 'DISPERSED') {
                statusEl.innerText = "çŠ¶æ€: ğŸ– æ•£å¼€ (æ˜Ÿäº‘)";
                statusEl.style.color = "#00ffff";

                // 1. ç²’å­ç‚¸å¼€
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.scatterPos.x,
                        y: p.scatterPos.y,
                        z: p.scatterPos.z,
                        duration: 1.5,
                        ease: "power3.out" // æ›´æœ‰çˆ†å‘åŠ›
                    });
                });
                // 2. çº¿æ¡†æ¶ˆå¤±
                if(wireframeMesh) {
                    gsap.to(wireframeMesh.material, { opacity: 0, duration: 0.5 });
                    gsap.to(wireframeMesh.scale, { x: 0.01, y: 0.01, z: 0.01, duration: 0.5 });
                }
                controls.autoRotate = false;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // æ•£å¼€æ—¶ç¨å¾®è½¬åŠ¨
            if (state === 'DISPERSED' && group) {
                group.rotation.y += 0.002;
            }

            controls.update();
            composer.render();
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('video-element');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) return;
                
                const lm = results.multiHandLandmarks[0];
                
                // åˆ¤å®šäº”æŒ‡å¼ å¼€
                const tips = [8, 12, 16, 20];
                const bases = [5, 9, 13, 17];
                let openCount = 0;
                tips.forEach((tip, i) => {
                    if (lm[tip].y < lm[bases[i]].y) openCount++;
                });

                // äº¤äº’é€»è¾‘
                if (openCount >= 3) {
                    updateState('DISPERSED'); // å¼ å¼€æ‰‹ = æ•£å¼€
                } else {
                    updateState('CONVERGED'); // æ¡æ‹³/è‡ªç„¶ = èšåˆ
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start();
        }
    </script>
</body>
</html>
