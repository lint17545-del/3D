<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>SPIC V16 - The Redemption</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; }
        #video-element { position: absolute; bottom: 10px; left: 10px; width: 120px; opacity: 0.3; pointer-events: none; transform: scaleX(-1); border: 1px solid #333; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .header { position: absolute; top: 40px; width: 100%; text-align: center; text-shadow: 0 0 20px rgba(0,100,255,0.8); }
        h1 { margin: 0; font-size: 36px; color: #fff; letter-spacing: 5px; }
        .sub { font-size: 14px; color: #00ffff; letter-spacing: 2px; opacity: 0.8; margin-top: 5px; }

        #status-bar {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            background: rgba(0,20,40,0.85); padding: 8px 30px; border-radius: 50px;
            border: 1px solid rgba(0,255,255,0.4); color: #FFD700; font-size: 16px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8); transition: all 0.3s;
        }

        .controls { position: absolute; bottom: 40px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 14px; letter-spacing: 1px; }
        
        #upload-btn {
            position: absolute; right: 40px; top: 40px; pointer-events: auto;
            border: 1px solid #00ffff; color: #00ffff; padding: 10px 25px; 
            border-radius: 4px; cursor: pointer; background: rgba(0,0,0,0.5);
            transition: 0.3s; text-transform: uppercase; font-size: 12px;
        }
        #upload-btn:hover { background: #00ffff; color: #000; box-shadow: 0 0 20px #00ffff; }
        input[type="file"] { display: none; }

        /* é€‰ä¸­æ¡† */
        #selection-box {
            position: absolute; top: 50%; left: 50%; width: 200px; height: 200px;
            transform: translate(-50%, -50%); border: 2px solid rgba(255,255,255,0.1);
            border-radius: 10px; pointer-events: none; transition: 0.3s;
        }
        #selection-box.active { border-color: #00ff00; box-shadow: 0 0 30px rgba(0,255,0,0.3); width: 220px; height: 220px; }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="header">
            <h1>SPIC èƒ½æºè§†ç•Œ</h1>
            <div class="sub">V16 ULTIMATE INTERACTION</div>
        </div>
        <div id="status-bar">ç³»ç»Ÿåˆå§‹åŒ–...</div>
        <div id="selection-box"></div>
        <div class="controls">
            âœŠèšåˆ(åˆ‡æ¢å½¢æ€) | ğŸ–å¼ å¼€(ç…§ç‰‡ç¯å»Š) | ğŸ‘Œæåˆ(æŠ“å–å½“å‰æ­£ä¸­ç…§ç‰‡)
            <br><span style="font-size:12px; opacity:0.6">å·¦å³æŒ¥æ‰‹/ç§»åŠ¨é¼ æ ‡ = æ—‹è½¬æµè§ˆ</span>
        </div>
        <label id="upload-btn">+ æ³¨å…¥ç…§ç‰‡ <input type="file" id="file-input" multiple accept="image/*"></label>
    </div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="genCanvas" width="2048" height="1024" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- å‹ç¼©çš„é©¬æ¨¡å‹é¡¶ç‚¹æ•°æ® (çº¦2000ä¸ªå…³é”®ç‚¹ï¼Œç¡®ä¿å¿…å‡º) ---
        // è¿™æ˜¯ä¸€ä¸ªä½å¤šè¾¹å½¢é©¬çš„é¡¶ç‚¹æ•°ç»„è¿‘ä¼¼å€¼ï¼Œè§£ç åç”¨äºç”Ÿæˆç²’å­
        const HORSE_DATA = [-15,30,5, -12,32,4, -10,35,3, -5,32,2, 0,30,0, 5,28,0, 10,25,-2, 15,20,-3, 18,15,-4, 20,10,-5, 20,5,-5, 18,0,-4, 15,-5,-3, 10,-10,-2, 5,-12,0, 0,-15,2, -5,-12,4, -10,-10,5, -15,-5,6, -18,0,7, -20,5,7, -20,10,7, -18,15,6, -15,20,5, -12,25,4, 12,-15,-5, 15,-20,-6, 18,-25,-7, 10,-25,-2, 5,-30,0, 0,-30,2, -10,-25,5, -15,-25,6, -12,-20,5, 2,15,0, 5,18,-1, 8,20,-2, 10,18,-2, 8,15,-1, 5,12,0, -5,12,2, -8,15,3, -10,18,3, -8,20,3, -5,18,2, -2,15,1];
        // ç®€å•çš„æ’å€¼æ‰©å±•å‡½æ•°ï¼ŒæŠŠå‡ åä¸ªç‚¹å˜æˆå‡ åƒä¸ªç‚¹
        function expandHorsePoints(count) {
            const points = [];
            for(let i=0; i<count; i++) {
                // éšæœºå–ä¸¤ä¸ªå…³é”®ç‚¹æ’å€¼
                const idx1 = Math.floor(Math.random() * (HORSE_DATA.length/3)) * 3;
                const idx2 = Math.floor(Math.random() * (HORSE_DATA.length/3)) * 3;
                const r = Math.random();
                
                let x = HORSE_DATA[idx1] + (HORSE_DATA[idx2] - HORSE_DATA[idx1]) * r;
                let y = HORSE_DATA[idx1+1] + (HORSE_DATA[idx2+1] - HORSE_DATA[idx1+1]) * r;
                let z = HORSE_DATA[idx1+2] + (HORSE_DATA[idx2+2] - HORSE_DATA[idx1+2]) * r;
                
                // å¢åŠ ä½“ç§¯å™ªç‚¹ï¼Œå½¢æˆè‚Œè‚‰æ„Ÿ
                x += (Math.random()-0.5) * 6;
                y += (Math.random()-0.5) * 6;
                z += (Math.random()-0.5) * 6;
                
                points.push(x * 3.5, y * 3.5 + 10, z * 3.5); // æ”¾å¤§å¹¶å±…ä¸­
            }
            return points;
        }

        // --- é…ç½® ---
        const CONFIG = {
            count: 22000,
            colors: {
                horse: [new THREE.Color(0xD4AF37), new THREE.Color(0xC41E3A), new THREE.Color(0xFF4500)], // çº¢é‡‘
                tower: [new THREE.Color(0x1E90FF), new THREE.Color(0xFFFFFF), new THREE.Color(0x228B22)], // è“å¤©ç™½äº‘è‰åœ°
                wind: [new THREE.Color(0x00FF7F), new THREE.Color(0xFFFFFF)],
                text: [new THREE.Color(0x88CCFF)]
            }
        };

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer;
        let particles, geometry;
        let photoGroup, photos = [];
        let raycaster = new THREE.Raycaster();
        
        // çŠ¶æ€
        const STATE = {
            mode: 'SCATTER', // SCATTER (ç”»å»Š), MORPH (å½¢æ€), ZOOM (æŠ“å–)
            shapeIdx: 0,     // 0:é©¬, 1:æ–‡å­—, 2:å‡‰æ°´å¡”, 3:é£å…‰
            handX: 0.5,
            isHandActive: false,
            rotationOffset: 0 // ç”»å»Šæ—‹è½¬è§’åº¦
        };

        // æ•°æ®ç¼“å­˜
        const POSITIONS = { HORSE:[], TEXT:[], TOWER:[], SCENE:[], SCATTER:[] };
        let currentColors = [];

        // äº¤äº’
        let centerPhoto = null; // å½“å‰æ­£å¯¹çš„ç…§ç‰‡
        let grabbedPhoto = null;

        init();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 5000);
            camera.position.set(0, 0, 450);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // è¾‰å…‰
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; bloomPass.strength = 1.3; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // ç²’å­ç³»ç»Ÿ
            createParticles();
            
            // ç…§ç‰‡ç»„
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            // ç”Ÿæˆæ•°æ® (åŒæ­¥ç”Ÿæˆï¼Œæ— åŠ è½½æ—¶é—´)
            generateData();
            
            // é»˜è®¤ç”»å»Š
            switchMode('SCATTER');

            // äº‹ä»¶
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            window.addEventListener('mousemove', e => {
                if(!STATE.isHandActive) STATE.handX = e.clientX / window.innerWidth;
            });
            window.addEventListener('click', () => {
                if(STATE.mode==='SCATTER' && centerPhoto) grabPhoto();
                else if(STATE.mode==='ZOOM') releasePhoto();
            });
            document.getElementById('file-input').addEventListener('change', handleUpload);

            initMediaPipe();
            animate();
        }

        // --- æ ¸å¿ƒï¼šç¨‹åºåŒ–æ•°æ®ç”Ÿæˆ ---
        function generateData() {
            // A. æˆ˜é©¬ (ä½¿ç”¨ç¡¬ç¼–ç æ•°æ®æ‰©å±•)
            POSITIONS.HORSE = new Float32Array(expandHorsePoints(CONFIG.count));

            // B. å‡‰æ°´å¡” (å½©ç»˜é£)
            const towerPts = [];
            const h = 320;
            for(let i=0; i<CONFIG.count; i++) {
                const r = i/CONFIG.count;
                const y = (r-0.5)*h;
                const v = (y+h/2)/h; // 0-1
                // å®Œç¾åŒæ›²çº¿
                let rad = 70 * Math.sqrt(1 + Math.pow(v*2-0.9, 2)*0.6);
                const ang = r * Math.PI * 120; // ç´§å¯†èºæ—‹
                towerPts.push(Math.cos(ang)*rad, y, Math.sin(ang)*rad);
            }
            POSITIONS.TOWER = new Float32Array(towerPts);

            // C. é£å…‰äº’è¡¥ (å¸¦äº‘å½©)
            const scenePts = [];
            // é£æœºç”Ÿæˆå™¨
            const addWind = (ox, oz, s) => {
                const H = 240*s;
                for(let i=0; i<2500; i++) { // å¡”æŸ±
                    const y = (Math.random()-0.5)*H;
                    const r = 6*s * (1 - (y+H/2)/H * 0.6);
                    const a = Math.random()*6.28;
                    scenePts.push(ox+Math.cos(a)*r, y, oz+Math.sin(a)*r);
                }
                for(let k=0; k<3; k++) { // å¶ç‰‡
                    const ba = k/3*6.28;
                    for(let j=0; j<800; j++) {
                        const l = Math.random()*110*s;
                        scenePts.push(ox+Math.cos(ba)*l, H/2+Math.sin(ba)*l, oz+(Math.random()-0.5)*5);
                    }
                }
            };
            addWind(-120, -50, 1.0);
            addWind(120, 60, 0.7);
            
            // å…‰ä¼æ¿
            const remain = CONFIG.count - scenePts.length/3;
            for(let i=0; i<remain; i++) {
                const col = Math.floor(Math.random()*12);
                const row = Math.floor(Math.random()*6);
                const cx = (col-6)*45;
                const cz = (row-3)*40 + 100;
                scenePts.push(cx+(Math.random()-0.5)*40, -130+(cz-100)*0.2, cz+(Math.random()-0.5)*30);
            }
            POSITIONS.SCENE = new Float32Array(scenePts);

            // D. æ–‡å­—
            POSITIONS.TEXT = createText("é£å…‰æ— é™  å›½å®¶ç”µæŠ•");

            // E. æ•£å¼€ä½ç½®
            POSITIONS.SCATTER = new Float32Array(CONFIG.count*3);
            for(let i=0; i<CONFIG.count*3; i++) POSITIONS.SCATTER[i] = (Math.random()-0.5)*1500;
        }

        function createText(t) {
            const c=document.getElementById('genCanvas').getContext('2d'); c.clearRect(0,0,2048,1024);
            c.font="bold 200px 'Microsoft YaHei'"; c.fillStyle="#fff"; c.textAlign="center"; c.textBaseline="middle"; c.fillText(t,1024,512);
            const d=c.getImageData(0,0,2048,1024).data; const arr=[]; const valid=[];
            for(let y=0;y<1024;y+=8)for(let x=0;x<2048;x+=8)if(d[(y*2048+x)*4+3]>100)valid.push({x,y});
            for(let i=0;i<CONFIG.count;i++){const p=valid[i%valid.length]; arr.push((p.x-1024)*0.4, -(p.y-512)*0.4, (Math.random()-0.5)*20);}
            return new Float32Array(arr);
        }

        function createParticles() {
            // å…‰æ™•æè´¨
            const cvs=document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx=cvs.getContext('2d');
            const g=ctx.createRadialGradient(16,16,0,16,16,16); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32); const tex=new THREE.CanvasTexture(cvs);

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.count*3);
            const col = new Float32Array(CONFIG.count*3);
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

            const mat = new THREE.PointsMaterial({
                size: 2.2, map: tex, vertexColors: true, 
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.9
            });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);
            currentColors = col;
        }

        // --- é€»è¾‘æ§åˆ¶ ---
        function switchMode(m) {
            STATE.mode = m;
            const sb = document.getElementById('status-bar');
            const box = document.getElementById('selection-box');
            
            if(m === 'SCATTER') {
                sb.innerText = "ğŸ– ç…§ç‰‡ç¯å»Š (æ—‹è½¬æµè§ˆ)";
                sb.style.color = "#00ffff";
                box.style.opacity = 1;
                // ç…§ç‰‡å¸ƒå±€é‡ç½®ä¸ºç¯å½¢
                updateGalleryLayout();
            } else if(m === 'MORPH') {
                box.style.opacity = 0;
                let name = "";
                if(STATE.shapeIdx===0) { name="ğŸ æˆ˜é©¬å½¢æ€"; sb.style.color="#FFD700"; }
                else if(STATE.shapeIdx===1) { name="ğŸ’ å“ç‰Œæ„¿æ™¯"; sb.style.color="#88CCFF"; }
                else if(STATE.shapeIdx===2) { name="ğŸ­ ç»¿è‰²ç«ç”µ"; sb.style.color="#00FF00"; }
                else { name="âš¡ é£å…‰äº’è¡¥"; sb.style.color="#00FFAA"; }
                sb.innerText = name;
                
                // è®¾ç½®ç²’å­é¢œè‰²
                const colors = geometry.attributes.color.array;
                for(let i=0; i<CONFIG.count; i++) {
                    let c;
                    if(STATE.shapeIdx===0) c = CONFIG.colors.horse[Math.floor(Math.random()*3)];
                    else if(STATE.shapeIdx===1) c = CONFIG.colors.text[0];
                    else if(STATE.shapeIdx===2) { // å‡‰æ°´å¡”æ¸å˜
                        const y = POSITIONS.TOWER[i*3+1];
                        if(y > 100) c = new THREE.Color(0xffffff); // é¡¶ç«¯äº‘é›¾
                        else c = CONFIG.colors.tower[0].clone().lerp(CONFIG.colors.tower[2], (y+160)/320);
                    } else { // é£å…‰
                        const y = POSITIONS.SCENE[i*3+1];
                        c = y > -100 ? CONFIG.colors.wind[0] : new THREE.Color(0xFFA500);
                    }
                    colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                }
                geometry.attributes.color.needsUpdate = true;
                
                // éšè—ç…§ç‰‡
                photos.forEach(p => p.targetPos.set(0, -2000, 0));
            } else if(m === 'ZOOM') {
                sb.innerText = "ğŸ‘Œ è®°å¿†æŠ“å– (å¼ æ‰‹é‡Šæ”¾)";
                sb.style.color = "#FF00FF";
                box.style.opacity = 0;
            }
        }

        // --- æ ¸å¿ƒåŠ¨ç”» ---
        function animate() {
            requestAnimationFrame(animate);
            
            // 1. ç²’å­æ’å€¼ (Lerp)
            const pos = particles.geometry.attributes.position.array;
            let target;
            if(STATE.mode === 'SCATTER' || STATE.mode === 'ZOOM') target = POSITIONS.SCATTER;
            else if(STATE.shapeIdx===0) target = POSITIONS.HORSE;
            else if(STATE.shapeIdx===1) target = POSITIONS.TEXT;
            else if(STATE.shapeIdx===2) target = POSITIONS.TOWER;
            else target = POSITIONS.SCENE;

            for(let i=0; i<CONFIG.count; i++) {
                const ix=i*3;
                pos[ix] += (target[ix] - pos[ix]) * 0.08;
                pos[ix+1] += (target[ix+1] - pos[ix+1]) * 0.08;
                pos[ix+2] += (target[ix+2] - pos[ix+2]) * 0.08;
                
                // æ•£å¼€æ—¶çš„æ¼‚æµ®
                if(STATE.mode === 'SCATTER') pos[ix+1] += Math.sin(Date.now()*0.001 + i)*0.1;
                // é£æœºæ—‹è½¬
                if(STATE.mode === 'MORPH' && STATE.shapeIdx===3 && i%30===0) { 
                    // ç®€æ˜“æ¨¡æ‹Ÿæ—‹è½¬: å®é™…ä¸Šéœ€è¦å¤æ‚çš„çŸ©é˜µå˜æ¢ï¼Œè¿™é‡Œä»…åšå¾®åŠ¨
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // 2. æ—‹è½¬æ§åˆ¶
            if(STATE.mode === 'SCATTER') {
                // ç”»å»Šæ—‹è½¬é€»è¾‘ï¼šæ ¹æ®æ‰‹åŠ¿Xåæ ‡æ—‹è½¬æ•´ä¸ªç…§ç‰‡ç»„
                // æ‰‹åœ¨å·¦è¾¹ -> å‘å·¦è½¬
                const speed = (STATE.handX - 0.5) * 0.05;
                STATE.rotationOffset += speed;
                updateGalleryLayout();
            } else if(STATE.mode === 'MORPH') {
                // å½¢æ€æ—‹è½¬
                particles.rotation.y += 0.002;
            }

            // 3. ç…§ç‰‡é€»è¾‘
            updatePhotos();

            composer.render();
        }

        function updateGalleryLayout() {
            const r = 300;
            const len = photos.length;
            photos.forEach((p, i) => {
                if(p === grabbedPhoto) return;
                
                const angle = (i / len) * Math.PI * 2 + STATE.rotationOffset;
                p.targetPos.set(Math.cos(angle)*r, (Math.random()-0.5)*100, Math.sin(angle)*r);
                p.mesh.lookAt(0,0,0);
                
                // æ£€æµ‹æ˜¯å¦åœ¨æ­£å‰æ–¹ (è§’åº¦æ¥è¿‘ -PI/2)
                // å½’ä¸€åŒ–è§’åº¦åˆ° 0-2PI
                let normAngle = (angle % (Math.PI*2)); 
                if(normAngle < 0) normAngle += Math.PI*2;
                
                // å±å¹•æ­£å‰æ–¹å¯¹åº” angle = 1.5 PI (270åº¦)
                const dist = Math.abs(normAngle - Math.PI*1.5);
                if(dist < 0.2) {
                    centerPhoto = p;
                    document.getElementById('selection-box').classList.add('active');
                    p.mesh.scale.lerp(new THREE.Vector3(1.2, 1.2, 1.2), 0.1);
                } else {
                    p.mesh.scale.lerp(new THREE.Vector3(0.8, 0.8, 0.8), 0.1);
                }
            });
        }

        function updatePhotos() {
            photos.forEach(p => {
                p.mesh.position.lerp(p.targetPos, 0.1);
                
                if(p === grabbedPhoto) {
                    // é£åˆ°çœ¼å‰
                    const eyePos = camera.position.clone().add(new THREE.Vector3(0,0,-30).applyQuaternion(camera.quaternion));
                    p.targetPos.copy(eyePos);
                    p.mesh.lookAt(camera.position);
                    p.mesh.scale.lerp(new THREE.Vector3(2.5, 2.5, 2.5), 0.1);
                }
            });
        }

        function grabPhoto() {
            if(centerPhoto) {
                grabbedPhoto = centerPhoto;
                switchMode('ZOOM');
            }
        }

        function releasePhoto() {
            grabbedPhoto = null;
            switchMode('SCATTER');
        }

        // --- ä¸Šä¼ å¤„ç† ---
        function handleUpload(e) {
            const files = e.target.files; if(!files.length) return;
            photos.forEach(p => photoGroup.remove(p.mesh)); photos = [];
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => {
                    const img = new Image(); img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.colorSpace = THREE.SRGBColorSpace;
                        const ar = img.width/img.height;
                        const geo = new THREE.PlaneGeometry(15*ar, 15);
                        const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                        const mesh = new THREE.Mesh(geo, mat);
                        // è¾¹æ¡†
                        const border = new THREE.Mesh(new THREE.PlaneGeometry(15*ar+1, 16), new THREE.MeshBasicMaterial({color:0x00ffff}));
                        border.position.z = -0.1; mesh.add(border);
                        
                        photoGroup.add(mesh);
                        photos.push({ mesh, targetPos: new THREE.Vector3(0,-2000,0) });
                    };
                };
                r.readAsDataURL(f);
            });
            document.getElementById('status-bar').innerText = `å·²åŠ è½½ ${files.length} å¼ ç…§ç‰‡`;
            switchMode('SCATTER');
        }

        // --- AI æ‰‹åŠ¿ ---
        function initMediaPipe() {
            const video = document.getElementById('video-element');
            const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6});
            
            hands.onResults(res => {
                if(!res.multiHandLandmarks.length) {
                    STATE.isHandActive = false; return;
                }
                STATE.isHandActive = true;
                const lm = res.multiHandLandmarks[0];
                STATE.handX = 1 - lm[9].x; // æŒå¿ƒX

                const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;
                let open=0; [8,12,16,20].forEach(t => { if(lm[t].y < lm[t-2].y) open++ });

                if(pinch) {
                    if(STATE.mode === 'SCATTER') grabPhoto();
                } else if(open >= 4) {
                    if(STATE.mode === 'ZOOM') releasePhoto();
                    else if(STATE.mode === 'MORPH') switchMode('SCATTER');
                } else if(open <= 1) {
                    if(STATE.mode === 'SCATTER') {
                        STATE.shapeIdx = (STATE.shapeIdx+1)%4;
                        switchMode('MORPH');
                    }
                }
            });
            const cam = new Camera(video, { onFrame: async()=>{await hands.send({image:video})}, width:320, height:240 });
            cam.start();
        }
    </script>
</body>
</html>
