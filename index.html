<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>SPIC Interactive V12 - Zero Latency</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010103; font-family: 'Microsoft YaHei', sans-serif; }
        
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 2px solid rgba(0, 200, 255, 0.4); border-radius: 8px; opacity: 0.5; }
        
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 26px; color: #FFD700; letter-spacing: 2px; text-shadow: 0 0 20px rgba(0, 100, 255, 0.6); font-weight: bold; }
        .cycle-info { font-size: 22px; margin-top: 10px; color: #fff; font-weight: bold; transition: all 0.5s; text-shadow: 0 0 10px currentColor; }
        .status { font-size: 16px; color: rgba(255,255,255,0.8); margin-top: 8px; background: rgba(0,0,0,0.6); padding: 4px 12px; border-radius: 20px; display: inline-block;}
        
        #upload-container { pointer-events: auto; display: inline-block; margin-top: 25px; }
        input[type="file"] { display: none; }
        .btn { background: linear-gradient(135deg, #FFD700, #FF4500); border: none; padding: 12px 25px; color: #fff; font-size: 14px; font-weight: bold; cursor: pointer; border-radius: 30px; box-shadow: 0 0 20px rgba(255, 69, 0, 0.4); transition: transform 0.2s; }
        .btn:hover { transform: scale(1.05); }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ffff; z-index: 20; font-size: 18px; text-align: center; letter-spacing: 1px; }
        #hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 14px; pointer-events: none; letter-spacing: 1px; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loading">æ­£åœ¨ç”Ÿæˆå·¥ä¸šåœºæ™¯...<br>(æ— éœ€ä¸‹è½½ï¼Œå³åˆ»å¯åŠ¨)</div>
    
    <div id="ui-layer">
        <h1>SPIC èƒ½æºè§†ç•Œ V12</h1>
        <div class="cycle-info" id="shape-name" style="color:#FFD700">ğŸ æˆ˜é©¬å½¢æ€</div>
        <div class="status" id="status-text">ç­‰å¾…æ‰‹åŠ¿...</div>
        <div id="upload-container">
            <label class="btn">+ æ³¨å…¥è®°å¿†ç…§ç‰‡ <input type="file" id="file-input" multiple accept="image/*"></label>
        </div>
    </div>
    <div id="hint">âœŠèšåˆ | ğŸ–æ•£å¼€(åˆ‡æ¢) | ğŸ‘Œæåˆ(æŠ“å–ç…§ç‰‡è‡³çœ¼å‰)</div>
    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="genCanvas" width="2048" height="1024" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        const CONFIG = {
            particleCount: 16000,
            maxPhotos: 30,
            horseUrl: 'https://threejs.org/examples/models/gltf/Horse.glb', // ä»…é©¬ä½¿ç”¨å¤–é“¾
            colors: {
                horse: [0xD4AF37, 0xC41E3A, 0xFFD700, 0x8B0000],
                text: [0x88CCFF],
                towerTop: new THREE.Color(0x87CEEB), // å¤©è“
                towerBottom: new THREE.Color(0x228B22), // è‰ç»¿
                wind: 0x00FF7F, solar: 0xFFA500
            }
        };

        let scene, camera, renderer, composer, mainGroup, photoGroup;
        let particles = []; let photoClouds = [];
        let state = 'CONVERGED'; let time = 0;
        let handPosition = { x: 0.5, y: 0.5 };
        
        let activeZoomPhoto = null;
        let isZoomLocked = false;
        let currentShapeIndex = 0;
        const SHAPES = { HORSE:[], TEXT:[], TOWER:[], WIND_SOLAR:[] };
        let pendingShapeChange = false;

        const sphereGeom = new THREE.SphereGeometry(0.6, 8, 8);
        const boxGeom = new THREE.BoxGeometry(0.8, 0.8, 0.8);

        init(); animate(); initMediaPipe();

        async function init() {
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x010103, 0.0008);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 5000);
            camera.position.set(0, 0, 450);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); dirLight.position.set(100, 100, 100); scene.add(dirLight);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.8);
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

            mainGroup = new THREE.Group(); photoGroup = new THREE.Group();
            scene.add(mainGroup); scene.add(photoGroup);

            // ç”Ÿæˆæ•°æ® (å¹¶è¡Œå¤„ç†)
            await generateAllShapes();
            
            createParticles();
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            document.getElementById('loading').style.display = 'none';
        }

        async function generateAllShapes() {
            // A. é©¬ (å°è¯•åŠ è½½ï¼Œå¤±è´¥åˆ™ä½¿ç”¨ç¨‹åºåŒ–çƒä½“ä½œä¸ºå…œåº•)
            try {
                await new Promise((resolve, reject) => {
                    const loader = new GLTFLoader();
                    // è®¾ç½®5ç§’è¶…æ—¶
                    const timer = setTimeout(() => reject("Timeout"), 5000);
                    loader.load(CONFIG.horseUrl, (gltf) => {
                        clearTimeout(timer);
                        SHAPES.HORSE = samplePoints(getPointsFromMesh(gltf.scene.children[0], 1.4), CONFIG.particleCount);
                        resolve();
                    }, undefined, (e) => reject(e));
                });
            } catch (e) {
                console.warn("é©¬æ¨¡å‹åŠ è½½å¤±è´¥/è¶…æ—¶ï¼Œåˆ‡æ¢è‡³å¤‡ç”¨å½¢æ€");
                SHAPES.HORSE = generateSphereFallback(CONFIG.particleCount); // å…œåº•
            }

            // B. æ–‡å­—
            SHAPES.TEXT = generateTextPoints("é£å…‰æ— é™  å›½å®¶ç”µæŠ•");

            // C. å‡‰æ°´å¡” (çº¯ä»£ç ç”Ÿæˆï¼Œ0ç§’åŠ è½½)
            SHAPES.TOWER = generateProceduralTower(CONFIG.particleCount);

            // D. é£å…‰äº’è¡¥ (çº¯ä»£ç ç”Ÿæˆï¼Œ0ç§’åŠ è½½)
            SHAPES.WIND_SOLAR = generateProceduralWindSolar(CONFIG.particleCount);
        }

        // --- ç¨‹åºåŒ–ç”Ÿæˆé€»è¾‘ (æ— éœ€ä¸‹è½½æ¨¡å‹) ---

        // 1. å‡‰æ°´å¡” (åŒæ›²çº¿æ—‹è½¬ä½“)
        function generateProceduralTower(count) {
            const points = [];
            // ä½¿ç”¨ LatheGeometry é€»è¾‘ç”Ÿæˆç‚¹
            // y^2 / a^2 - x^2 / b^2 = 1 (åŒæ›²çº¿)
            
            const height = 300;
            const segments = 100; // å‚ç›´åˆ†æ®µ
            
            for(let i=0; i<count; i++) {
                // éšæœºé«˜åº¦ -150 åˆ° 150
                const y = (Math.random() - 0.5) * height;
                // å½’ä¸€åŒ–é«˜åº¦ -1 åˆ° 1
                const v = y / (height/2);
                
                // å‡‰æ°´å¡”åŠå¾„å…¬å¼ï¼šä¸­é—´ç»†ï¼Œä¸¤å¤´ç²—
                // r = r_mid * sqrt(1 + y^2/a^2)
                const throatRadius = 60; // å–‰éƒ¨åŠå¾„
                const curvature = 0.5;   // å¼¯æ›²ç¨‹åº¦
                
                // ç¨å¾®è°ƒæ•´å½¢çŠ¶ï¼Œåº•éƒ¨æ¯”é¡¶éƒ¨ç²—
                let r = throatRadius * Math.sqrt(1 + Math.pow(v, 2) * curvature);
                if (v < 0) r *= (1 + Math.abs(v) * 0.4); // åº•éƒ¨åŠ ç²—
                
                // éšæœºè§’åº¦
                const theta = Math.random() * Math.PI * 2;
                
                const x = r * Math.cos(theta);
                const z = r * Math.sin(theta);
                
                const p = new THREE.Vector3(x, y, z);
                
                // æ ‡è®°é«˜åº¦ç”¨äºä¸Šè‰² (0åº•éƒ¨ -> 1é¡¶éƒ¨)
                p.heightRatio = (y + height/2) / height; 
                points.push(p);
            }
            return samplePoints(points, count);
        }

        // 2. é£å…‰äº’è¡¥ (ç»„åˆå‡ ä½•ä½“)
        function generateProceduralWindSolar(count) {
            const points = [];
            
            // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆåœ†æŸ±ä½“ç‚¹äº‘
            const addCylinder = (x, z, r, h, isWind) => {
                const density = 200; // ç‚¹çš„å¯†åº¦
                for(let i=0; i<h*2; i++) {
                    const py = (Math.random() - 0.5) * h; // -h/2 åˆ° h/2
                    const ang = Math.random() * Math.PI * 2;
                    // é£æœºå¡”ç­’æ˜¯é”¥å½¢çš„
                    const currentR = r * (1 - (py + h/2)/h * 0.4); 
                    points.push({
                        pos: new THREE.Vector3(x + Math.cos(ang)*currentR, py, z + Math.sin(ang)*currentR),
                        isWind: isWind
                    });
                }
            };

            // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆå¶ç‰‡
            const addBlades = (x, y, z, size) => {
                for(let k=0; k<3; k++) { // 3ä¸ªå¶ç‰‡
                    const angleBase = (k/3) * Math.PI * 2;
                    for(let i=0; i<300; i++) {
                        const len = Math.random() * size;
                        // å¶ç‰‡ç¨æœ‰æ‰­æ›²
                        const bladeX = Math.cos(angleBase) * len;
                        const bladeY = Math.sin(angleBase) * len;
                        points.push({
                            pos: new THREE.Vector3(x + bladeX, y + bladeY, z + (Math.random()-0.5)*5),
                            isWind: true
                        });
                    }
                }
            };

            // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆå…‰ä¼æ¿ (çŸ©å½¢)
            const addPanel = (x, y, z, w, h) => {
                for(let i=0; i<50; i++) {
                    const px = (Math.random()-0.5) * w;
                    const pz = (Math.random()-0.5) * h;
                    // å€¾æ–œ 30åº¦
                    const py = pz * Math.sin(Math.PI/6);
                    const pz_rot = pz * Math.cos(Math.PI/6);
                    points.push({
                        pos: new THREE.Vector3(x + px, y + py, z + pz_rot),
                        isSolar: true
                    });
                }
            };

            // æ„å»ºåœºæ™¯
            // å·¦ä¾§å¤§é£æœº
            addCylinder(-120, -50, 8, 200, true);
            addBlades(-120, 100, -45, 110);
            
            // å³ä¾§å°é£æœº
            addCylinder(100, 80, 5, 150, true);
            addBlades(100, 75, 85, 80);

            // åœ°é¢å…‰ä¼æ¿é˜µåˆ—
            for(let row=0; row<4; row++) {
                for(let col=0; col<6; col++) {
                    const cx = (col - 3) * 50;
                    const cz = (row - 2) * 40 + 50;
                    addPanel(cx, -120, cz, 40, 25);
                }
            }

            // è½¬æ¢ä¸º Vector3 å¹¶é‡‡æ ·
            const vectorPoints = points.map(p => {
                const vec = p.pos;
                vec.isWind = p.isWind;
                vec.isSolar = p.isSolar;
                return vec;
            });

            return samplePoints(vectorPoints, count);
        }

        function generateSphereFallback(count) {
            const points = [];
            const r = 100;
            for(let i=0; i<count; i++) {
                const vec = new THREE.Vector3(
                    (Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2
                ).normalize().multiplyScalar(r);
                points.push(vec);
            }
            return points;
        }

        function generateTextPoints(text) {
            const ctx = document.getElementById('genCanvas').getContext('2d');
            ctx.clearRect(0,0,2048,1024);
            ctx.font = "bold 200px 'Microsoft YaHei'"; ctx.fillStyle = "white";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, 1024, 512);
            const data = ctx.getImageData(0,0,2048,1024).data; const pts=[];
            for(let y=0;y<1024;y+=6) for(let x=0;x<2048;x+=6) if(data[(y*2048+x)*4+3]>128) pts.push(new THREE.Vector3((x-1024)*0.3,-(y-512)*0.3,(Math.random()-0.5)*15));
            return samplePoints(pts, CONFIG.particleCount);
        }

        function getPointsFromMesh(mesh, scale) {
            const positions = []; const posAttr = mesh.geometry.attributes.position; const v = new THREE.Vector3();
            for(let i=0; i<posAttr.count; i++) positions.push(v.fromBufferAttribute(posAttr, i).multiplyScalar(scale).clone());
            return positions;
        }
        function samplePoints(s,c) { 
            if(!s.length)return[]; const b=new THREE.Box3().setFromPoints(s); const ct=b.getCenter(new THREE.Vector3()); 
            s.forEach(p=>p.sub(ct)); const r=[]; for(let i=0;i<c;i++){ 
                const p=s[i%s.length].clone(); 
                if(s[i%s.length].heightRatio !== undefined) p.heightRatio = s[i%s.length].heightRatio;
                if(s[i%s.length].isWind) p.isWind = true;
                if(s[i%s.length].isSolar) p.isSolar = true;
                r.push(p);
            } return r.sort(()=>Math.random()-0.5); 
        }

        // --- 2. ç²’å­æ¸²æŸ“ ---
        function createParticles() {
            for(let i=0; i<CONFIG.particleCount; i++) {
                const mesh = new THREE.Mesh(sphereGeom, new THREE.MeshStandardMaterial({
                    color:0xffffff, roughness:0.4, metalness:0.5
                }));
                const scatterPos = new THREE.Vector3((Math.random()-0.5)*900, (Math.random()-0.5)*700, (Math.random()-0.5)*900);
                mesh.position.copy(scatterPos); mainGroup.add(mesh);
                particles.push({
                    mesh, targets: [SHAPES.HORSE[i], SHAPES.TEXT[i], SHAPES.TOWER[i], SHAPES.WIND_SOLAR[i]],
                    scatterPos, baseColor: new THREE.Color(), seed: Math.random()
                });
            }
            updateVisuals(0); updateState('DISPERSED');
        }

        function updateVisuals(idx) {
            const ui=document.getElementById('shape-name');
            let colors, geom=sphereGeom, op=1, trans=false, emissiveInt=0.3;
            if(idx===0) { ui.innerText="ğŸ æˆ˜é©¬å½¢æ€ (çº¢é‡‘)"; ui.style.color="#FFD700"; colors=CONFIG.colors.horse; emissiveInt=0.8; }
            else if(idx===1) { ui.innerText="ğŸ’ æ–‡å­—å½¢æ€ (æ˜Ÿå…‰è“)"; ui.style.color="#88CCFF"; colors=CONFIG.colors.text; geom=boxGeom; op=0.8; trans=true; }
            else if(idx===2) { ui.innerText="ğŸ­ å‡‰æ°´å¡” (å½©ç»˜æ¸å˜)"; ui.style.color="#00BFFF"; }
            else { ui.innerText="âš¡ é£å…‰äº’è¡¥ (ç»¿è‰²èƒ½æº)"; ui.style.color="#00FF00"; geom=boxGeom; }

            particles.forEach((p,i) => {
                let hex;
                if(idx===2) { // å‡‰æ°´å¡”æ¸å˜
                    const ratio = p.targets[2].heightRatio !== undefined ? p.targets[2].heightRatio : 0.5;
                    p.baseColor.lerpColors(CONFIG.colors.towerBottom, CONFIG.colors.towerTop, ratio);
                } else if(idx===3) { // é£å…‰
                    hex = p.targets[3].isSolar ? CONFIG.colors.solar : CONFIG.colors.wind;
                    p.baseColor.setHex(hex);
                } else {
                    hex = colors[Math.floor(Math.random()*colors.length)];
                    p.baseColor.setHex(hex);
                }

                p.mesh.geometry = geom; p.mesh.material.transparent = trans;
                gsap.to(p.mesh.material.color, {r:p.baseColor.r,g:p.baseColor.g,b:p.baseColor.b, duration:0.8});
                gsap.to(p.mesh.material, {opacity:op, duration:0.8});
                gsap.to(p.mesh.material.emissive, {r:p.baseColor.r,g:p.baseColor.g,b:p.baseColor.b, intensity:emissiveInt, duration:0.8});
            });
        }

        // --- 3. äº¤äº’ä¸çŠ¶æ€ (å«3Dç…§ç‰‡æŠ“å–) ---
        function updateState(newState) {
            if(state === newState) return;
            if(isZoomLocked && newState !== 'DISPERSED') return;

            if(state==='DISPERSED' && newState==='CONVERGED' && pendingShapeChange) {
                currentShapeIndex=(currentShapeIndex+1)%4; updateVisuals(currentShapeIndex); pendingShapeChange=false;
            } else if(newState==='DISPERSED') pendingShapeChange=true;

            // é€€å‡º ZOOM
            if(state === 'ZOOM' && newState !== 'ZOOM' && activeZoomPhoto) {
                isZoomLocked = false;
                gsap.to(activeZoomPhoto.position, {...activeZoomPhoto.homePos, duration:1.5, ease:"power2.inOut"});
                gsap.to(activeZoomPhoto.scale, {x:1, y:1, z:1, duration:1.5});
                activeZoomPhoto = null;
            }

            state = newState;
            const stEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                stEl.innerText = "çŠ¶æ€: âœŠ èšåˆ (æ—‹è½¬)";
                particles.forEach(p => gsap.to(p.mesh.position, {...p.targets[currentShapeIndex], duration: 1.5+p.seed, ease:"power2.inOut"}));
                photoClouds.forEach(p => { if(p!==activeZoomPhoto) {gsap.to(p.position, {...p.homePos, duration:1.8}); gsap.to(p.scale, {x:1,y:1,z:1, duration:1});} });
            } else if (state === 'DISPERSED') {
                stEl.innerText = "çŠ¶æ€: ğŸ– æ•£å¼€ (åˆ‡æ¢/é‡Šæ”¾)";
                particles.forEach(p => gsap.to(p.mesh.position, {...p.scatterPos, duration: 2, ease:"power3.out"}));
                photoClouds.forEach(p => { if(p!==activeZoomPhoto) {gsap.to(p.position, {...p.scatterPos, duration:2.2}); gsap.to(p.scale, {x:1.5,y:1.5,z:1.5, duration:1});} });
            } else if (state === 'ZOOM') {
                if(photoClouds.length > 0 && !isZoomLocked) {
                    isZoomLocked = true;
                    stEl.innerText = "çŠ¶æ€: ğŸ‘Œ å·²æŠ“å– (å¼ æ‰‹é‡Šæ”¾)";
                    activeZoomPhoto = photoClouds[Math.floor(Math.random()*photoClouds.length)];
                    
                    // 3D æŠ“å–æ ¸å¿ƒï¼šé£åˆ°ç›¸æœºæ­£å‰æ–¹
                    const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const targetPos = camera.position.clone().add(camDir.multiplyScalar(80)); // è·ç¦»80
                    
                    gsap.to(activeZoomPhoto.position, { x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1.2, ease: "power2.out" });
                    gsap.to(activeZoomPhoto.scale, { x: 8, y: 8, z: 8, duration: 1.2 });
                    // ä½¿ç”¨ quaternion å®Œç¾å¯¹é½
                    gsap.to(activeZoomPhoto.quaternion, { x: camera.quaternion.x, y: camera.quaternion.y, z: camera.quaternion.z, w: camera.quaternion.w, duration: 1.2 });
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate); time+=0.01;
            
            if(state !== 'ZOOM') {
                const tRotY = (handPosition.x-0.5)*3; const tRotX = (handPosition.y-0.5)*2;
                mainGroup.rotation.y += (tRotY - mainGroup.rotation.y)*0.05;
                mainGroup.rotation.x += (tRotX - mainGroup.rotation.x)*0.05;
                if(state !== 'CONVERGED') photoGroup.rotation.copy(mainGroup.rotation);
                else { photoGroup.rotation.y += 0.005; photoGroup.rotation.x *= 0.95; }
            }

            if(state==='DISPERSED') particles.forEach(p => { p.mesh.position.y+=Math.sin(time+p.seed*10)*0.1; p.mesh.position.x+=Math.cos(time+p.seed*10)*0.1; });
            
            photoClouds.forEach(p => { if(p !== activeZoomPhoto) p.lookAt(camera.position); });
            composer.render();
        }

        function handleFileUpload(e) {
            const files=e.target.files; if(!files.length)return;
            photoClouds.forEach(p=>photoGroup.remove(p)); photoClouds=[];
            Array.from(files).slice(0,CONFIG.maxPhotos).forEach((f,i)=>{
                const r=new FileReader();
                r.onload=ev=>{
                    const img=new Image(); img.src=ev.target.result;
                    img.onload=()=>{
                        const tex=new THREE.Texture(img); tex.needsUpdate=true; tex.colorSpace=THREE.SRGBColorSpace;
                        const mesh=new THREE.Mesh(new THREE.PlaneGeometry(15,15), new THREE.MeshBasicMaterial({map:tex, side:THREE.DoubleSide, transparent:true}));
                        const ang=(i/files.length)*Math.PI*2, rad=200;
                        mesh.homePos=new THREE.Vector3(Math.cos(ang)*rad, (Math.random()-0.5)*150, Math.sin(ang)*rad);
                        mesh.scatterPos=new THREE.Vector3((Math.random()-0.5)*1000, (Math.random()-0.5)*800, (Math.random()-0.5)*1000);
                        mesh.position.copy(mesh.scatterPos); photoGroup.add(mesh); photoClouds.push(mesh);
                    }
                }
                r.readAsDataURL(f);
            });
            alert(`å·²åŠ è½½ ${files.length} å¼ ç…§ç‰‡ã€‚`);
        }

        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); }
        
        function initMediaPipe() {
            const v=document.getElementById('video-element');
            const h=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            h.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7});
            h.onResults(res=>{
                if(!res.multiHandLandmarks.length) return; const lm=res.multiHandLandmarks[0];
                handPosition.x=1-(lm[0].x+lm[9].x)/2; handPosition.y=(lm[0].y+lm[9].y)/2;
                const pinch=Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                let open=0; [8,12,16,20].forEach((t,i)=>{if(lm[t].y<lm[5+i*4].y)open++});
                if(pinch<0.05) { if(state!=='ZOOM') updateState('ZOOM'); }
                else if(open>=4) { if(state!=='DISPERSED') updateState('DISPERSED'); }
                else if(open<=1) { if(state!=='CONVERGED' && state!=='ZOOM') updateState('CONVERGED'); }
            });
            new Camera(v,{onFrame:async()=>await h.send({image:v}),width:320,height:240}).start();
        }
    </script>
</body>
</html>
