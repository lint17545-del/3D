<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Matrix (V17.0 Precision Tower)</title>
    <style>
        /* æ·±è“å·¥ä¸šèƒŒæ™¯ */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center bottom, #051020 0%, #000000 100%); font-family: "Microsoft YaHei", sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #00f3ff; pointer-events: none; user-select: none;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.6);
        }
        h1 { margin: 0; font-weight: 800; letter-spacing: 6px; font-size: 32px; color: #ffffff; text-transform: uppercase; }
        .subtitle { font-size: 12px; color: #0088ff; letter-spacing: 3px; margin-top: 5px; border-left: 3px solid #00f3ff; padding-left: 10px;}
        .version-tag { font-size: 10px; color: #ffaa00; margin-top: 15px; border: 1px solid #ffaa00; display: inline-block; padding: 4px 8px; background: rgba(0,0,0,0.8);}
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #00050a; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #00f3ff;
            flex-direction: column; transition: opacity 0.8s;
        }
        
        #start-btn {
            margin-top: 40px; padding: 15px 60px; 
            background: transparent; color: #00f3ff;
            border: 2px solid #00f3ff; cursor: pointer;
            font-size: 16px; letter-spacing: 4px; font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            text-transform: uppercase; transition: 0.3s;
            display: none; 
        }
        #start-btn:hover { background: #00f3ff; color: #000; box-shadow: 0 0 50px rgba(0, 243, 255, 1.0); }
        #loading-text { margin-top: 15px; color: #446688; font-size: 12px; font-family: monospace; }

        #upload-btn {
            pointer-events: auto; background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00f3ff; color: #00f3ff; padding: 8px 20px;
            cursor: pointer; margin-top: 20px; display: inline-block;
            font-size: 12px; letter-spacing: 1px; transition: 0.3s;
        }
        #upload-btn:hover { background: #00f3ff; color: #000; }
        input[type="file"] { display: none; }
        .input_video { display: none; }
        
        .status-highlight { color: #ffff00; font-weight: bold; text-shadow: 0 0 10px #ffff00; }
        .icon-guide { margin-top: 15px; font-size: 12px; color: #88aacc; line-height: 2.0; }
        .highlight { color: #ffffff; font-weight: bold; }
    </style>
</head>
<body>
    <div id="loader">
        <div style="font-size: 32px; letter-spacing: 8px; font-weight: bold; text-shadow: 0 0 20px #00f3ff;">èƒ½æºçŸ©é˜µ</div>
        <div style="font-size: 14px; letter-spacing: 4px; color: #ffffff; opacity: 0.7; margin-top: 5px;">ENERGY MATRIX V17.0</div>
        <div id="loading-text">CALCULATING STRUCTURE...</div>
        <button id="start-btn">INITIALIZE</button>
    </div>

    <div id="ui-layer">
        <h1>æ™ºæ…§èƒ½æº</h1>
        <div class="subtitle">THERMAL & NEW ENERGY VISUALIZATION</div>
        <div class="version-tag">Precision Cooling Tower</div>
        <div class="status" id="gesture-status">SYSTEM READY</div>
        <div class="icon-guide">
            <span class="highlight">âœŒï¸ å‰ªåˆ€æ‰‹</span> : å…¨è´Ÿè·è¿è¡Œ (Full Power)<br>
            <span class="highlight">âœŠ æ¡æ‹³</span> : å¾…æœºçŠ¶æ€ (Standby)<br>
            <span class="highlight">ğŸ– å¼ å¼€</span> : <span style="color:#ff00ff">ç»“æ„è§£æ„ (SCATTER)</span><br>
            <span class="highlight">ğŸ–±ï¸ é¼ æ ‡</span> : è§†è§’ç¯ç»• (Orbit)
        </div>
        <label id="upload-btn">
            [+] åŠ è½½å…¨æ¯å½±åƒ (Upload Photo)
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        // partType: 0=å¡”èº«, 1=é£æœºå¶ç‰‡, 2=å…‰ä¼, 3=è’¸æ±½, 4=åœ°é¢, 5=éšœç¢ç¯
        attribute float partType; 
        attribute vec3 initialPos; 
        attribute float randomSeed;

        uniform float time;
        uniform float runSpeed; 
        uniform float scatter;
        uniform vec3 mousePos;
        
        varying vec3 vColor;
        varying float vAlpha;

        mat2 rotate2d(float _angle){ return mat2(cos(_angle),-sin(_angle), sin(_angle),cos(_angle)); }

        void main() {
            vColor = customColor;
            vAlpha = 1.0;
            vec3 pos = initialPos;
            float t = time * runSpeed;

            if (partType > 0.5 && partType < 1.5) { // é£æœº
                vec3 center = vec3(-25.0, 35.0, -10.0);
                vec3 local = pos - center;
                float angle = -t * 3.0; 
                local.xy = rotate2d(angle) * local.xy;
                pos = center + local;
                vColor += vec3(0.2) * sin(t * 5.0 + pos.x); 
            } else if (partType > 1.5 && partType < 2.5) { // å…‰ä¼
                float flow = mod(pos.x + pos.z + t * 5.0, 20.0);
                if (flow < 2.0) { vColor = vec3(1.0); pos.y += 0.5; }
            } else if (partType > 2.5 && partType < 3.5) { // è’¸æ±½
                float cycle = mod(time * (1.0 + runSpeed) + randomSeed * 10.0, 1.0);
                pos.y = initialPos.y + cycle * 20.0; 
                float spread = cycle * 8.0;
                pos.x += sin(time + randomSeed * 10.0) * spread * 0.6;
                pos.z += cos(time + randomSeed * 10.0) * spread * 0.6;
                vAlpha = (1.0 - cycle) * (runSpeed * 0.8 + 0.2);
            } else if (partType > 3.5 && partType < 4.5) { // åœ°é¢
                vAlpha = 0.3 + 0.2 * sin(time + pos.x * 0.1);
            } else if (partType > 4.5) { // éšœç¢ç¯ (é—ªçƒ)
                float blink = sin(time * 3.0);
                if(blink > 0.8) vColor = vec3(1.0, 0.0, 0.0);
                else vColor = vec3(0.2, 0.0, 0.0);
            }

            // æ•£å¼€
            if (scatter > 0.01) {
                vec3 dir = normalize(initialPos);
                if (length(initialPos) < 0.1) dir = vec3(0.0, 1.0, 0.0);
                pos += dir * scatter * 80.0;
                pos.x += sin(randomSeed * 30.0 + time) * scatter * 20.0;
                pos.y += cos(randomSeed * 20.0) * scatter * 20.0;
                vColor = mix(vColor, vec3(0.0, 1.0, 1.0), scatter * 0.5);
                vAlpha *= (1.0 - scatter * 0.4);
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor; varying float vAlpha;
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            if (dot(cxy, cxy) > 1.0) discard;
            float glow = 1.0 - dot(cxy, cxy);
            glow = pow(glow, 2.0);
            gl_FragColor = vec4(vColor, vAlpha * glow);
        }
    </script>

    <script>
        const CONFIG = {
            particleCount: 28000,
            cameraZ: 90,
            colors: {
                cyan: new THREE.Color(0x00eaff),
                orange: new THREE.Color(0xffaa00),
                white: new THREE.Color(0xffffff),
                grey: new THREE.Color(0x556677),
                darkBase: new THREE.Color(0x001133),
                red: new THREE.Color(0xff0000)
            }
        };

        let scene, camera, renderer, composer;
        let particles, uniforms;
        let photoGroup, photosData = [];
        const STATE = { mode: 'ENERGY' };

        window.onload = function() {
            const btn = document.getElementById('start-btn');
            const txt = document.getElementById('loading-text');
            setTimeout(() => { btn.style.display = 'block'; }, 3000);
            btn.onclick = () => {
                if(typeof THREE === 'undefined') { alert("ç»„ä»¶æœªåŠ è½½ï¼Œè¯·åˆ·æ–°"); return; }
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 800);
                init();
                try { startAI(); } catch(e) { console.warn("AI skipped"); }
            };
        };

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x00050a, 0.002);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 30, CONFIG.cameraZ);
            camera.lookAt(0, 15, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.2; bloomPass.strength = 1.3; bloomPass.radius = 0.5;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene); composer.addPass(bloomPass);
            } catch(e) { composer = null; }

            buildIndustrialCity();
            
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            document.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('resize', onResize, false);
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            animate();
        }

        // --- æ ¸å¿ƒï¼šå·¥ä¸šå»ºç­‘ç”Ÿæˆç®—æ³• ---
        function buildIndustrialCity() {
            const positions = [], colors = [], sizes = [], partTypes = [], initialPos = [], randomSeeds = [];
            const tempVec = new THREE.Vector3(); const tempCol = new THREE.Color();

            function pushParticle(x, y, z, color, size, type) {
                positions.push(x, y, z); initialPos.push(x, y, z);
                colors.push(color.r, color.g, color.b); sizes.push(size);
                partTypes.push(type); randomSeeds.push(Math.random());
            }

            // === 1. å‡‰æ°´å¡” (Cooling Tower) - ç²¾å¯†é€ å‹ç‰ˆ ===
            const towerCenter = new THREE.Vector3(10, 0, -10);
            const towerHeight = 40; // å¡”é«˜
            const baseRad = 15;     // åº•éƒ¨åŠå¾„ (ä¸‹å¤§)
            const throatRad = 8;    // å–‰éƒ¨åŠå¾„ (ä¸­é—´å°)
            const topRad = 9;       // é¡¶éƒ¨åŠå¾„ (ä¸Šå£å¾®å¼ ï¼Œä½†æ¯”åº•å°)
            const throatH = 30;     // å–‰éƒ¨é«˜åº¦ (çº¦75%å¤„)

            for(let y=0; y<=towerHeight; y+=0.5) { // å¢åŠ å±‚æ•°ï¼Œæ›´ç»†è…»
                // åŠå¾„è®¡ç®—ï¼šåˆ†æ®µæ’å€¼
                let currentRad;
                if (y < throatH) {
                    // åº•éƒ¨åˆ°å–‰éƒ¨ï¼šäºŒæ¬¡æ›²çº¿æ€¥å‰§æ”¶ç¼©
                    let t = y / throatH; // 0 -> 1
                    // æŠ›ç‰©çº¿æ’å€¼
                    currentRad = baseRad + (throatRad - baseRad) * (1 - (1-t)*(1-t));
                    // ä¿®æ­£ï¼šæˆ‘ä»¬è¦çš„æ˜¯ä¸‹å‡¹æ›²çº¿ (Hyperbolic)
                    // R(y) = a / sqrt(y+c) è¿™ç§æ„Ÿè§‰ï¼Œæˆ–è€…ç®€å•çš„ x^2
                    // è®©æˆ‘ä»¬ç”¨æ›´ç®€å•çš„ï¼š t^2 æ’å€¼
                    currentRad = baseRad * (1-t)*(1-t) + throatRad * (1-(1-t)*(1-t));
                    // å†æ¬¡ä¿®æ­£ï¼šæ ‡å‡†çš„ Cooling tower æ›²çº¿
                    let dy = y - throatH;
                    currentRad = throatRad * Math.sqrt(1 + (dy*dy)/(throatH*throatH * 0.5));
                } else {
                    // å–‰éƒ¨åˆ°é¡¶éƒ¨ï¼šçº¿æ€§æˆ–å¾®æ›²çº¿å¼ å¼€
                    let t = (y - throatH) / (towerHeight - throatH);
                    currentRad = throatRad + (topRad - throatRad) * t;
                }

                // æ¯ä¸€å±‚çš„ä¸€åœˆç²’å­
                let circumference = 2 * Math.PI * currentRad;
                let particleCount = Math.floor(circumference * 1.5); // ä¿æŒå¯†åº¦ä¸€è‡´
                
                for(let i=0; i<particleCount; i++) {
                    let angle = (i / particleCount) * Math.PI * 2;
                    let px = towerCenter.x + Math.cos(angle) * currentRad;
                    let pz = towerCenter.z + Math.sin(angle) * currentRad;
                    
                    // çº¹ç†ï¼šåŠ ä¸€äº›çºµå‘çš„åŠ å¼ºç­‹
                    let isRib = (i % 8 === 0);
                    let col = isRib ? CONFIG.colors.cyan : CONFIG.colors.darkBase;
                    // é¡¶éƒ¨åŠ ä¸€åœˆçº¢ç¯ (éšœç¢ç¯)
                    let type = 0.0;
                    if (y > towerHeight - 1 && i % 10 === 0) {
                        col = CONFIG.colors.red;
                        type = 5.0; // é—ªçƒç¯
                    }
                    
                    pushParticle(px, y, pz, col, isRib ? 0.8 : 0.5, type);
                }
            }
            // å¡”åº•æ”¯æŸ± (è¿›é£å£)
            for(let i=0; i<20; i++) {
                let angle = (i/20) * Math.PI * 2;
                let r = baseRad;
                // å€¾æ–œæ”¯æŸ± Xå½¢
                for(let h=0; h<4; h+=0.5) {
                    let x = towerCenter.x + Math.cos(angle) * (r - h*0.2);
                    let z = towerCenter.z + Math.sin(angle) * (r - h*0.2);
                    pushParticle(x, h, z, CONFIG.colors.white, 0.6, 0.0);
                }
            }
            // è’¸æ±½æº (å†…éƒ¨)
            for(let i=0; i<800; i++) {
                 let angle = Math.random() * Math.PI * 2;
                 let r = Math.random() * throatRad;
                 pushParticle(towerCenter.x + Math.cos(angle)*r, towerHeight - 5, towerCenter.z + Math.sin(angle)*r, CONFIG.colors.grey, 2.0, 3.0);
            }

            // === 2. é£æœº (Type 0 & 1) ===
            const windPos = new THREE.Vector3(-25, 0, -10); const windHeight = 35;
            // å¡”ç­’
            for(let h=0; h<windHeight; h+=0.5) {
                let r = 1.2 * (1.0 - h/windHeight * 0.5);
                for(let i=0; i<12; i++) {
                    let angle = (i/12) * Math.PI * 2;
                    pushParticle(windPos.x + Math.cos(angle)*r, h, windPos.z + Math.sin(angle)*r, CONFIG.colors.white, 0.6, 0.0);
                }
            }
            // é¡¶éƒ¨æœºèˆ±
            for(let x=-2; x<=2; x+=0.5) {
                for(let y=0; y<=2; y+=0.5) {
                    for(let z=-2; z<=2; z+=0.5) {
                        pushParticle(windPos.x + x, windHeight + y, windPos.z + z, CONFIG.colors.white, 0.8, 0.0);
                    }
                }
            }
            // å¶ç‰‡
            const bladeLen = 22;
            for(let b=0; b<3; b++) {
                let baseAngle = (b / 3) * Math.PI * 2;
                for(let l=2; l<bladeLen; l+=0.4) {
                    let width = 1.8 * Math.sin((l/bladeLen) * Math.PI); 
                    for(let w=-width/2; w<width/2; w+=0.2) {
                        let lx = w; let ly = l;
                        let rx = lx * Math.cos(baseAngle) - ly * Math.sin(baseAngle);
                        let ry = lx * Math.sin(baseAngle) + ly * Math.cos(baseAngle);
                        pushParticle(windPos.x + rx, windHeight + 1 + ry, windPos.z, CONFIG.colors.white, 0.5, 1.0);
                    }
                }
            }

            // === 3. å…‰ä¼ ===
            const pvRows = 8; const pvCols = 10;
            const pvStartX = -35; const pvStartZ = 5;
            for(let r=0; r<pvRows; r++) {
                for(let c=0; c<pvCols; c++) {
                    let cx = pvStartX + c * 6; let cz = pvStartZ + r * 4;
                    for(let px=-2.5; px<=2.5; px+=0.4) {
                        for(let pz=-1.5; pz<=1.5; pz+=0.4) {
                            let py = 1.5 + pz * 0.5; let realZ = cz + pz;
                            let isBorder = (Math.abs(px)>2.3 || Math.abs(pz)>1.3);
                            pushParticle(cx + px, py, realZ, isBorder ? CONFIG.colors.orange : CONFIG.colors.darkBase, isBorder ? 0.6 : 0.4, 2.0);
                        }
                    }
                }
            }

            // === 4. åœ°é¢ ===
            for(let x=-60; x<=60; x+=2) {
                for(let z=-40; z<=60; z+=2) {
                    if(Math.random() > 0.95) pushParticle(x, 0, z, CONFIG.colors.cyan, 0.4, 4.0);
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('initialPos', new THREE.Float32BufferAttribute(initialPos, 3));
            geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('partType', new THREE.Float32BufferAttribute(partTypes, 1));
            geometry.setAttribute('randomSeed', new THREE.Float32BufferAttribute(randomSeeds, 1));

            uniforms = {
                time: { value: 0.0 },
                runSpeed: { value: 0.1 },
                scatter: { value: 0.0 },
                mousePos: { value: new THREE.Vector3(0,0,0) }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function onMouseMove(e) {
            let mx = (e.clientX / window.innerWidth) * 2 - 1;
            let my = -(e.clientY / window.innerHeight) * 2 + 1;
            if(uniforms) uniforms.mousePos.value.set(mx, my, 0);
            if(STATE.mode !== 'SCATTER') {
                camera.position.x += (mx * 10 - camera.position.x) * 0.05;
                camera.position.y += (20 + my * 5 - camera.position.y) * 0.05;
                camera.lookAt(0, 15, 0);
            }
        }
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(composer) composer.setSize(window.innerWidth, window.innerHeight);
        }
        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }
        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.encoding=THREE.sRGBEncoding;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8*aspect, 8), mat);
            const border = new THREE.LineSegments( new THREE.EdgesGeometry(new THREE.PlaneGeometry(8*aspect, 8)), new THREE.LineBasicMaterial( { color: 0x00f3ff } ));
            mesh.add(border);
            mesh.position.set(10, 45, -10);
            mesh.userData = { home: mesh.position.clone(), scat: new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*50, (Math.random()-0.5)*100), focus: false };
            photoGroup.add(mesh); photosData.push(mesh);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            if(uniforms) {
                uniforms.time.value = time;
                let targetSpeed = 0.1; let targetScatter = 0.0;
                if (STATE.mode === 'OPERATING') targetSpeed = 2.0; 
                if (STATE.mode === 'SCATTER') targetScatter = 1.0;
                uniforms.runSpeed.value += (targetSpeed - uniforms.runSpeed.value) * 0.05;
                uniforms.scatter.value += (targetScatter - uniforms.scatter.value) * 0.05;
            }
            photosData.forEach(p => {
                const d = p.userData; let tgt = (STATE.mode === 'SCATTER') ? d.scat : d.home;
                if(d.focus) {
                    const v = new THREE.Vector3(0,0,-20).applyQuaternion(camera.quaternion); tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position); 
                } else {
                    p.lookAt(camera.position);
                    if(STATE.mode !== 'SCATTER') p.position.y = d.home.y + Math.sin(time + p.id)*2.0;
                }
                p.position.lerp(tgt, 0.05);
            });
            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        async function startAI() {
            const video = document.getElementsByClassName('input_video')[0];
            const stat = document.getElementById('gesture-status');
            if(typeof Hands === 'undefined') return;
            const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults(res => {
                if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    const lm = res.multiHandLandmarks[0];
                    stat.classList.add('status-highlight');
                    
                    let openCount = 0;
                    if(lm[8].y < lm[6].y) openCount++; 
                    if(lm[12].y < lm[10].y) openCount++;
                    if(lm[16].y < lm[14].y) openCount++; 
                    if(lm[20].y < lm[18].y) openCount++; 

                    const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;

                    if (pinch) {
                        stat.innerText = "ğŸ‘Œ æŠ“å– (GRAB)";
                        if(photosData.length>0) { photosData.forEach(p=>p.userData.focus=false); photosData[photosData.length-1].userData.focus = true; }
                    } 
                    else if (openCount >= 4) { STATE.mode = 'SCATTER'; stat.innerText = "ğŸ– ç»“æ„æ•£å¼€ (SCATTER)"; }
                    else if (openCount === 2) { STATE.mode = 'OPERATING'; stat.innerText = "âœŒï¸ å…¨é€Ÿè¿è¡Œ (MAX POWER)"; }
                    else if (openCount === 0) { STATE.mode = 'ENERGY'; stat.innerText = "âœŠ å¾…æœº (STANDBY)"; }
                } else { stat.classList.remove('status-highlight'); }
            });
            const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
            await cam.start(); stat.innerText = "AI æ¿€æ´»";
        }
    </script>
</body>
</html>
