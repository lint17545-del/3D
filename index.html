<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D Particle Horse - Perfect Frame</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Arial', sans-serif; }
        
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; opacity: 0.5; }
        
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 24px; color: #FFD700; letter-spacing: 2px; text-shadow: 0 0 20px rgba(196, 30, 58, 0.5); font-weight: 300; }
        .status { font-size: 16px; color: rgba(255,255,255,0.8); margin-top: 10px; font-weight: normal; letter-spacing: 1px;}
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; z-index: 20; font-size: 16px; text-align: center; letter-spacing: 2px; }
        
        /* 增加鼠标提示，避免用户不知道可以滚轮缩放 */
        #hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.3); font-size: 12px; pointer-events: none; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">正在进行构图计算...</div>
    
    <div id="ui-layer">
        <h1>粒子灵驹 · 构图修正版</h1>
        <div class="status" id="status-text">等待指令...</div>
    </div>
    <div id="hint">支持鼠标滚轮调整远近 | 手势控制旋转</div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const CONFIG = {
            particleCount: 6000, // 粒子更密，增强体积感
            colors: [0x0F52BA, 0xFFD700, 0xC41E3A], 
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb'
        };

        let scene, camera, renderer, composer, controls;
        let particles = [];
        let group;
        let state = 'CONVERGED';
        let time = 0;
        let handPosition = { x: 0.5, y: 0.5 };
        // 增加一个全局中心点，用于构图
        let modelCenter = new THREE.Vector3(0,0,0);

        init();
        animate();
        initMediaPipe();

        function init() {
            scene = new THREE.Scene();
            // 背景改为更有深度的径向渐变模拟（这里用Fog配合暗色）
            scene.fog = new THREE.FogExp2(0x020205, 0.0015);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            // 初始位置稍微远一点，等模型加载完会自动对焦
            camera.position.set(0, 0, 400);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 灯光优化：主光源 + 轮廓光 + 补光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(50, 50, 100);
            scene.add(mainLight);
            
            const rimLight = new THREE.SpotLight(0x0F52BA, 5); // 蓝色轮廓光
            rimLight.position.set(-50, 50, -50);
            rimLight.lookAt(0,0,0);
            scene.add(rimLight);

            // 后处理
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.2; // 辉光强度适中
            bloomPass.radius = 0.5;
            bloomPass.threshold = 0.1;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true; // 允许用户自己微调

            loadModel();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function loadModel() {
            const loader = new GLTFLoader();
            loader.load(CONFIG.modelUrl, (gltf) => {
                const model = gltf.scene;
                let mesh = null;
                model.traverse((child) => {
                    if (child.isMesh) mesh = child;
                });

                if(mesh) {
                    createParticlesFromMesh(mesh);
                }
                document.getElementById('loading').style.display = 'none';
            });
        }

        function createParticlesFromMesh(mesh) {
            group = new THREE.Group();
            scene.add(group);

            const posAttr = mesh.geometry.attributes.position;
            const count = posAttr.count;
            const targetPoints = [];
            const tempVec = new THREE.Vector3();

            // 1. 获取所有点
            for(let i=0; i<count; i++) {
                tempVec.fromBufferAttribute(posAttr, i);
                targetPoints.push(tempVec.clone());
            }

            // 2. 计算包围盒 (Bounding Box)
            // 这就是解决“太大”或“太小”的关键
            const box = new THREE.Box3().setFromPoints(targetPoints);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            modelCenter.copy(center);

            // 3. 将所有点归一化并移动到原点中心
            // 我们不依赖模型的原始坐标，而是手动把它们居中
            targetPoints.forEach(p => {
                p.sub(center); // 居中
            });

            // 4. 计算最佳相机距离 (Fit to Screen)
            // 根据 FOV 和 模型最大边长，反推相机 z 轴
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.2; // 乘以 1.2 留出 20% 的边距 (Padding)

            // 移动相机到最佳位置
            gsap.to(camera.position, { z: cameraZ, duration: 2, ease: "power2.out" });
            controls.target.set(0, 0, 0); // 确然看的是中心

            // 5. 生成粒子
            const shuffledPoints = targetPoints.sort(() => Math.random() - 0.5).slice(0, CONFIG.particleCount);
            const geom = new THREE.BoxGeometry(0.5, 0.5, 0.5); // 稍微细腻一点的粒子
            const materials = CONFIG.colors.map(c => new THREE.MeshBasicMaterial({ color: c }));

            shuffledPoints.forEach(pt => {
                const mat = materials[Math.floor(Math.random() * materials.length)];
                const pMesh = new THREE.Mesh(geom, mat);
                
                // 散开范围根据模型本身大小来定，而不是写死
                const scatterRange = maxDim * 2; 
                const scatterPos = new THREE.Vector3(
                    (Math.random()-0.5) * scatterRange,
                    (Math.random()-0.5) * scatterRange,
                    (Math.random()-0.5) * scatterRange
                );

                pMesh.userData = {
                    randomOffset: Math.random() * 100,
                    speed: 0.01 + Math.random() * 0.02
                };

                pMesh.position.copy(scatterPos);
                group.add(pMesh);

                particles.push({
                    mesh: pMesh,
                    targetPos: pt,
                    scatterPos: scatterPos
                });
            });
            
            updateState('DISPERSED');
        }

        function updateState(newState) {
            if (state === newState) return;
            state = newState;
            
            const statusEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                statusEl.innerText = "状态: 聚合";
                statusEl.style.color = "#FFD700";

                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.targetPos.x,
                        y: p.targetPos.y,
                        z: p.targetPos.z,
                        duration: 1.8, // 稍微慢一点，更优雅
                        ease: "power3.inOut" // 更平滑的加减速
                    });
                    // 聚合时粒子稍微变小一点，显得精致
                    gsap.to(p.mesh.scale, { x: 1, y: 1, z: 1, duration: 1.5 });
                });

            } else if (state === 'DISPERSED') {
                statusEl.innerText = "状态: 散开 (手势控制)";
                statusEl.style.color = "#00ffff";

                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.scatterPos.x,
                        y: p.scatterPos.y,
                        z: p.scatterPos.z,
                        duration: 2.0,
                        ease: "power2.out"
                    });
                    // 散开时粒子变大，更有氛围感
                    gsap.to(p.mesh.scale, { x: 2, y: 2, z: 2, duration: 1.5 });
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            if (!group) return;

            // 1. 整体呼吸感 (Breath)
            // 无论什么状态，整体都有一种极缓慢的上下浮动，打破死板
            group.position.y = Math.sin(time * 0.5) * 2; 

            if (state === 'DISPERSED') {
                // 散开态：粒子游动
                particles.forEach(p => {
                    const offset = p.mesh.userData.randomOffset;
                    // 使用噪点式的移动，不仅仅是上下
                    p.mesh.position.x += Math.cos(time + offset) * 0.05;
                    p.mesh.position.y += Math.sin(time + offset) * 0.05;
                    p.mesh.position.z += Math.sin(time * 0.5 + offset) * 0.05;
                });

                // 手势柔和跟随
                const targetRotY = (handPosition.x - 0.5) * 2; 
                const targetRotX = (handPosition.y - 0.5) * 1;

                // 阻尼更大(0.03)，惯性更强，感觉更重、更高级
                group.rotation.y += (targetRotY - group.rotation.y) * 0.03;
                group.rotation.x += (targetRotX - group.rotation.x) * 0.03;

            } else {
                // 聚合态：非常缓慢的自转展示
                group.rotation.y += 0.002;
                // 也要响应一点点手势，但很微弱
                const targetRotX = (handPosition.y - 0.5) * 0.5;
                group.rotation.x += (targetRotX - group.rotation.x) * 0.05;
            }

            controls.update();
            composer.render();
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('video-element');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) return;
                
                const lm = results.multiHandLandmarks[0];
                
                // 更新手势位置
                const palmX = (lm[0].x + lm[9].x) / 2;
                const palmY = (lm[0].y + lm[9].y) / 2;
                handPosition.x = 1 - palmX; 
                handPosition.y = palmY;

                // 状态判定
                const tips = [8, 12, 16, 20];
                const bases = [5, 9, 13, 17];
                let openCount = 0;
                tips.forEach((tip, i) => {
                    if (lm[tip].y < lm[bases[i]].y) openCount++;
                });

                if (openCount >= 3) {
                    updateState('DISPERSED');
                } else if (openCount <= 1) {
                    updateState('CONVERGED');
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start();
        }
    </script>
</body>
</html>
