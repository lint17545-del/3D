<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNY Final Horse (Hardcoded Points)</title>
    <style>
        /* 1. è§†è§‰è¿˜åŸï¼šçº¢åŒ…é£æ ¼æ·±çº¢èƒŒæ™¯ */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #660000 0%, #2a0000 100%); font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #ffd700; pointer-events: none; user-select: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        h1 { margin: 0; font-weight: bold; letter-spacing: 2px; font-size: 24px; color: #ffd700; }
        
        /* çŠ¶æ€æ˜¾ç¤º */
        #status-box {
            margin-top: 10px; padding: 8px 15px;
            border: 2px solid #ffd700; background: rgba(0,0,0,0.6);
            font-size: 16px; font-weight: bold; color: #fff;
            display: inline-block; border-radius: 6px;
        }
        
        #upload-btn {
            pointer-events: auto; background: rgba(100, 0, 0, 0.6);
            border: 1px solid #ffd700; color: #ffd700; padding: 8px 15px;
            cursor: pointer; margin-top: 15px; display: inline-block; font-size: 12px;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <h1>é¾™é©¬ç²¾ç¥ Â· æœ€ç»ˆä¿®æ­£</h1>
        <div id="status-box">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤...</div>
        <div style="margin-top:10px; font-size:12px; color:#ffcccc; line-height: 1.6;">
            ğŸ– <b>å¼ å¼€æ‰‹</b>: ç‚¸è£‚æ•£å¼€ (SCATTER)<br>
            âœŠ <b>æ¡æ‹³</b>: èšåˆæˆé©¬ (ASSEMBLE)<br>
            ğŸ‘Œ <b>æåˆ</b>: æŠ“å–ç…§ç‰‡ (GRAB)
        </div>
        <label id="upload-btn">
            ä¸Šä¼ ç…§ç‰‡
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        const CONFIG = {
            particleCount: 3500, // ç²’å­æ•°é‡
            cameraZ: 50,
            colors: { gold: 0xffd700, blue: 0x00ffff, white: 0xffffff }
        };

        const STATE = { mode: 'ASSEMBLE', handVisible: false };
        let scene, camera, renderer, composer;
        let particlesMesh, dummy = new THREE.Object3D();
        let particlesData = [], photoGroup, photosData = [];
        let time = 0;

        // ç›´æ¥å¯åŠ¨ï¼Œä¸ç­‰å¾… loader
        window.onload = function() {
            init();
            try { startAI(); } catch(e) {}
        };

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x2a0000, 0.002); // çº¢é›¾

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.cameraZ);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const l1 = new THREE.PointLight(CONFIG.colors.gold, 2, 100); l1.position.set(20,20,20); scene.add(l1);

            // è¾‰å…‰ (è®©ç²’å­å‘äº®)
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.1; bloomPass.strength = 1.5; bloomPass.radius = 0.5;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene); composer.addPass(bloomPass);
            } catch(e) { composer = null; }

            // åˆ›å»ºç²’å­
            createHardcodedHorse();
            
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            // é¼ æ ‡äº¤äº’
            document.addEventListener('mousemove', e => {
                if(!STATE.handVisible && STATE.mode === 'SCATTER') {
                    camera.position.x += ((e.clientX/window.innerWidth-0.5)*30 - camera.position.x)*0.05;
                    camera.position.y += (-(e.clientY/window.innerHeight-0.5)*30 - camera.position.y)*0.05;
                    camera.lookAt(0,0,0);
                }
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if(composer) composer.setSize(window.innerWidth, window.innerHeight);
            });
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            
            animate();
        }

        // --- æ ¸å¿ƒï¼šå®Œå…¨æ‰‹å·¥å®šä¹‰çš„é©¬åŒ¹ç‚¹äº‘ (ä¸ä¾èµ–ä»»ä½•åŠ è½½) ---
        function createHardcodedHorse() {
            const geo = new THREE.TetrahedronGeometry(0.25, 0); // è±å½¢ç²’å­
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.8 });
            particlesMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
            
            const col = new THREE.Color();
            
            // è¾…åŠ©å‡½æ•°ï¼šåœ¨ä¸€ä¸ªæ¤­åœ†èŒƒå›´å†…éšæœºç”Ÿæˆç‚¹
            // type: 0=èº«, 1=å¤´é¢ˆ, 2=è…¿, 3=å°¾
            function addCluster(count, cx, cy, cz, rx, ry, rz, type) {
                for(let k=0; k<count; k++) {
                    if(particlesData.length >= CONFIG.particleCount) break;
                    
                    // éšæœºç‚¹
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.cbrt(Math.random());
                    let x = cx + rx * r * Math.sin(phi) * Math.cos(theta);
                    let y = cy + ry * r * Math.sin(phi) * Math.sin(theta);
                    let z = cz + rz * r * Math.cos(phi);

                    // é¢œè‰²åˆ†é… (é‡‘+è“)
                    let rnd = Math.random();
                    if(rnd > 0.6) col.setHex(CONFIG.colors.gold);
                    else if(rnd > 0.3) col.setHex(CONFIG.colors.blue);
                    else col.setHex(0xffffff);
                    
                    let idx = particlesData.length;
                    particlesMesh.setColorAt(idx, col);

                    // åˆå§‹ç‚¸å¼€ä½ç½®
                    const startPos = new THREE.Vector3(
                        (Math.random()-0.5)*150, 
                        (Math.random()-0.5)*100, 
                        (Math.random()-0.5)*100
                    );
                    
                    dummy.position.copy(startPos);
                    dummy.updateMatrix();
                    particlesMesh.setMatrixAt(idx, dummy.matrix);

                    particlesData.push({
                        idx: idx,
                        current: startPos.clone(),
                        homeBase: new THREE.Vector3(x, y, z), // é©¬çš„å½¢çŠ¶åŸºå‡†
                        scatter: startPos.clone(),
                        type: type, // ç”¨äºåŠ¨ç”»åŒºåˆ†
                        speed: 0.05 + Math.random()*0.05,
                        offset: Math.random() * 100
                    });
                }
            }

            // --- æ‰‹å·¥â€œæâ€ä¸€åŒ¹é©¬ ---
            // 1. èº«ä½“ (Body) - æ¨ªå‘æ¤­åœ†
            addCluster(1200, 0, 0, 0, 10, 5, 4, 0);
            
            // 2. è„–å­ (Neck) - å‘ä¸Šå‘å‰
            // æˆ‘ä»¬é€šè¿‡åæ ‡å˜æ¢æŠŠä¸€å›¢ç²’å­ç§»è¿‡å»
            // è„–å­æ˜¯å€¾æ–œçš„
            for(let i=0; i<600; i++) {
                 // ç®€å•çš„çº¿æ€§æ’å€¼ç”Ÿæˆåœ†æŸ±æ„Ÿ
                 let t = Math.random(); 
                 let px = 6 + t * 6; // x: 6 -> 12
                 let py = 3 + t * 8; // y: 3 -> 11
                 let pz = (Math.random()-0.5) * 3 * (1-t*0.5); // è„–å­ä¸Šé¢ç»†
                 
                 // é¢œè‰²
                 let rnd = Math.random();
                 if(rnd > 0.6) col.setHex(CONFIG.colors.gold);
                 else if(rnd > 0.3) col.setHex(CONFIG.colors.blue);
                 else col.setHex(0xffffff);
                 
                 let idx = particlesData.length;
                 particlesMesh.setColorAt(idx, col);
                 
                 // æ•°æ®
                 const startPos = new THREE.Vector3((Math.random()-0.5)*150, (Math.random()-0.5)*100, 0);
                 dummy.position.copy(startPos); dummy.updateMatrix(); particlesMesh.setMatrixAt(idx, dummy.matrix);
                 particlesData.push({
                    idx: idx, current: startPos.clone(), homeBase: new THREE.Vector3(px, py, pz), scatter: startPos.clone(), type: 1, speed: 0.06, offset: Math.random()
                 });
            }

            // 3. å¤´ (Head)
            addCluster(400, 13, 11, 0, 3.5, 2.5, 2, 1);

            // 4. è…¿ (Legs)
            // å‰å·¦
            addCluster(250, 8, -6, 2, 1.5, 5, 1, 2);
            // å‰å³
            addCluster(250, 8, -6, -2, 1.5, 5, 1, 2);
            // åå·¦
            addCluster(250, -8, -6, 2, 2, 6, 1.5, 2);
            // åå³
            addCluster(250, -8, -6, -2, 2, 6, 1.5, 2);

            // 5. å°¾å·´ (Tail)
            addCluster(300, -11, 2, 0, 4, 2, 1, 3);

            scene.add(particlesMesh);
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.02;

            const box = document.getElementById('status-box');
            if(STATE.mode === 'ASSEMBLE') {
                box.innerText = "ğŸ çŠ¶æ€ï¼šå¥”è·‘ (RUN)"; box.style.color = "#00ff00";
                box.style.borderColor = "#00ff00";
            } else {
                box.innerText = "ğŸŒŒ çŠ¶æ€ï¼šæ•£å¼€ (SCATTER)"; box.style.color = "#00ffff";
                box.style.borderColor = "#00ffff";
            }

            for(let i=0; i<particlesData.length; i++) {
                const d = particlesData[i];
                let target;

                if (STATE.mode === 'ASSEMBLE') {
                    // å¥”è·‘åŠ¨ç”»é€»è¾‘
                    let animHome = d.homeBase.clone();
                    
                    // è…¿éƒ¨åˆ’åŠ¨
                    if(d.type === 2) { 
                        // ç®€å•çš„æ­£å¼¦æ³¢æ‘†åŠ¨
                        // æ ¹æ® x åæ ‡åŒºåˆ†å‰åè…¿ï¼Œæ ¹æ® z åæ ‡åŒºåˆ†å·¦å³
                        let legPhase = (d.homeBase.x > 0 ? 0 : Math.PI) + (d.homeBase.z > 0 ? 0 : Math.PI/2);
                        animHome.x += Math.sin(time*5 + legPhase) * 2.5;
                        animHome.y += Math.cos(time*5 + legPhase) * 1.5;
                    } 
                    // å°¾å·´é£˜åŠ¨
                    else if(d.type === 3) {
                        animHome.x -= Math.sin(time*3)*1.0 + 1.0; // å¾€åé£˜
                        animHome.y += Math.cos(time*4)*0.5;
                    }
                    // èº«ä½“èµ·ä¼
                    else {
                        animHome.y += Math.sin(time*5) * 0.5;
                    }
                    
                    target = animHome;
                } else {
                    target = d.scatter;
                }

                // ç‰©ç†è¿åŠ¨ (Lerp)
                d.current.lerp(target, d.speed);

                dummy.position.copy(d.current);
                
                // ç²’å­è‡ªè½¬
                dummy.rotation.x += 0.02;
                dummy.rotation.y += 0.02;
                
                // æ•£å¼€æ—¶ç¨å¾®å¤§ä¸€ç‚¹
                let s = (STATE.mode === 'SCATTER') ? 0.8 : 0.5;
                dummy.scale.setScalar(s);
                
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate = true;

            // ç…§ç‰‡é€»è¾‘
            photosData.forEach(p => {
                let tgt;
                if(p.userData.focus) {
                    let v = new THREE.Vector3(0,0,-20).applyQuaternion(camera.quaternion);
                    tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position);
                } else {
                    if (STATE.mode === 'ASSEMBLE') tgt = p.userData.home;
                    else tgt = p.userData.scat;
                    p.lookAt(camera.position);
                }
                p.position.lerp(tgt, 0.05);
            });

            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        // --- æ‰‹åŠ¿è¯†åˆ« ---
        async function startAI() {
            if(typeof Hands === 'undefined') return;
            const video = document.getElementsByClassName('input_video')[0];
            const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            
            hands.onResults(res => {
                if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    STATE.handVisible = true;
                    const lm = res.multiHandLandmarks[0];
                    
                    // ç®€å•çš„æ•°æ‰‹æŒ‡ç®—æ³•
                    let count = 0;
                    if(lm[8].y < lm[6].y) count++; if(lm[12].y < lm[10].y) count++;
                    if(lm[16].y < lm[14].y) count++; if(lm[20].y < lm[18].y) count++;

                    const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;

                    if(pinch) {
                        if(photosData.length>0 && STATE.mode==='ASSEMBLE') {
                            photosData.forEach(p=>p.userData.focus=false);
                            photosData[photosData.length-1].userData.focus = true;
                        }
                    } else if(count >= 3) {
                        STATE.mode = 'SCATTER';
                        photosData.forEach(p=>p.userData.focus=false);
                    } else {
                        STATE.mode = 'ASSEMBLE';
                    }
                } else { STATE.handVisible = false; }
            });
            const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
            await cam.start();
        }

        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }
        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.encoding=THREE.sRGBEncoding;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8*aspect, 8), mat);
            const border = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.PlaneGeometry(8*aspect, 8)), new THREE.LineBasicMaterial({color:0xffd700}));
            mesh.add(border);
            mesh.position.set(0, 20, 0);
            mesh.userData = { home: new THREE.Vector3(0, 20, 0), scat: new THREE.Vector3((Math.random()-0.5)*150, (Math.random()-0.5)*100, (Math.random()-0.5)*150), focus: false };
            photoGroup.add(mesh); photosData.push(mesh);
        }
    </script>
</body>
</html>
