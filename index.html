<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Tree (Perfect V3.2)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #ffffff; pointer-events: none; user-select: none;
            text-shadow: 0 1px 3px rgba(0,0,0,0.9);
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; font-size: 24px; color: #d4af37; text-shadow: 0 0 15px rgba(212, 175, 55, 0.8); }
        /* V3.2 Ê†áÁ≠æ */
        .version-tag { font-size: 10px; color: #00ff00; margin-bottom: 10px; border: 1px solid #00ff00; display: inline-block; padding: 2px 5px; background: rgba(0,0,0,0.7);}
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #d4af37;
            flex-direction: column; transition: opacity 0.5s;
        }
        #start-btn {
            padding: 12px 30px; border: 1px solid #d4af37; background: rgba(212, 175, 55, 0.1);
            color: #d4af37; font-size: 16px; cursor: pointer; letter-spacing: 2px;
            transition: 0.3s; margin-top: 20px; display: none;
        }
        #start-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 20px #d4af37; }
        #loading-text { margin-top: 10px; color: #888; font-size: 14px; }
        
        #upload-btn {
            pointer-events: auto; background: rgba(50, 50, 50, 0.8);
            border: 1px solid #ffffff; color: #ffffff; padding: 8px 15px;
            cursor: pointer; margin-top: 15px; display: inline-block;
            font-size: 12px; border-radius: 4px; text-transform: uppercase;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
        
        #console-log { position: fixed; bottom: 0; left: 0; width: 100%; height: 100px; background: rgba(0,0,0,0.8); color: red; font-size: 10px; pointer-events: none; z-index: 999; overflow: auto; display: none; }
    </style>
</head>
<body>
    <div id="console-log"></div>
    <div id="loader">
        <div id="loading-text">Loading Assets...</div>
        <button id="start-btn">START CAMERA</button>
    </div>

    <div id="ui-layer">
        <h1>NOEL PARTICLES</h1>
        <div class="version-tag">Ver 3.2 (Perfect Photo & Controls)</div>
        <div class="status" id="gesture-status">Wait for start...</div>
        <div style="margin-top:5px; font-size:12px; color:#ccc; line-height: 1.4;">
            ‚úäFist: Tree | üñêOpen: Scatter (Move to rotate) <br>
            üëåPinch: Grab center photo
        </div>
        <label id="upload-btn">
            Upload Photos (Upload multiple!)
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        function log(msg) { const el = document.getElementById('console-log'); el.style.display='block'; el.innerHTML+=`> ${msg}<br>`; console.log(msg); }
        window.onload = function() {
            const startBtn = document.getElementById('start-btn'); const loadingText = document.getElementById('loading-text');
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') { log("Error: Not HTTPS."); loadingText.innerText="Please use HTTPS"; return; }
            loadingText.style.display = 'none'; startBtn.style.display = 'block';
            startBtn.addEventListener('click', () => {
                document.getElementById('loader').style.opacity = 0; setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                initThree(); startCamera(); 
            });
        };

        const CONFIG = { particleCount: 1800, treeHeight: 50, baseRadius: 18, colors: { green: 0x1a3322, gold: 0xffd700, red: 0xb30000 }, cameraZ: 70 };
        const STATE = { mode: 'TREE', handVisible: false, handX: 0.5, handY: 0.5, gesture: 'NONE' };
        let scene, camera, renderer, composer, particlesMesh, photoGroup, dummy = new THREE.Object3D();
        // Êñ∞Â¢ûÂ∞ÑÁ∫øÊ£ÄÊµãÂô®ÔºåÁî®‰∫éÁ≤æÁ°ÆÊäìÂèñ
        let raycaster = new THREE.Raycaster();
        const centerVector = new THREE.Vector2(0, 0); // Â±èÂπï‰∏≠ÂøÉÁÇπ
        const particlesData = [], photosData = [];

        function initThree() {
            try {
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                // ‰øùÊåÅÊ∑°ÈõæÔºåÂ¢ûÂä†Ê∑±ÈÇÉÊÑüÔºå‰ΩÜÁÖßÁâá‰ºöÂøΩÁï•ÂÆÉ
                scene.fog = new THREE.FogExp2(0x020202, 0.0008); 

                camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000); // Â¢ûÂä†ËßÜË∑ù
                camera.position.set(0, 12, CONFIG.cameraZ);
                camera.lookAt(0, 10, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.5; 
                container.appendChild(renderer.domElement);

                scene.add(new THREE.AmbientLight(0xffffff, 0.1));
                const l1 = new THREE.PointLight(CONFIG.colors.gold, 2.5, 150); l1.position.set(10,30,30); scene.add(l1);
                const l2 = new THREE.PointLight(CONFIG.colors.red, 1.5, 120); l2.position.set(-15,0,15); scene.add(l2);

                try {
                    const renderScene = new THREE.RenderPass(scene, camera);
                    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.8);
                    bloomPass.threshold = 0.7; bloomPass.strength = 0.8; bloomPass.radius = 0.3;
                    composer = new THREE.EffectComposer(renderer);
                    composer.addPass(renderScene);
                    composer.addPass(bloomPass);
                } catch(e) { log("Bloom skipped."); composer = null; }

                createParticles();
                photoGroup = new THREE.Group();
                scene.add(photoGroup);

                document.addEventListener('mousemove', e => {
                    if (!STATE.handVisible && STATE.mode === 'SCATTER') updateCameraFromInput(e.clientX/window.innerWidth, e.clientY/window.innerHeight);
                });
                document.addEventListener('click', e => {
                    if(['upload-btn', 'file-input', 'start-btn'].includes(e.target.id)) return;
                    if(!STATE.handVisible && photosData.length > 0) { STATE.mode = STATE.mode === 'TREE' ? 'SCATTER' : 'TREE'; }
                });

                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    if(composer) composer.setSize(window.innerWidth, window.innerHeight);
                });
                document.getElementById('file-input').addEventListener('change', handleImageUpload);
                animate();
            } catch(err) { log("3D Init Error: " + err.message); }
        }

        function createParticles() {
            const geo = new THREE.IcosahedronGeometry(0.4, 1);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.8 });
            particlesMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
            const col = new THREE.Color();
            for(let i=0; i<CONFIG.particleCount; i++) {
                const p = i/CONFIG.particleCount;
                const angle = p * Math.PI * 22; 
                const r = CONFIG.baseRadius * (1-p*p*0.8);
                const tx = Math.cos(angle)*r + (Math.random()-0.5)*2;
                const tz = Math.sin(angle)*r + (Math.random()-0.5)*2;
                const ty = (CONFIG.treeHeight*p) - CONFIG.treeHeight/2 + 5;
                let t = Math.random();
                if(t>0.65) col.setHex(t>0.9 ? CONFIG.colors.red : CONFIG.colors.gold); else col.setHex(CONFIG.colors.green);
                particlesMesh.setColorAt(i, col);
                dummy.position.set(tx, ty, tz);
                dummy.scale.setScalar(0.5+Math.random());
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
                // „Äê‰øÆÊîπ3ÔºöÂ§ßÂπÖÂ¢ûÂä†Êï£ÂºÄËåÉÂõ¥„ÄëÂçäÂæÑ‰ªé70Â¢ûÂä†Âà∞250ÔºåÊõ¥ÂπøÈòî
                particlesData.push({ idx: i, cur: new THREE.Vector3(tx,ty,tz), tree: new THREE.Vector3(tx,ty,tz), 
                    scat: new THREE.Vector3((Math.random()-0.5)*250, (Math.random()-0.5)*250, (Math.random()-0.5)*250), 
                    speed: 0.01+Math.random()*0.02 });
            }
            scene.add(particlesMesh);
        }

        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }

        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.generateMipmaps=true; tex.encoding = THREE.sRGBEncoding;
            const aspect = img.width/img.height;
            // „Äê‰øÆÊîπ1ÔºöÂΩªÂ∫ïÁßªÈô§Êª§Èïú„Äë‰ΩøÁî® BasicMaterialÔºåÂπ∂ËÆæÁΩÆ fog: false, toneMapped: false
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, fog: false, toneMapped: false });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(5*aspect, 5), mat);
            // „Äê‰øÆÊîπ2ÔºöÁôΩËâ≤ËæπÊ°Ü„ÄëÈ¢úËâ≤Êîπ‰∏∫ 0xffffff
            const frame = new THREE.Mesh(new THREE.BoxGeometry(5*aspect+0.2, 5.2, 0.1), new THREE.MeshStandardMaterial({color:0xffffff, roughness: 0.4, metalness: 0.2}));
            mesh.position.z = 0.06; frame.add(mesh);
            const ty = Math.random()*CONFIG.treeHeight - CONFIG.treeHeight/2 + 5;
            frame.position.set(0, ty, 20);
            // „Äê‰øÆÊîπ3ÔºöÂ§ßÂπÖÂ¢ûÂä†ÁÖßÁâáÊï£ÂºÄËåÉÂõ¥„Äë
            frame.userData = { tree: new THREE.Vector3((Math.random()-0.5)*10, ty, CONFIG.baseRadius+2), 
                scat: new THREE.Vector3((Math.random()-0.5)*300, (Math.random()-0.5)*200, (Math.random()-0.5)*300), 
                cur: frame.position.clone(), focus: false };
            photoGroup.add(frame); photosData.push(frame);
        }

        function animate() {
            requestAnimationFrame(animate);
            const targetState = STATE.mode; const time = Date.now() * 0.0005;
            for(let i=0; i<CONFIG.particleCount; i++) {
                const d = particlesData[i]; let tgt = (targetState==='TREE'||targetState==='ZOOM') ? d.tree : d.scat;
                if(targetState!=='TREE') d.cur.y += Math.sin(time+i*0.1)*0.01;
                d.cur.lerp(tgt, d.speed); dummy.position.copy(d.cur);
                if(targetState==='SCATTER') { dummy.rotation.x+=0.005; dummy.rotation.y+=0.008; } else dummy.rotation.set(0,0,0);
                dummy.updateMatrix(); particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate=true;
            photosData.forEach(p => {
                const d = p.userData; let tgt = (targetState==='TREE') ? d.tree : d.scat; let scale = 1;
                if(d.focus) {
                    const v = new THREE.Vector3(0,0,-15).applyQuaternion(camera.quaternion); tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position); scale=3.0; // ÊîæÂ§ßÂÄçÊï∞Â¢ûÂä†
                } else {
                    if(targetState!=='TREE') p.lookAt(camera.position); else p.lookAt(tgt.x*2, tgt.y, tgt.z*2);
                }
                d.cur.lerp(tgt, 0.04); p.position.copy(d.cur); p.scale.lerp(new THREE.Vector3(scale,scale,scale), 0.1);
            });
            if(STATE.mode==='SCATTER' && STATE.handVisible) updateCameraFromInput(STATE.handX, STATE.handY);
            else if(STATE.mode==='TREE') { camera.position.lerp(new THREE.Vector3(0,12,CONFIG.cameraZ), 0.03); camera.lookAt(0,10,0); }
            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        function updateCameraFromInput(x, y) {
            // „Äê‰øÆÊîπ4ÔºöÂ§ßÂπÖÂ¢ûÂä†ÊóãËΩ¨ËåÉÂõ¥„ÄëÊ∞¥Âπ≥ÂíåÂûÇÁõ¥Á≥ªÊï∞ÁøªÂÄç
            const theta = (x-0.5) * 6 * Math.PI; // Ê∞¥Âπ≥ËåÉÂõ¥Êõ¥Â§ß
            const phi = (1-y) * Math.PI * 0.6 + 0.2; // ÂûÇÁõ¥ËåÉÂõ¥Êõ¥Â§ß
            const r = CONFIG.cameraZ * 1.2; // Êï£ÂºÄÊó∂Áõ∏Êú∫Á®çËøú
            const cx = r * Math.sin(theta) * Math.sin(phi);
            const cz = r * Math.cos(theta) * Math.sin(phi);
            const cy = r * Math.cos(phi) + 10;
            camera.position.lerp(new THREE.Vector3(cx, cy, cz), 0.05);
            camera.lookAt(0, 10, 0);
        }

        async function startCamera() {
            log("Init AI..."); const video = document.getElementsByClassName('input_video')[0];
            try {
                if(typeof Hands === 'undefined') throw new Error("Hands lib missing");
                const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
                hands.onResults(onResults);
                const camera = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
                await camera.start(); document.getElementById('gesture-status').innerText = "AI Active!"; log("Camera Started");
            } catch(e) { log("Cam Fail: " + e.message); document.getElementById('gesture-status').innerText = "Cam Failed. Mouse Mode."; }
        }

        function onResults(res) {
            const status = document.getElementById('gesture-status');
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                STATE.handVisible = true; const lm = res.multiHandLandmarks[0];
                // Â¢ûÂä†Âπ≥ÊªëÂ§ÑÁêÜÔºåÈò≤Ê≠¢Áõ∏Êú∫ÊäñÂä®
                STATE.handX = STATE.handX * 0.8 + (1 - lm[0].x) * 0.2; 
                STATE.handY = STATE.handY * 0.8 + lm[0].y * 0.2;
                const tips=[8,12,16,20], bases=[5,9,13,17]; let open=0;
                tips.forEach((t,i) => { if(Math.hypot(lm[t].x-lm[0].x, lm[t].y-lm[0].y) > Math.hypot(lm[bases[i]].x-lm[0].x, lm[bases[i]].y-lm[0].y)*1.3) open++; });
                if(Math.hypot(lm[4].x-lm[0].x, lm[4].y-lm[0].y)>0.15) open++;
                const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.04; // ÊçèÂêàÈòàÂÄºÂæÆË∞É

                if(pinch) { 
                    STATE.gesture='PINCH'; status.innerText="üëå Pinch (Grabbing Center)"; 
                    // „Äê‰øÆÊîπ3ÔºöÂÖ®Êñ∞ÊäìÂèñÊú∫Âà∂„ÄëÂ∞ÑÁ∫øÊ£ÄÊµã
                    raycastGrab();
                }
                else if(open<=1) { STATE.gesture='FIST'; STATE.mode='TREE'; resetPhoto(); status.innerText="‚úä Fist (Tree)"; }
                else if(open>=4) { 
                    STATE.gesture='OPEN'; 
                    if(STATE.mode==='ZOOM' && !pinch) { STATE.mode='SCATTER'; resetPhoto(); }
                    else if(STATE.mode!=='ZOOM') STATE.mode='SCATTER';
                    status.innerText="üñê Open (Scatter)"; 
                }
            } else { STATE.handVisible = false; status.innerText = "No Hand Detected"; }
        }

        // „Äê‰øÆÊîπ3ÔºöÂÖ®Êñ∞ÊäìÂèñÊú∫Âà∂„Äë‰ΩøÁî® Raycaster ÊäìÂèñÂ±èÂπï‰∏≠ÂøÉÁúãÂà∞ÁöÑÂØπË±°
        function raycastGrab() {
            if(STATE.mode === 'ZOOM' || photosData.length === 0) return;
            // ‰ªéÂ±èÂπï‰∏≠ÂøÉÂèëÂ∞ÑÂ∞ÑÁ∫ø
            raycaster.setFromCamera(centerVector, camera);
            // Ê£ÄÊµãÂ∞ÑÁ∫øÊòØÂê¶Âáª‰∏≠‰∫ÜÁÖßÁâáÁªÑ‰∏≠ÁöÑ‰ªª‰Ωï‰∏Ä‰∏™
            const intersects = raycaster.intersectObjects(photoGroup.children, true);
            if (intersects.length > 0) {
                // intersects[0] Â∞±ÊòØÁ¶ªÁõ∏Êú∫ÊúÄËøë„ÄÅ‰∏îÂú®ÁîªÈù¢‰∏≠ÂøÉÁöÑÈÇ£‰∏™
                const targetFrame = intersects[0].object.parent; // Ëé∑ÂèñÁà∂Á∫ß Frame Mesh
                if(targetFrame && targetFrame.userData) {
                    resetPhoto();
                    STATE.mode='ZOOM'; targetFrame.userData.focus=true;
                    document.getElementById('gesture-status').innerText = "Got it!";
                }
            }
        }
        function resetPhoto() { photosData.forEach(p=>p.userData.focus=false); }
    </script>
</body>
</html>
