<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPIC å·¥ä¸šè§†ç•Œ (V19 Stable Core)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: "Microsoft YaHei", sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #ffffff; pointer-events: none; user-select: none;
            text-shadow: 0 1px 3px rgba(0,0,0,0.9);
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 4px; font-size: 24px; color: #d4af37; text-shadow: 0 0 15px rgba(212, 175, 55, 0.8); }
        
        .status-tag { font-size: 14px; color: #00ffea; margin-top: 10px; border: 1px solid #00ffea; display: inline-block; padding: 4px 10px; background: rgba(0,0,0,0.6); border-radius: 20px;}
        
        #controls-hint { margin-top: 10px; font-size: 12px; color: #aaa; line-height: 1.6; }
        
        #upload-btn {
            pointer-events: auto; background: linear-gradient(90deg, #b30000, #d4af37);
            border: none; color: #ffffff; padding: 10px 20px;
            cursor: pointer; margin-top: 20px; display: inline-block;
            font-size: 12px; border-radius: 30px; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3); transition: 0.3s;
        }
        #upload-btn:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(212, 175, 55, 0.6); }
        input[type="file"] { display: none; }
        
        .input_video { display: none; }
        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 999; display: flex; justify-content: center; align-items: center; color: #00ffff; font-size: 18px; transition: opacity 0.5s; }
    </style>
</head>
<body>

    <div id="loader">ç³»ç»Ÿå¯åŠ¨ä¸­...</div>

    <div id="ui-layer">
        <h1 id="scene-title">ğŸ æˆ˜é©¬å½¢æ€</h1>
        <div class="status-tag" id="gesture-status">ç­‰å¾…æ‘„åƒå¤´/é¼ æ ‡...</div>
        <div id="controls-hint">
            âœŠæ¡æ‹³: åˆ‡æ¢åœºæ™¯ (é©¬/å¡”/é£å…‰/å­—)<br>
            ğŸ–å¼ å¼€: æ•£å¼€ (ç…§ç‰‡ç”»å»Š)<br>
            ğŸ‘Œæåˆ: æŠ“å–ç…§ç‰‡ (æˆ–ç‚¹å‡»é¼ æ ‡)
        </div>
        <label id="upload-btn">
            + æ³¨å…¥ç…§ç‰‡ (Gallery)
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="genCanvas" width="1024" height="512" style="display:none;"></canvas>

    <script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.staticfile.org/three.js/r128/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- æˆ˜é©¬éª¨éª¼å…³é”®ç‚¹ (ç¡¬ç¼–ç ï¼Œç¡®ä¿æ— éœ€ä¸‹è½½æ¨¡å‹) ---
        const HORSE_PTS = [
            0,20,10, 5,20,8, 10,22,5, 15,25,0, 20,28,-2, 25,20,-2, 28,15,-3, 20,5,0, 15,0,2, 
            -5,18,12, -15,18,10, -25,10,5, -5,5,10, -15,5,8, -20,8,5, 
            5,-10,5, 5,-30,5, -20,-10,5, -25,-30,8, -35,10,5,
            // è¡¥å……ç‚¹ï¼Œè®©é©¬æ›´ä¸°æ»¡
            0,15,8, -10,12,8, -20,0,5, 5,-5,5
        ];

        // --- é…ç½® ---
        const CONFIG = { 
            particleCount: 18000, 
            cameraZ: 100, 
            colors: { 
                horse: [0xD4AF37, 0xC41E3A, 0xFF4500], 
                tower: [0x00BFFF, 0xFFFFFF, 0x228B22],
                wind: [0x00FF7F, 0xF0FFFF],
                text: [0x88CCFF]
            } 
        };

        const STATE = { 
            mode: 'SHAPE', // SHAPE, SCATTER, ZOOM
            shapeIdx: 0,   // 0:é©¬, 1:å¡”, 2:é£å…‰, 3:æ–‡å­—
            handVisible: false, 
            handX: 0.5, handY: 0.5,
            autoRotate: 0
        };

        // å…¨å±€å˜é‡
        let scene, camera, renderer, composer;
        let particlesMesh, photoGroup, dummy = new THREE.Object3D();
        let raycaster = new THREE.Raycaster();
        let particlesData = [], photosData = [];
        
        // ä½ çš„é˜²æ™•ç›¸æœºå˜é‡
        let lookAtTarget = new THREE.Vector3(0, 0, 0);
        let currentLookAt = new THREE.Vector3(0, 0, 0);

        // å½¢æ€æ•°æ®ç¼“å­˜
        const SHAPES = { HORSE:[], TOWER:[], SCENE:[], TEXT:[], SCATTER:[] };

        // å¯åŠ¨
        window.onload = () => {
            initThree();
            generateAllData(); // ç”Ÿæˆæ•°æ®
            createParticles(); // åˆ›å»ºç²’å­
            startCamera();     // å¯åŠ¨AI
            document.getElementById('loader').style.display = 'none';
        };

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.0015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, CONFIG.cameraZ);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false }); // æ€§èƒ½ä¼˜åŒ–
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            // ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
            const l1 = new THREE.PointLight(0xffd700, 1.5, 200); l1.position.set(50,50,50); scene.add(l1);
            const l2 = new THREE.PointLight(0x00ffff, 1.5, 200); l2.position.set(-50,0,50); scene.add(l2);

            // åå¤„ç†
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.2; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            } catch(e) { console.log("Bloom disabled"); }

            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            // äº‹ä»¶
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if(composer) composer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // é¼ æ ‡ä½œä¸ºå¤‡ç”¨äº¤äº’
            document.addEventListener('mousemove', e => {
                if(!STATE.handVisible) {
                    STATE.handX = e.clientX/window.innerWidth;
                    STATE.handY = e.clientY/window.innerHeight;
                }
            });
            document.addEventListener('click', (e) => {
                if(e.target.id === 'upload-btn') return;
                if(STATE.mode === 'ZOOM') {
                    STATE.mode = 'SCATTER'; resetPhoto(); updateUI("ğŸ– é‡Šæ”¾ç…§ç‰‡");
                } else if(STATE.mode === 'SCATTER') {
                    // å°è¯•æŠ“å–
                    raycastGrab();
                } else {
                    // åˆ‡æ¢åœºæ™¯
                    STATE.shapeIdx = (STATE.shapeIdx+1)%4;
                    updateSceneInfo();
                }
            });
            document.getElementById('file-input').addEventListener('change', handleImageUpload);

            animate();
        }

        // --- æ ¸å¿ƒï¼šç¨‹åºåŒ–ç”Ÿæˆæ•°æ® (æ— æ¨¡å‹ä¸‹è½½) ---
        function generateAllData() {
            // 1. æˆ˜é©¬ (éª¨éª¼æ’å€¼)
            const horse = [];
            for(let i=0; i<CONFIG.particleCount; i++) {
                const idx1 = Math.floor(Math.random()*(HORSE_PTS.length/3))*3;
                const idx2 = Math.floor(Math.random()*(HORSE_PTS.length/3))*3;
                const t = Math.random();
                let x = HORSE_PTS[idx1] + (HORSE_PTS[idx2]-HORSE_PTS[idx1])*t;
                let y = HORSE_PTS[idx1+1] + (HORSE_PTS[idx2+1]-HORSE_PTS[idx1+1])*t;
                let z = HORSE_PTS[idx1+2] + (HORSE_PTS[idx2+2]-HORSE_PTS[idx1+2])*t;
                // æ‰©å……ä½“ç§¯
                x += (Math.random()-0.5)*10; y += (Math.random()-0.5)*10; z += (Math.random()-0.5)*6;
                horse.push(new THREE.Vector3(x*1.5, y*1.5, z*1.5));
            }
            SHAPES.HORSE = horse;

            // 2. å‡‰æ°´å¡” (åŒæ›²çº¿)
            const tower = [];
            const H = 80;
            for(let i=0; i<CONFIG.particleCount; i++) {
                const r = i/CONFIG.particleCount;
                const y = (r-0.5)*H;
                const v = (y+H/2)/H; 
                let rad = 20 * Math.sqrt(1 + Math.pow(v*2.2-1.3, 2)*0.6);
                if(r>0.95) rad = Math.random()*30; // è’¸æ±½
                const ang = r*Math.PI*120;
                tower.push(new THREE.Vector3(Math.cos(ang)*rad, y, Math.sin(ang)*rad));
            }
            SHAPES.TOWER = tower;

            // 3. é£å…‰äº’è¡¥
            const scene = [];
            const addFan = (ox, oz, s) => {
                const h = 60*s;
                for(let k=0; k<1500; k++) { // æŸ±
                    scene.push(new THREE.Vector3(ox+(Math.random()-0.5)*3, (Math.random()-0.5)*h, oz+(Math.random()-0.5)*3));
                }
                for(let b=0; b<3; b++) { // å¶ç‰‡
                    const ang = b/3*6.28;
                    for(let k=0; k<500; k++) {
                        const l = Math.random()*35*s;
                        scene.push(new THREE.Vector3(ox+Math.cos(ang)*l, h/2+Math.sin(ang)*l, oz));
                    }
                }
            };
            addFan(-30, -15, 1.2); addFan(30, 15, 0.8);
            const remain = CONFIG.particleCount - scene.length;
            for(let i=0; i<remain; i++) { // å…‰ä¼
                const c = Math.floor(Math.random()*10); const r = Math.floor(Math.random()*5);
                scene.push(new THREE.Vector3((c-5)*12, -40, (r-2)*10+30));
            }
            SHAPES.SCENE = scene;

            // 4. æ–‡å­—
            SHAPES.TEXT = createTextPoints("é£å…‰æ— é™  å›½å®¶ç”µæŠ•");

            // 5. æ•£å¼€
            for(let i=0; i<CONFIG.particleCount; i++) {
                SHAPES.SCATTER.push(new THREE.Vector3((Math.random()-0.5)*250, (Math.random()-0.5)*200, (Math.random()-0.5)*250));
            }
        }

        function createTextPoints(txt) {
            const c=document.getElementById('genCanvas').getContext('2d');
            c.clearRect(0,0,1024,512); c.font="bold 120px 'Microsoft YaHei'"; 
            c.fillStyle="#fff"; c.textAlign="center"; c.textBaseline="middle"; 
            c.fillText(txt,512,256);
            const d=c.getImageData(0,0,1024,512).data; const v=[]; const pts=[];
            for(let y=0;y<512;y+=4)for(let x=0;x<1024;x+=4)if(d[(y*1024+x)*4+3]>100)v.push({x,y});
            for(let i=0;i<CONFIG.particleCount;i++){const p=v[i%v.length]; pts.push(new THREE.Vector3((p.x-512)*0.15, -(p.y-256)*0.15, 0));}
            return pts;
        }

        function createParticles() {
            const geo = new THREE.IcosahedronGeometry(0.2, 0); // ä½æ¨¡ç²’å­
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.8 });
            particlesMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
            
            const col = new THREE.Color();
            for(let i=0; i<CONFIG.particleCount; i++) {
                dummy.position.copy(SHAPES.SCATTER[i]);
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
                
                // åˆå§‹æ•°æ®
                particlesData.push({ 
                    cur: SHAPES.SCATTER[i].clone(), 
                    target: SHAPES.HORSE[i], // é»˜è®¤ç›®æ ‡
                    speed: 0.02 + Math.random()*0.04 
                });
            }
            scene.add(particlesMesh);
            updateSceneInfo(); // åˆå§‹åŒ–é¢œè‰²
        }

        // --- é€»è¾‘ ---
        function updateSceneInfo() {
            const title = document.getElementById('scene-title');
            const status = document.getElementById('gesture-status');
            let colors;
            
            if(STATE.shapeIdx===0) { title.innerText="ğŸ æˆ˜é©¬å½¢æ€ (çº¢é‡‘)"; colors=CONFIG.colors.horse; }
            else if(STATE.shapeIdx===1) { title.innerText="ğŸ­ å‡‰æ°´å¡” (å½©ç»˜)"; colors=CONFIG.colors.tower; }
            else if(STATE.shapeIdx===2) { title.innerText="âš¡ é£å…‰äº’è¡¥"; colors=CONFIG.colors.wind; }
            else { title.innerText="ğŸ’ å“ç‰Œæ„¿æ™¯"; colors=CONFIG.colors.text; }

            // æ›´æ–°ç²’å­ç›®æ ‡å’Œé¢œè‰²
            const targetShape = [SHAPES.HORSE, SHAPES.TOWER, SHAPES.SCENE, SHAPES.TEXT][STATE.shapeIdx];
            
            for(let i=0; i<CONFIG.particleCount; i++) {
                particlesData[i].target = targetShape[i];
                
                // ç®€å•çš„é¢œè‰²åˆ†é…
                const cHex = colors[Math.floor(Math.random()*colors.length)];
                const col = new THREE.Color(cHex);
                particlesMesh.setColorAt(i, col);
            }
            particlesMesh.instanceColor.needsUpdate = true;
            status.innerText = "åœºæ™¯å·²åˆ‡æ¢";
        }

        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            photosData.forEach(p => photoGroup.remove(p.mesh)); photosData = [];
            
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => {
                    const img = new Image(); img.src = ev.target.result;
                    img.onload = () => createPhoto(img);
                };
                r.readAsDataURL(f);
            });
            
            // è‡ªåŠ¨åˆ‡åˆ°æ•£å¼€æ¨¡å¼
            STATE.mode = 'SCATTER';
            document.getElementById('gesture-status').innerText = `å·²åŠ è½½ ${files.length} å¼ ç…§ç‰‡`;
        }

        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; 
            const ar = img.width/img.height;
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8*ar, 8), new THREE.MeshBasicMaterial({map:tex, side:THREE.DoubleSide}));
            const frame = new THREE.Mesh(new THREE.BoxGeometry(8*ar+0.2, 8.2, 0.1), new THREE.MeshBasicMaterial({color:0xffffff}));
            mesh.position.z = 0.06; frame.add(mesh);
            
            // æ•£å¼€ä½ç½® (åœ†ç¯)
            const angle = Math.random() * Math.PI * 2;
            const r = 60 + Math.random()*20;
            const scat = new THREE.Vector3(Math.cos(angle)*r, (Math.random()-0.5)*40, Math.sin(angle)*r);
            
            frame.position.copy(scat);
            frame.lookAt(0,0,0);
            
            photoGroup.add(frame);
            photosData.push({ mesh:frame, cur:scat.clone(), scat:scat, focus:false, baseRot:frame.rotation.clone() });
        }

        // --- æ ¸å¿ƒåŠ¨ç”» (Lerp + Anti-Dizzy) ---
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            // 1. ç²’å­è¿åŠ¨
            for(let i=0; i<CONFIG.particleCount; i++) {
                const d = particlesData[i];
                let tgt = (STATE.mode==='SHAPE') ? d.target : SHAPES.SCATTER[i];
                
                // æ•£å¼€æ—¶åŠ ç‚¹æ¼‚æµ®
                if(STATE.mode !== 'SHAPE') {
                    tgt = SHAPES.SCATTER[i].clone();
                    tgt.y += Math.sin(time + i*0.1) * 5;
                }

                d.cur.lerp(tgt, d.speed);
                dummy.position.copy(d.cur);
                // ç²’å­æœ¬èº«ä¸æ—‹è½¬ï¼Œä¿æŒé«˜æ€§èƒ½
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate = true;

            // 2. ç…§ç‰‡è¿åŠ¨
            if(STATE.mode === 'SCATTER' || STATE.mode === 'ZOOM') {
                // è‡ªåŠ¨æ—‹è½¬ç”»å»Š
                if(STATE.mode === 'SCATTER' && !STATE.handVisible) STATE.autoRotate += 0.002;
                if(STATE.handVisible) STATE.autoRotate += (STATE.handX - 0.5) * 0.05;

                photosData.forEach((p, i) => {
                    let tgt;
                    let scale = 1;
                    
                    if(p.focus) {
                        // æŠ“å–ï¼šé£åˆ°çœ¼å‰
                        const v = new THREE.Vector3(0,0,-15).applyQuaternion(camera.quaternion);
                        tgt = camera.position.clone().add(v);
                        p.mesh.lookAt(camera.position);
                        scale = 2.5;
                    } else {
                        // æ•£å¼€ï¼šåœ†ç¯å¸ƒå±€ + æ—‹è½¬
                        const total = photosData.length;
                        const angle = (i/total)*Math.PI*2 + STATE.autoRotate;
                        const r = 70;
                        tgt = new THREE.Vector3(Math.cos(angle)*r, p.scat.y, Math.sin(angle)*r);
                        p.mesh.lookAt(0,0,0); // é¢å‘ä¸­å¿ƒ
                    }
                    
                    p.cur.lerp(tgt, 0.05);
                    p.mesh.position.copy(p.cur);
                    p.mesh.scale.lerp(new THREE.Vector3(scale,scale,scale), 0.1);
                });
            } else {
                // éšè—ç…§ç‰‡
                photosData.forEach(p => p.mesh.position.set(0,-1000,0));
            }

            // 3. ç›¸æœº (Anti-Dizzy)
            if(STATE.mode === 'SCATTER' || STATE.mode === 'SHAPE') {
                const tx = (STATE.handX - 0.5) * 30; // å·¦å³å¾®åŠ¨
                const ty = (STATE.handY - 0.5) * 20;
                
                // ç›®æ ‡æ˜¯çœ‹å‘ä¸­å¿ƒï¼Œä½†å¸¦ä¸€ç‚¹åç§»
                lookAtTarget.set(tx, ty, 0);
                currentLookAt.lerp(lookAtTarget, 0.05);
                camera.lookAt(currentLookAt);
                
                // ç›¸æœºä½ç½®è½»å¾®æµ®åŠ¨
                camera.position.lerp(new THREE.Vector3(tx*0.5, ty*0.5, CONFIG.cameraZ), 0.05);
            }

            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        // --- äº¤äº’ ---
        function raycastGrab() {
            if(STATE.mode === 'ZOOM' || photosData.length === 0) return;
            
            // ä½ çš„ V3.4 é€»è¾‘ï¼šä¼˜å…ˆå¸é™„ä¸­å¿ƒ
            let closest = null; let minAngle = Infinity;
            const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
            
            photosData.forEach(p => {
                const toPhoto = p.mesh.position.clone().sub(camera.position).normalize();
                const angle = camDir.angleTo(toPhoto);
                // åªè¦åœ¨è§†é‡ä¸­å¿ƒ 20åº¦ ä»¥å†…
                if(angle < 0.4 && angle < minAngle) { minAngle = angle; closest = p; }
            });
            
            if(closest) {
                resetPhoto();
                STATE.mode = 'ZOOM';
                closest.focus = true;
                document.getElementById('gesture-status').innerText = "å·²æŠ“å– (å¼ æ‰‹é‡Šæ”¾)";
            }
        }

        function resetPhoto() { photosData.forEach(p => p.focus = false); }
        function updateUI(msg) { document.getElementById('gesture-status').innerText = msg; }

        // --- AI ---
        async function startCamera() {
            try {
                const video = document.getElementsByClassName('input_video')[0];
                const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
                hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6});
                hands.onResults(res => {
                    if(res.multiHandLandmarks.length) {
                        STATE.handVisible = true;
                        const lm = res.multiHandLandmarks[0];
                        STATE.handX = STATE.handX*0.8 + (1-lm[9].x)*0.2;
                        STATE.handY = STATE.handY*0.8 + lm[9].y*0.2;

                        const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;
                        let open=0; [8,12,16,20].forEach(t=>{if(lm[t].y<lm[t-2].y)open++});

                        if(pinch) {
                            if(STATE.mode==='SCATTER') raycastGrab();
                        } else if(open>=4) {
                            if(STATE.mode==='ZOOM') { STATE.mode='SCATTER'; resetPhoto(); updateUI("ğŸ– ç…§ç‰‡ç”»å»Š"); }
                            else if(STATE.mode==='SHAPE') { STATE.mode='SCATTER'; updateUI("ğŸ– ç…§ç‰‡ç”»å»Š"); }
                        } else if(open<=1) {
                            if(STATE.mode==='SCATTER') {
                                STATE.mode='SHAPE';
                                STATE.shapeIdx = (STATE.shapeIdx+1)%4;
                                updateSceneInfo();
                            }
                        }
                    } else {
                        STATE.handVisible = false;
                    }
                });
                const cam = new Camera(video, {onFrame: async()=>{await hands.send({image:video})}, width:480, height:360});
                await cam.start();
                updateUI("æ‘„åƒå¤´å·²æ¿€æ´»");
            } catch(e) {
                console.log("Camera failed", e);
                updateUI("æ‘„åƒå¤´ä¸å¯ç”¨ï¼Œè¯·ä½¿ç”¨é¼ æ ‡");
            }
        }
    </script>
</body>
</html>
