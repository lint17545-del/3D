<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D Interactive Masterpiece</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Microsoft YaHei', sans-serif; }
        
        /* è§†é¢‘æ¡†ä¼˜åŒ–ï¼šç¨å¾®é€æ˜ä¸€ç‚¹ï¼Œä¸æŒ¡è§†çº¿ */
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 1px solid rgba(0, 255, 255, 0.3); border-radius: 8px; opacity: 0.4; }
        
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 28px; color: #fff; letter-spacing: 4px; text-shadow: 0 0 10px rgba(0, 150, 255, 0.8); font-weight: 300; }
        .status { font-size: 16px; color: rgba(255,255,255,0.9); margin-top: 10px; font-weight: bold; letter-spacing: 1px;}
        .cycle-info { font-size: 20px; margin-top: 5px; color: #FFD700; text-shadow: 0 0 10px #FFD700; }
        
        #upload-container { pointer-events: auto; display: inline-block; margin-top: 15px; }
        input[type="file"] { display: none; }
        .btn { 
            background: rgba(0, 255, 255, 0.1); 
            border: 1px solid #00FFFF; 
            padding: 10px 20px; 
            color: #00FFFF; 
            font-size: 14px;
            cursor: pointer; 
            border-radius: 30px; 
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .btn:hover { background: #00FFFF; color: #000; box-shadow: 0 0 20px #00FFFF; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00FFFF; z-index: 20; font-size: 18px; text-align: center; letter-spacing: 2px; text-shadow: 0 0 10px #00FFFF; }
        
        #hint { position: absolute; bottom: 40px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 14px; letter-spacing: 2px; pointer-events: none; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨æ„å»ºé«˜ç²¾åº¦æ¨¡å‹ä¸Logoç®—æ³•...</div>
    
    <div id="ui-layer">
        <h1>ç²’å­å™äº‹ Â· å¿µåŠ›æ“æ§</h1>
        <div class="cycle-info" id="shape-name">ğŸ æˆ˜é©¬å½¢æ€</div>
        <div class="status" id="status-text">ç­‰å¾…æ‰‹åŠ¿...</div>
        
        <div id="upload-container">
            <label class="btn">
                + æ³¨å…¥ç…§ç‰‡è®°å¿† (Max 30)
                <input type="file" id="file-input" multiple accept="image/*">
            </label>
        </div>
    </div>
    
    <div id="hint">âœŠæ¡æ‹³: å¿µåŠ›é”å®š(è·Ÿéšæ—‹è½¬) | ğŸ–å¼ å¼€: çˆ†å‘æ•£å¼€ | ğŸ‘Œæåˆ: æŠ“å–è®°å¿†</div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="textCanvas" width="2048" height="512" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- æ ¸å¿ƒé…ç½® ---
        const CONFIG = {
            particleCount: 8000, // å¢åŠ ç²’å­æ•°ä»¥è·å¾—æ›´å¥½çš„Logoå’Œæ–‡å­—æ¸…æ™°åº¦
            maxPhotos: 30,
            colors: {
                horse: [0x0F52BA, 0xFFD700, 0xC41E3A], // è“é‡‘çº¢
                text:  [0x88CCFF, 0xAAFFFF, 0x0088FF]  // æ˜Ÿå…‰è“ä½“ç³»
            },
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb'
        };

        // --- å…¨å±€çŠ¶æ€ ---
        let scene, camera, renderer, composer;
        let particles = [];
        let group;
        let state = 'CONVERGED'; // CONVERGED, DISPERSED, ZOOM
        let time = 0;
        
        // äº¤äº’å˜é‡
        let handPosition = { x: 0.5, y: 0.5 };
        let targetRotation = { x: 0, y: 0 };
        let activeZoomParticle = null;
        let isHandClosed = false; // ç”¨äºåˆ¤å®šæ˜¯å¦å¤„äºâ€œå¿µåŠ›é”å®šâ€çŠ¶æ€

        // å½¢æ€å¾ªç¯ç³»ç»Ÿ
        let currentShapeIndex = 0; 
        const SHAPES = {
            HORSE: [],
            TEXT: [],
            LOGO: []
        };
        let pendingShapeChange = false; // æ•£å¼€åæ˜¯å¦å‡†å¤‡å¥½åˆ‡æ¢

        init();
        animate();
        initMediaPipe();

        async function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.001); // æ›´æ·±é‚ƒçš„èƒŒæ™¯

            // ç›¸æœºä½ç½®
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 0, 350);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç¯å…‰ç³»ç»Ÿä¼˜åŒ–ï¼šä¸ºäº†è®©æ–‡å­—å’Œlogoæ›´é€äº®
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);
            const spotLight = new THREE.SpotLight(0xffffff, 2);
            spotLight.position.set(100, 100, 100);
            scene.add(spotLight);
            const blueLight = new THREE.PointLight(0x0088ff, 1, 300);
            blueLight.position.set(-50, 0, 50);
            scene.add(blueLight);

            // åå¤„ç† (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.3;
            bloomPass.radius = 0.4;
            bloomPass.threshold = 0.1;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç”Ÿæˆæ•°æ®
            await generateAllShapes();
            createParticles();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            document.getElementById('loading').style.display = 'none';
        }

        // --- 1. å½¢çŠ¶ç”Ÿæˆç®—æ³• ---
        async function generateAllShapes() {
            // A. é©¬
            await new Promise(resolve => {
                new GLTFLoader().load(CONFIG.modelUrl, (gltf) => {
                    const positions = getPointsFromMesh(gltf.scene.children[0], CONFIG.particleCount, 1.2);
                    centerPoints(positions);
                    SHAPES.HORSE = positions;
                    resolve();
                });
            });

            // B. æ–‡å­— "é£å…‰æ— é™ å›½å®¶ç”µæŠ•" (å•è¡Œ + ç»ç’ƒè´¨æ„Ÿ)
            SHAPES.TEXT = generateTextPoints("é£å…‰æ— é™  å›½å®¶ç”µæŠ•", CONFIG.particleCount);

            // C. Logo (Så½¢çº¢ç»¿ä¸å¸¦) - å‚æ•°åŒ–ç”Ÿæˆ
            SHAPES.LOGO = generateCustomLogo(CONFIG.particleCount);
        }

        function generateCustomLogo(count) {
            const points = [];
            // æˆ‘ä»¬ç”¨å‚æ•°æ–¹ç¨‹æ¨¡æ‹Ÿä¸€ä¸ªç«‹ä½“ S å½¢ä¸å¸¦
            // åˆ†ä¸ºä¸¤æ®µï¼šç»¿è‰²ä¸Šæ®µï¼Œçº¢è‰²ä¸‹æ®µ
            
            for(let i=0; i<count; i++) {
                const t = (i / count) * Math.PI * 2; // 0 to 2PI
                
                // è¿™æ˜¯ä¸€ä¸ªæ‰­æ›²çš„ç¯å½¢å¸¦çŠ¶å…¬å¼ (MÃ¶bius strip å˜ä½“)
                // x, y å®šä¹‰ S å½¢è·¯å¾„
                let u = (i / count); // 0 to 1
                let angle = u * Math.PI * 2; // ä¸€åœˆ
                
                // åŸºç¡€è·¯å¾„ï¼šSå½¢
                let x = Math.sin(angle) * 60;
                let y = Math.cos(angle * 0.5) * 50; // 0.5é¢‘ç‡äº§ç”Ÿ8å­—/Så½¢
                let z = Math.sin(angle * 2) * 20;   // Zè½´æ‰­æ›²å¢åŠ ç«‹ä½“æ„Ÿ

                // å¢åŠ å®½åº¦ (Ribbon width)
                let width = (Math.random() - 0.5) * 35;
                let dx = Math.cos(angle) * width;
                let dy = Math.sin(angle) * width * 0.2;

                points.push(new THREE.Vector3(x + dx, y + dy, z));
            }
            return points;
        }

        function generateTextPoints(text, count) {
            const canvas = document.getElementById('textCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,2048,512);
            ctx.font = "900 180px 'Microsoft YaHei'"; // æ›´ç²—æ›´å¤§çš„å­—ä½“
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 1024, 256);

            const data = ctx.getImageData(0,0,2048,512).data;
            const points = [];
            
            // æ‰«æ
            for(let y=0; y<512; y+=4) {
                for(let x=0; x<2048; x+=4) {
                    if(data[(y*2048+x)*4+3] > 128) {
                        const px = (x - 1024) * 0.35;
                        const py = -(y - 256) * 0.35;
                        // å¢åŠ åšåº¦ï¼Œå½¢æˆâ€œæ°´æ™¶å—â€æ„Ÿè§‰
                        for(let k=0; k<2; k++) {
                            points.push(new THREE.Vector3(px, py, (Math.random()-0.5)*15));
                        }
                    }
                }
            }
            // é‡‡æ ·åˆ°ç›®æ ‡æ•°é‡
            return samplePoints(points, count);
        }

        function getPointsFromMesh(mesh, count, scale) {
            const points = [];
            const posAttr = mesh.geometry.attributes.position;
            const temp = new THREE.Vector3();
            for(let i=0; i<posAttr.count; i++) {
                temp.fromBufferAttribute(posAttr, i).multiplyScalar(scale);
                points.push(temp.clone());
            }
            return samplePoints(points, count);
        }

        function samplePoints(src, count) {
            const res = [];
            // å±…ä¸­
            const box = new THREE.Box3().setFromPoints(src);
            const center = box.getCenter(new THREE.Vector3());
            src.forEach(p => p.sub(center));
            
            for(let i=0; i<count; i++) res.push(src[i % src.length].clone());
            return res.sort(() => Math.random() - 0.5);
        }

        function centerPoints(points) {
             const box = new THREE.Box3().setFromPoints(points);
             const center = box.getCenter(new THREE.Vector3());
             points.forEach(p => p.sub(center));
        }

        // --- 2. ç²’å­ç³»ç»Ÿ ---
        function createParticles() {
            group = new THREE.Group();
            scene.add(group);

            const geom = new THREE.BoxGeometry(0.8, 0.8, 0.8); // é»˜è®¤æ–¹å—

            for(let i=0; i<CONFIG.particleCount; i++) {
                const mesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({color: 0xffffff}));
                
                // æ•£å¼€èŒƒå›´ï¼šæ”¹ä¸ºå…¨å±çˆ†å‘ (Range å¤§å¤§å¢åŠ )
                const scatterPos = new THREE.Vector3(
                    (Math.random()-0.5) * 600,
                    (Math.random()-0.5) * 400,
                    (Math.random()-0.5) * 400
                );
                
                mesh.position.copy(scatterPos);
                group.add(mesh);

                particles.push({
                    mesh: mesh,
                    // ç›®æ ‡åº“
                    targets: {
                        0: SHAPES.HORSE[i],
                        1: SHAPES.TEXT[i],
                        2: SHAPES.LOGO[i]
                    },
                    scatterPos: scatterPos,
                    isPhoto: false,
                    baseColor: new THREE.Color(),
                    velocity: new THREE.Vector3(0,0,0) // ç”¨äºæ•£å¼€æ—¶çš„æµåŠ¨
                });
            }
            
            updateParticleVisuals(0); // åˆå§‹ä¸ºé©¬
            updateState('DISPERSED');
        }

        // æ ¸å¿ƒï¼šæ ¹æ®å½¢æ€æ›´æ–°é¢œè‰²å’Œå‡ ä½•ä½“
        function updateParticleVisuals(shapeIdx) {
            const isHorse = shapeIdx === 0;
            const isText = shapeIdx === 1;
            const isLogo = shapeIdx === 2;

            particles.forEach((p, i) => {
                if(p.isPhoto) return;

                let color;
                // 1. é©¬ï¼šè“é‡‘çº¢
                if(isHorse) {
                    color = CONFIG.colors.horse[Math.floor(Math.random() * CONFIG.colors.horse.length)];
                    p.mesh.scale.set(1,1,1);
                    p.mesh.material.opacity = 1;
                }
                // 2. æ–‡å­—ï¼šæ˜Ÿå…‰è“ (æµ…æµ…çš„ï¼Œäº®æ™¶æ™¶)
                else if(isText) {
                    color = CONFIG.colors.text[Math.floor(Math.random() * CONFIG.colors.text.length)];
                    // æ–¹å½¢ç¢ç»ç’ƒè´¨æ„Ÿï¼šç¨å¾®å‹æ‰ä¸€ç‚¹ï¼ŒåŠé€æ˜
                    p.mesh.scale.set(1.2, 1.2, 0.5); 
                    p.mesh.material.opacity = 0.7; 
                    p.mesh.material.transparent = true;
                }
                // 3. Logoï¼šçº¢ç»¿æ¸å˜
                else if(isLogo) {
                    // æ ¹æ® Y è½´é«˜åº¦å†³å®šé¢œè‰²ï¼šä¸Šç»¿ä¸‹çº¢
                    const y = p.targets[2].y;
                    if(y > 0) {
                        // ç»¿è‰²ç³» (æ·±ç»¿åˆ°å«©ç»¿)
                        const greenVal = 0.5 + (y / 50) * 0.5;
                        color = new THREE.Color(0.2, greenVal, 0.1); 
                    } else {
                        // çº¢è‰²ç³» (ä¸­å›½çº¢åˆ°æ©™è‰²)
                        const redVal = 0.8 + (Math.abs(y) / 50) * 0.2;
                        color = new THREE.Color(redVal, 0.1, 0.0);
                    }
                    p.mesh.scale.set(1.2, 1.2, 1.2);
                    p.mesh.material.opacity = 1;
                }

                if(color instanceof THREE.Color) p.baseColor = color;
                else p.baseColor = new THREE.Color(color);

                gsap.to(p.mesh.material.color, {
                    r: p.baseColor.r, g: p.baseColor.g, b: p.baseColor.b, 
                    duration: 1.0
                });
            });
            
            // UI æ›´æ–°
            const nameEl = document.getElementById('shape-name');
            if(isHorse) nameEl.innerText = "ğŸ æˆ˜é©¬å½¢æ€";
            else if(isText) nameEl.innerText = "ğŸ’ å“ç‰Œæ„¿æ™¯";
            else nameEl.innerText = "ğŸ—ï¸ å“ç‰Œå›¾è…¾";
        }

        // --- 3. äº¤äº’é€»è¾‘ (æ‰‹åŠ¿é©±åŠ¨) ---
        function updateState(newState) {
            if (state === newState && state !== 'ZOOM') return;
            
            // åªæœ‰æ•£å¼€åæ‰èƒ½åˆ‡æ¢å½¢æ€
            if(state === 'DISPERSED' && newState === 'CONVERGED') {
                if(pendingShapeChange) {
                    currentShapeIndex = (currentShapeIndex + 1) % 3;
                    updateParticleVisuals(currentShapeIndex);
                    pendingShapeChange = false;
                }
            } else if (newState === 'DISPERSED') {
                pendingShapeChange = true;
            }

            state = newState;
            const statusEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                statusEl.innerText = "çŠ¶æ€: âœŠ å¿µåŠ›é”å®š (éšæ‰‹è€ŒåŠ¨)";
                statusEl.style.color = "#FFD700";
                
                particles.forEach(p => {
                    const target = p.targets[currentShapeIndex];
                    
                    // èšåˆåŠ¨ç”»
                    gsap.to(p.mesh.position, {
                        x: target.x, y: target.y, z: target.z,
                        duration: 1.2, ease: "power2.inOut"
                    });
                    
                    // ç…§ç‰‡ä¼˜åŒ–ï¼šèšåˆæ—¶ï¼Œç…§ç‰‡Zè½´å¤–ç§» + æ°¸è¿œæœå‘ç›¸æœº
                    if(p.isPhoto) {
                        gsap.to(p.mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                        gsap.to(p.mesh.position, {
                            // åœ¨ç›®æ ‡ä½ç½®åŸºç¡€ä¸Šï¼Œå¾€ç›¸æœºæ–¹å‘æ‹‰è¿‘ 15 ä¸ªå•ä½ï¼Œä¿è¯ä¸è¢«é®æŒ¡
                            z: target.z + 15, 
                            duration: 1.2 
                        });
                        p.mesh.lookAt(camera.position);
                    } else {
                        gsap.to(p.mesh.rotation, {x:0, y:0, z:0, duration: 1});
                    }
                });

            } else if (state === 'DISPERSED') {
                statusEl.innerText = "çŠ¶æ€: ğŸ– èƒ½é‡çˆ†å‘ (ç­‰å¾…èšåˆ)";
                statusEl.style.color = "#00FFFF";
                
                particles.forEach(p => {
                    // æ•£å¼€åŠ¨ç”»ï¼šæ›´çŒ›çƒˆ
                    gsap.to(p.mesh.position, {
                        x: p.scatterPos.x, y: p.scatterPos.y, z: p.scatterPos.z,
                        duration: 1.5, ease: "power3.out" // çˆ†ç‚¸æ„Ÿ
                    });
                    
                    if(p.isPhoto) {
                        gsap.to(p.mesh.scale, { x: 3, y: 3, z: 1, duration: 1 });
                        p.mesh.lookAt(camera.position);
                    }
                });

            } else if (state === 'ZOOM') {
                statusEl.innerText = "çŠ¶æ€: ğŸ“¸ è®°å¿†æŠ“å–";
                statusEl.style.color = "#FF00FF";
                
                const photos = particles.filter(p => p.isPhoto);
                if(photos.length > 0) {
                    const target = photos[Math.floor(Math.random()*photos.length)];
                    activeZoomParticle = target;

                    // è®¡ç®—ç›¸æœºæ­£å‰æ–¹çš„â€œéª‘è„¸â€ä½ç½® (è·ç¦»ç›¸æœº 30 å•ä½)
                    const vec = new THREE.Vector3(0, 0, -1);
                    vec.applyQuaternion(camera.quaternion);
                    const targetPos = camera.position.clone().add(vec.multiplyScalar(30));

                    gsap.to(target.mesh.position, {
                        x: targetPos.x, y: targetPos.y, z: targetPos.z,
                        duration: 0.6, ease: "back.out(1.0)"
                    });
                    gsap.to(target.mesh.scale, { x: 12, y: 12, z: 1, duration: 0.6 });
                    
                    // å¼ºåˆ¶å¯¹é½ç›¸æœºæ—‹è½¬
                    target.mesh.lookAt(camera.position);
                    gsap.to(target.mesh.rotation, {
                        x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z, duration: 0.6
                    });
                }
            }
        }

        // --- 4. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            if(!group) return;

            // A. æ•£å¼€æ€ï¼šç²’å­æµåŠ¨ (Perlin Noise æ¨¡æ‹Ÿ)
            if(state === 'DISPERSED') {
                particles.forEach(p => {
                    if(state === 'ZOOM' && p === activeZoomParticle) return;
                    
                    // å¢åŠ ä¸è§„åˆ™æµåŠ¨ï¼Œä¸å†æ­»æ¿
                    p.mesh.position.x += Math.sin(time + p.scatterPos.y * 0.1) * 0.1;
                    p.mesh.position.y += Math.cos(time + p.scatterPos.x * 0.1) * 0.1;
                    
                    if(p.isPhoto) p.mesh.lookAt(camera.position);
                });
                
                // æ•£å¼€æ—¶ï¼Œæ•´ä½“ç¼“æ…¢å›æ­£
                group.rotation.y += (0 - group.rotation.y) * 0.02;
                group.rotation.x += (0 - group.rotation.x) * 0.02;
            } 
            
            // B. èšåˆæ€ï¼šå¿µåŠ›è·Ÿéš (æ ¸å¿ƒäº¤äº’)
            else if (state === 'CONVERGED') {
                // å¦‚æœæ‰‹æ¡æ‹³ï¼ˆåˆ¤å®šä¸º activeï¼‰ï¼Œåˆ™æ¨¡å‹è·Ÿéšæ‰‹åŠ¿æ—‹è½¬
                // handPosition: 0(left) -> 1(right)
                // æ˜ å°„åˆ°æ—‹è½¬è§’åº¦: -1.5(left) -> 1.5(right)
                
                const targetRotY = (handPosition.x - 0.5) * 3; 
                const targetRotX = (handPosition.y - 0.5) * 2; 

                // ä½¿ç”¨ lerp å¹³æ»‘è·Ÿéš
                group.rotation.y += (targetRotY - group.rotation.y) * 0.08; 
                group.rotation.x += (targetRotX - group.rotation.x) * 0.08;
                
                // ç¡®ä¿ç…§ç‰‡å§‹ç»ˆæœå‘ç›¸æœº
                particles.forEach(p => {
                    if(p.isPhoto) p.mesh.lookAt(camera.position);
                });
            }

            composer.render();
        }

        // --- 5. ç…§ç‰‡ä¸Šä¼ ä¸å¤„ç† ---
        function handleFileUpload(event) {
            const files = event.target.files;
            if(!files.length) return;
            const limit = Math.min(files.length, CONFIG.maxPhotos);
            
            // æ¸…ç†æ—§ç…§ç‰‡
            particles.forEach(p => {
                if(p.isPhoto) {
                    p.isPhoto = false;
                    p.mesh.material = new THREE.MeshBasicMaterial({color: p.baseColor});
                }
            });

            const photoIndices = [];
            while(photoIndices.length < limit) {
                const r = Math.floor(Math.random() * particles.length);
                if(!photoIndices.includes(r)) photoIndices.push(r);
            }

            Array.from(files).slice(0, limit).forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        
                        const p = particles[photoIndices[i]];
                        p.isPhoto = true;
                        p.mesh.geometry = new THREE.PlaneGeometry(3, 3); // åŸå¤§å°ºå¯¸
                        p.mesh.material = new THREE.MeshBasicMaterial({
                            map: tex, side: THREE.DoubleSide, transparent: true
                        });
                        p.mesh.lookAt(camera.position);
                    }
                }
                reader.readAsDataURL(file);
            });
            alert(`å·²æ³¨å…¥ ${limit} æ®µè®°å¿†ã€‚èšåˆæ—¶å®ƒä»¬å°†æ‚¬æµ®äºè¡¨é¢ã€‚`);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 6. åª’ä½“ç®¡é“ (MediaPipe) ---
        function initMediaPipe() {
            const videoElement = document.getElementById('video-element');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) {
                    // å¦‚æœæ‰‹ç§»å‡ºç”»é¢ï¼Œç¨å¾®å›æ­£
                    return;
                }
                
                const lm = results.multiHandLandmarks[0];
                
                // 1. æ›´æ–°æ‰‹çš„ä½ç½® (ç”¨äºæ§åˆ¶æ—‹è½¬)
                // å–æ‰‹è…•(0)å’Œä¸­æŒ‡æ ¹(9)çš„ä¸­å¿ƒä½œä¸ºâ€œæ‰‹å¿ƒâ€
                const palmX = (lm[0].x + lm[9].x) / 2;
                const palmY = (lm[0].y + lm[9].y) / 2;
                handPosition.x = 1 - palmX; // é•œåƒç¿»è½¬
                handPosition.y = palmY;

                // 2. æåˆæ£€æµ‹ (æŠ“å–ç…§ç‰‡)
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                
                // 3. æ¡æ‹³/å¼ å¼€æ£€æµ‹
                const tips = [8, 12, 16, 20];
                const bases = [5, 9, 13, 17];
                let openCount = 0;
                tips.forEach((tip, i) => { if (lm[tip].y < lm[bases[i]].y) openCount++; });

                // 4. çŠ¶æ€æœºé€»è¾‘
                if (pinchDist < 0.05) {
                    // æåˆ -> æŠ“å–
                    if (state !== 'ZOOM') updateState('ZOOM');
                } else if (openCount >= 3) {
                    // å¼ å¼€ -> æ•£å¼€
                    if (state !== 'DISPERSED') updateState('DISPERSED');
                } else if (openCount <= 1) {
                    // æ¡æ‹³ -> èšåˆé”å®š
                    if (state !== 'CONVERGED') updateState('CONVERGED');
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start();
        }
    </script>
</body>
</html>
