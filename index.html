<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebula Horse - Cinematic Edition</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050000; /* 深邃黑红背景 */
            font-family: 'Arial', sans-serif; 
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        /* UI 只有极简风格 */
        #ui-layer {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 10; text-align: center; pointer-events: none;
            width: 80%;
        }

        .status-text {
            color: rgba(255, 215, 0, 0.8);
            font-size: 14px; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            margin-bottom: 15px; font-weight: lighter;
        }

        .upload-btn {
            pointer-events: auto;
            background: transparent;
            color: #FFD700;
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 8px 20px;
            font-size: 12px;
            cursor: pointer;
            transition: 0.4s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .upload-btn:hover { 
            background: rgba(255, 215, 0, 0.1); 
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4); 
            border-color: #FFD700;
        }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #884444; font-size: 12px; letter-spacing: 3px; z-index: 20;
        }

        /* 隐藏视频源 */
        .input_video { display: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">INITIALIZING NEURAL LINK...</div>
    <video class="input_video"></video>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="status-text" class="status-text">WAITING FOR HAND SIGNAL</div>
        <input type="file" id="imageUpload" multiple accept="image/*" style="display: none;">
        <button class="upload-btn" onclick="document.getElementById('imageUpload').click()">+ LOAD MEMORIES</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 配置与全局变量 ---
        const CONFIG = {
            particleCount: 4000,   // 粒子数量
            particleSize: 0.15,    // 粒子大小
            bloomStrength: 2.0,    // 辉光强度
            bloomThreshold: 0.3,   // 辉光阈值 (避免照片过曝)
            colorGold: new THREE.Color(0xFFCC33), // 香槟金
            colorRed: new THREE.Color(0x880011),  // 深红
        };

        let scene, camera, renderer, composer;
        let particlesSystem, photoSystem;
        let particleGeo, particleMat;
        let photoGroup = new THREE.Group();
        
        let targetPositions = []; // 存储马的形状数据
        let currentPositions = []; // 粒子当前位置
        let originalPositions = []; // 散开时的随机位置
        
        let clock = new THREE.Clock();
        
        // 状态
        const STATE = {
            FORM: 0,   // 马 (聚合)
            STARDUST: 1, // 散开 (星云)
            PHOTO: 2     // 照片展示
        };
        let appState = STATE.FORM;
        let targetRotationY = 0;
        let activePhoto = null; // 当前聚焦的照片Mesh

        // --- 1. 辅助函数：生成光点纹理 (无需外部图片) ---
        function getGlowSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            // 径向渐变，中心亮，边缘透明
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,200,100,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- 2. 核心：构建优美的马形 (Math Art) ---
        function generateHorseShape(count) {
            const positions = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                let x, y, z;
                const r = Math.random();
                
                // 使用概率分布来构建“肌肉块”
                if (r < 0.35) {
                    // 躯干 (Ribcage & Body) - 稍微压扁的椭球
                    x = (Math.random() - 0.5) * 3.5;
                    y = (Math.random() - 0.5) * 1.8;
                    z = (Math.random() - 0.5) * 1.5;
                    // 稍微向后移
                    x -= 0.5; 
                } else if (r < 0.55) {
                    // 脖子 (Neck) - 贝塞尔曲线风格的管状
                    const t = Math.random(); // 0 to 1 along neck
                    // 脖子曲线函数
                    const curveX = -2.0 - t * 1.5;
                    const curveY = 1.0 + t * 2.0;
                    // 脖子厚度随高度变细
                    const thickness = 0.8 * (1 - t * 0.4);
                    
                    x = curveX + (Math.random()-0.5) * thickness;
                    y = curveY + (Math.random()-0.5) * thickness * 1.5;
                    z = (Math.random()-0.5) * thickness * 0.8;
                } else if (r < 0.65) {
                    // 头 (Head)
                    x = -3.8 + (Math.random()-0.5) * 1.2;
                    y = 3.2 + (Math.random()-0.5) * 0.8;
                    z = (Math.random()-0.5) * 0.7;
                    // 鼻子稍微突出
                    if(Math.random() > 0.5) { x -= 0.5; y -= 0.2; }
                } else if (r < 0.85) {
                    // 腿 (Legs) - 动态奔跑姿态
                    const isFront = Math.random() > 0.5;
                    const isLeft = Math.random() > 0.5 ? -1 : 1;
                    
                    // 腿的基本位置
                    const legRootX = isFront ? -2.0 : 1.5;
                    const legRootY = -0.5;
                    const legZ = 0.6 * isLeft;

                    // 简化的关节逻辑
                    const t = Math.random(); // 0(top) to 1(hoof)
                    
                    // 前腿抬起，后腿蹬地
                    let offsetX = 0;
                    let offsetY = -t * 3.0;
                    
                    if (isFront) {
                        // 前腿弯曲
                        offsetX = Math.sin(t * Math.PI) * 1.0; 
                        offsetY += Math.sin(t * Math.PI) * 0.5;
                    } else {
                        // 后腿向后蹬
                        offsetX = t * 1.5;
                    }

                    x = legRootX + offsetX + (Math.random()-0.5)*0.4;
                    y = legRootY + offsetY;
                    z = legZ + (Math.random()-0.5)*0.4;
                } else {
                    // 鬃毛和尾巴 (粒子流)
                    if (Math.random() > 0.5) {
                        // 尾巴
                        const t = Math.random();
                        x = 1.5 + t * 2.0 + Math.random()*0.5;
                        y = 0.5 - t * 1.5 + Math.random()*0.5;
                        z = (Math.random()-0.5) * t * 1.0;
                    } else {
                        // 鬃毛
                        const t = Math.random();
                        x = -2.0 - t * 1.0;
                        y = 3.5 - t * 1.5;
                        z = 0;
                    }
                }
                
                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;
            }
            return positions;
        }

        // --- 3. 初始化 Three.js ---
        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            // 添加环境雾气，增加深邃感
            scene.fog = new THREE.FogExp2(0x050000, 0.03);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 12;
            camera.position.y = 1;

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false }); // 既然是全屏深色，不需要 alpha
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 优化性能
            container.appendChild(renderer.domElement);

            // 粒子系统
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);

            // 生成马的数据
            targetPositions = generateHorseShape(CONFIG.particleCount);
            
            // 初始化粒子位置（全屏随机分布）
            for(let i=0; i<CONFIG.particleCount; i++) {
                // 随机位置 (星云态)
                positions[i*3] = (Math.random() - 0.5) * 40;
                positions[i*3+1] = (Math.random() - 0.5) * 20;
                positions[i*3+2] = (Math.random() - 0.5) * 20;
                
                // 记录原始随机位
                originalPositions.push(new THREE.Vector3(positions[i*3], positions[i*3+1], positions[i*3+2]));
                currentPositions.push(new THREE.Vector3(positions[i*3], positions[i*3+1], positions[i*3+2]));

                // 颜色 (混合金色和深红色)
                const colorMix = Math.random();
                const color = new THREE.Color().lerpColors(CONFIG.colorRed, CONFIG.colorGold, colorMix * 0.8 + 0.2); // 偏金
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;

                // 大小随机
                sizes[i] = Math.random() * CONFIG.particleSize;
            }

            particleGeo = new THREE.BufferGeometry();
            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // Shader Material 替代标准材质，为了更好的性能和效果
            particleMat = new THREE.PointsMaterial({
                size: 1.0,
                map: getGlowSprite(),
                vertexColors: true,
                blending: THREE.AdditiveBlending, // 关键：加法混合让粒子发光
                depthWrite: false,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            particlesSystem = new THREE.Points(particleGeo, particleMat);
            scene.add(particlesSystem);
            scene.add(photoGroup); // 照片组

            // 后期处理
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = CONFIG.bloomThreshold;
            bloomPass.strength = CONFIG.bloomStrength;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
        }

        // --- 4. 照片逻辑 ---
        const imageInput = document.getElementById('imageUpload');
        imageInput.addEventListener('change', (e) => {
            const files = e.target.files;
            if (!files.length) return;
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.src = evt.target.result;
                    img.onload = () => {
                        createPhoto(img);
                    };
                };
                reader.readAsDataURL(file);
            });
        });

        function createPhoto(img) {
            const aspect = img.width / img.height;
            const tex = new THREE.Texture(img);
            tex.needsUpdate = true;
            tex.colorSpace = THREE.SRGBColorSpace; // 修复颜色

            // 使用 BasicMaterial 避免受光照影响变黑，也不要太亮导致过曝
            const mat = new THREE.MeshBasicMaterial({ 
                map: tex, 
                side: THREE.DoubleSide, 
                transparent: true,
                opacity: 0.9
            });
            const geo = new THREE.PlaneGeometry(1.5 * aspect, 1.5);
            const mesh = new THREE.Mesh(geo, mat);

            // 初始随机位置
            mesh.position.set(
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10
            );
            
            // 存一个目标位置用于动画
            mesh.userData = {
                originPos: mesh.position.clone(),
                velocity: new THREE.Vector3((Math.random()-0.5)*0.01, (Math.random()-0.5)*0.01, 0)
            };

            photoGroup.add(mesh);
        }

        // --- 5. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const positions = particleGeo.attributes.position.array;
            
            // 旋转整个粒子群 (根据手势旋转目标)
            if (appState === STATE.STARDUST || appState === STATE.PHOTO) {
                particlesSystem.rotation.y += (targetRotationY - particlesSystem.rotation.y) * 0.05;
            } else {
                // 马形态自动慢旋
                particlesSystem.rotation.y += 0.002;
            }

            // 更新所有粒子位置
            for(let i=0; i<CONFIG.particleCount; i++) {
                const px = currentPositions[i].x;
                const py = currentPositions[i].y;
                const pz = currentPositions[i].z;
                
                let tx, ty, tz;

                if (appState === STATE.FORM) {
                    // 目标：马的形状
                    tx = targetPositions[i*3];
                    ty = targetPositions[i*3+1];
                    tz = targetPositions[i*3+2];
                    
                    // 加上一点微弱的呼吸浮动
                    tx += Math.sin(time * 2 + py) * 0.02;
                } else {
                    // 目标：原始散开位置
                    tx = originalPositions[i].x;
                    ty = originalPositions[i].y;
                    tz = originalPositions[i].z;

                    // 增加 "Curl Noise" 感觉的漂浮流动
                    tx += Math.sin(time * 0.5 + i) * 0.5;
                    ty += Math.cos(time * 0.3 + i) * 0.5;
                }

                // 插值移动 (Lerp) - 0.08 的系数控制汇聚速度
                currentPositions[i].x += (tx - px) * 0.08;
                currentPositions[i].y += (ty - py) * 0.08;
                currentPositions[i].z += (tz - pz) * 0.08;

                // 更新 Buffer
                positions[i*3] = currentPositions[i].x;
                positions[i*3+1] = currentPositions[i].y;
                positions[i*3+2] = currentPositions[i].z;
            }

            particleGeo.attributes.position.needsUpdate = true;

            // 更新照片逻辑
            photoGroup.children.forEach(photo => {
                if (appState === STATE.PHOTO && photo === activePhoto) {
                    // 选中的照片：飞到相机面前
                    // 计算相机前方的位置
                    const target = new THREE.Vector3(0, 0, 8).applyMatrix4(camera.matrixWorld);
                    photo.position.lerp(target, 0.1);
                    photo.lookAt(camera.position);
                    photo.scale.setScalar(2.0); // 放大
                } else if (appState === STATE.FORM) {
                    // 马形态：照片融入马身体里 (随机选几个马的点作为目标)
                    // 这里为了简单，让照片围绕在马周围旋转
                    photo.position.lerp(photo.userData.originPos.clone().multiplyScalar(0.3), 0.05);
                    photo.lookAt(camera.position);
                    photo.scale.setScalar(0.5); // 变小
                } else {
                    // 散开态：漂浮
                    photo.position.x += photo.userData.velocity.x;
                    photo.position.y += photo.userData.velocity.y;
                    photo.lookAt(camera.position);
                    photo.scale.setScalar(1.0);
                }
            });

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 6. 手势识别逻辑 (优化版) ---
        const statusText = document.getElementById('status-text');
        
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

            const lm = results.multiHandLandmarks[0];
            
            // 简单的手势判断
            const wrist = lm[0];
            const fingerTips = [lm[8], lm[12], lm[16], lm[20]];
            const fingerMids = [lm[6], lm[10], lm[14], lm[18]]; // 关节
            
            // 判断手指是否弯曲 (指尖y > 关节y, 屏幕坐标系向下为正)
            let foldedFingers = 0;
            // 注意：MediaPipe坐标系，y向下增大。如果指尖y > 关节y，说明手指指向下或弯曲。
            // 更稳健的方法是计算 指尖到手腕距离 vs 关节到手腕距离
            const dist = (p1, p2) => Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
            
            for(let i=0; i<4; i++) {
                if (dist(fingerTips[i], wrist) < dist(fingerMids[i], wrist)) {
                    foldedFingers++;
                }
            }

            const isFist = foldedFingers >= 3;
            const isPinch = dist(lm[4], lm[8]) < 0.05; // 拇指食指距离

            // 状态机切换
            if (isPinch) {
                // 抓取模式
                if (appState !== STATE.PHOTO) {
                    appState = STATE.PHOTO;
                    statusText.innerText = "MODE: MEMORY RECALL (PINCH)";
                    // 随机激活一张照片，或者找离中心最近的
                    if (photoGroup.children.length > 0) {
                        activePhoto = photoGroup.children[Math.floor(Math.random() * photoGroup.children.length)];
                    }
                }
            } else if (isFist) {
                // 聚合模式
                appState = STATE.FORM;
                statusText.innerText = "MODE: GOLDEN HORSE (FIST)";
                activePhoto = null;
            } else {
                // 散开模式
                appState = STATE.STARDUST;
                statusText.innerText = "MODE: NEBULA (OPEN HAND)";
                activePhoto = null;
                
                // 根据手掌位置旋转视角
                const handX = lm[9].x; // 中指根部x
                targetRotationY = (handX - 0.5) * 5; // -2.5 to 2.5 rad
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraMedia = new Camera(document.querySelector('.input_video'), {
            onFrame: async () => { await hands.send({image: document.querySelector('.input_video')}); },
            width: 640, height: 480
        });

        init();
        animate();
        cameraMedia.start();

    </script>
</body>
</html>
