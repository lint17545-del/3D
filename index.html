<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D Photo Memory Horse - Final</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Arial', sans-serif; }
        
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; opacity: 0.5; }
        
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 24px; color: #FFD700; letter-spacing: 2px; text-shadow: 0 0 20px rgba(196, 30, 58, 0.5); font-weight: 300; }
        .status { font-size: 16px; color: rgba(255,255,255,0.8); margin-top: 10px; font-weight: normal; letter-spacing: 1px;}
        .tips { font-size: 12px; color: #aaa; margin-top: 5px; margin-bottom: 15px;}

        /* ä¸Šä¼ æŒ‰é’®æ ·å¼ */
        #upload-container { pointer-events: auto; display: inline-block; }
        input[type="file"] { display: none; }
        .btn { 
            background: rgba(255, 215, 0, 0.1); 
            border: 1px solid #FFD700; 
            padding: 8px 15px; 
            color: #FFD700; 
            font-size: 12px;
            cursor: pointer; 
            border-radius: 4px; 
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn:hover { background: #FFD700; color: #000; box-shadow: 0 0 15px #FFD700; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; z-index: 20; font-size: 16px; text-align: center; letter-spacing: 2px; }
        #hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.3); font-size: 12px; pointer-events: none; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨ç¼–ç»‡è®°å¿†ç½‘ç»œ...</div>
    
    <div id="ui-layer">
        <h1>è®°å¿†çµé©¹ Â· æœ€ç»ˆç« </h1>
        <div class="status" id="status-text">ç­‰å¾…æŒ‡ä»¤...</div>
        <div class="tips">âœŠæ¡æ‹³:èšåˆ | ğŸ–å¼ å¼€:æ˜Ÿäº‘ | ğŸ‘Œæåˆ:æŸ¥çœ‹ç…§ç‰‡</div>
        
        <div id="upload-container">
            <label class="btn">
                + ä¸Šä¼ ç…§ç‰‡ (æ³¨å…¥è®°å¿†)
                <input type="file" id="file-input" multiple accept="image/*">
            </label>
        </div>
    </div>
    
    <div id="hint">æ»šè½®ç¼©æ”¾ | æ‹–æ‹½æ—‹è½¬ | æåˆæ‰‹æŒ‡æŸ¥çœ‹ç»†èŠ‚</div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const CONFIG = {
            particleCount: 6000, 
            colors: [0x0F52BA, 0xFFD700, 0xC41E3A], 
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb'
        };

        let scene, camera, renderer, composer, controls;
        let particles = [];
        let group;
        let state = 'CONVERGED';
        let time = 0;
        let handPosition = { x: 0.5, y: 0.5 };
        let activeZoomParticle = null; // å½“å‰æ­£åœ¨æŸ¥çœ‹çš„ç…§ç‰‡ç²’å­

        init();
        animate();
        initMediaPipe();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.0015);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 400);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(50, 50, 100);
            scene.add(mainLight);

            // åå¤„ç†
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.0; 
            bloomPass.radius = 0.5;
            bloomPass.threshold = 0.1;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            loadModel();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // ç»‘å®šä¸Šä¼ äº‹ä»¶
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
        }

        // --- ç…§ç‰‡å¤„ç†é€»è¾‘ ---
        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;

            const textureLoader = new THREE.TextureLoader();
            const photoParticlesIndices = [];

            // éšæœºæŒ‘é€‰ä¸€äº›ç²’å­å˜æˆç…§ç‰‡
            // æˆ‘ä»¬ä¿ç•™å¤§éƒ¨åˆ†ç²’å­ä½œä¸ºâ€œèº«ä½“â€ï¼ŒåªæŒ‘é€‰çº¦ 10% çš„ç²’å­ä½œä¸ºç…§ç‰‡è½½ä½“
            for(let i=0; i<files.length; i++) {
                 // æ¯å¼ ç…§ç‰‡åˆ†é…ç»™ 50 ä¸ªç²’å­
                 for(let j=0; j<50; j++) {
                     const randIdx = Math.floor(Math.random() * particles.length);
                     photoParticlesIndices.push({ idx: randIdx, fileIndex: i });
                 }
            }

            let loadedCount = 0;

            Array.from(files).forEach((file, fileIndex) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        texture.colorSpace = THREE.SRGBColorSpace; // é¢œè‰²æ ¡æ­£

                        // æ‰¾åˆ°åˆ†é…ç»™è¿™å¼ å›¾çš„æ‰€æœ‰ç²’å­ï¼Œå¹¶æ›¿æ¢æè´¨
                        const targetIndices = photoParticlesIndices.filter(p => p.fileIndex === fileIndex);
                        
                        targetIndices.forEach(item => {
                            const p = particles[item.idx];
                            p.isPhoto = true;
                            
                            // æ›¿æ¢å‡ ä½•ä½“ä¸ºå¹³é¢
                            p.mesh.geometry = new THREE.PlaneGeometry(1.5, 1.5); // ç…§ç‰‡ç²’å­å¤§ä¸€ç‚¹
                            p.mesh.material = new THREE.MeshBasicMaterial({ 
                                map: texture, 
                                side: THREE.DoubleSide, 
                                transparent: true,
                                opacity: 0.9 
                            });
                            // åˆå§‹è®©ç…§ç‰‡éƒ½æœå‘ç›¸æœº
                            p.mesh.lookAt(camera.position);
                        });
                        
                        loadedCount++;
                        if(loadedCount === files.length) {
                            alert(`æˆåŠŸæ³¨å…¥ ${files.length} æ®µè®°å¿†ï¼\nè¯•è¯•æåˆæ‰‹æŒ‡ (ğŸ‘Œ) æŠ“å–å®ƒä»¬ã€‚`);
                        }
                    };
                };
                reader.readAsDataURL(file);
            });
        }

        function loadModel() {
            const loader = new GLTFLoader();
            loader.load(CONFIG.modelUrl, (gltf) => {
                const model = gltf.scene;
                let mesh = null;
                model.traverse((child) => {
                    if (child.isMesh) mesh = child;
                });
                if(mesh) createParticlesFromMesh(mesh);
                document.getElementById('loading').style.display = 'none';
            });
        }

        function createParticlesFromMesh(mesh) {
            group = new THREE.Group();
            scene.add(group);

            const posAttr = mesh.geometry.attributes.position;
            const count = posAttr.count;
            const targetPoints = [];
            const tempVec = new THREE.Vector3();

            for(let i=0; i<count; i++) {
                tempVec.fromBufferAttribute(posAttr, i);
                targetPoints.push(tempVec.clone());
            }

            // è‡ªåŠ¨æ„å›¾é€»è¾‘
            const box = new THREE.Box3().setFromPoints(targetPoints);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            targetPoints.forEach(p => p.sub(center));

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.2;
            gsap.to(camera.position, { z: cameraZ, duration: 2, ease: "power2.out" });

            const shuffledPoints = targetPoints.sort(() => Math.random() - 0.5).slice(0, CONFIG.particleCount);
            const geom = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const materials = CONFIG.colors.map(c => new THREE.MeshBasicMaterial({ color: c }));

            shuffledPoints.forEach(pt => {
                const mat = materials[Math.floor(Math.random() * materials.length)];
                const pMesh = new THREE.Mesh(geom, mat);
                const scatterRange = maxDim * 2; 
                const scatterPos = new THREE.Vector3(
                    (Math.random()-0.5) * scatterRange,
                    (Math.random()-0.5) * scatterRange,
                    (Math.random()-0.5) * scatterRange
                );

                pMesh.userData = {
                    randomOffset: Math.random() * 100,
                    speed: 0.01 + Math.random() * 0.02
                };

                pMesh.position.copy(scatterPos);
                group.add(pMesh);

                particles.push({
                    mesh: pMesh,
                    targetPos: pt,
                    scatterPos: scatterPos,
                    isPhoto: false // æ ‡è®°æ˜¯å¦ä¸ºç…§ç‰‡
                });
            });
            updateState('DISPERSED');
        }

        function updateState(newState) {
            if (state === newState && state !== 'ZOOM') return; // ZOOM å…è®¸é‡å¤è§¦å‘ä»¥åˆ‡æ¢ç…§ç‰‡
            
            // å¦‚æœä» ZOOM åˆ‡æ¢å‡ºå»ï¼Œå…ˆé‡ç½®ä¹‹å‰çš„ activeZoomParticle
            if (state === 'ZOOM' && newState !== 'ZOOM' && activeZoomParticle) {
                 const p = activeZoomParticle;
                 // é£å›å®ƒåº”è¯¥åœ¨çš„ä½ç½® (æ ¹æ®å½“å‰å¤§çŠ¶æ€å†³å®šæ˜¯ targetPos è¿˜æ˜¯ scatterPos)
                 // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬å‡è®¾æ¾å¼€æ‰‹å°±æ˜¯å›åˆ° CONVERGED æˆ– DISPERSED
                 // è¿™é‡Œä¸åšå¤æ‚åˆ¤æ–­ï¼Œç›´æ¥ç”±ä¸‹é¢çš„å¾ªç¯æ¥ç®¡
            }

            state = newState;
            const statusEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                statusEl.innerText = "çŠ¶æ€: èšåˆ (æˆ˜é©¬)";
                statusEl.style.color = "#FFD700";
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.targetPos.x, y: p.targetPos.y, z: p.targetPos.z,
                        duration: 1.5, ease: "power3.inOut"
                    });
                    gsap.to(p.mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                    if(p.isPhoto) {
                        // ç…§ç‰‡åœ¨èšåˆæ—¶å˜å°ä¸€ç‚¹ï¼Œèå…¥èº«ä½“
                         gsap.to(p.mesh.scale, { x: 0.5, y: 0.5, z: 0.5, duration: 1 });
                         // æ—‹è½¬å¯¹é½
                         gsap.to(p.mesh.rotation, { x: 0, y: 0, z: 0, duration: 1 });
                    }
                });

            } else if (state === 'DISPERSED') {
                statusEl.innerText = "çŠ¶æ€: æ•£å¼€ (æ˜Ÿäº‘)";
                statusEl.style.color = "#00ffff";
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.scatterPos.x, y: p.scatterPos.y, z: p.scatterPos.z,
                        duration: 2.0, ease: "power2.out"
                    });
                    gsap.to(p.mesh.scale, { x: 2, y: 2, z: 2, duration: 1 });
                     if(p.isPhoto) {
                         gsap.to(p.mesh.scale, { x: 3, y: 3, z: 3, duration: 1 }); // ç…§ç‰‡æ•£å¼€æ—¶å¤§ä¸€ç‚¹
                         p.mesh.lookAt(camera.position); // å§‹ç»ˆçœ‹å‘ç›¸æœº
                    }
                });

            } else if (state === 'ZOOM') {
                statusEl.innerText = "çŠ¶æ€: ğŸ“¸ å›å¿†æµ®ç°";
                statusEl.style.color = "#ff00ff";
                
                // 1. æ‰¾åˆ°æ‰€æœ‰çš„ç…§ç‰‡ç²’å­
                const photoParticles = particles.filter(p => p.isPhoto);
                
                if (photoParticles.length > 0) {
                    // 2. éšæœºé€‰ä¸€ä¸ª (ä¸ºäº†æ•ˆæœï¼Œæˆ‘ä»¬æ¯æ¬¡æŠ“ä¸€ä¸ªæ–°çš„)
                    const target = photoParticles[Math.floor(Math.random() * photoParticles.length)];
                    activeZoomParticle = target;

                    // 3. è®¡ç®—ç›¸æœºå‰æ–¹çš„ä½ç½®
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    // è·ç¦»ç›¸æœº 50 å•ä½å¤„
                    const showPos = camera.position.clone().add(camDir.multiplyScalar(50));
                    
                    // 4. åŠ¨ç”»é£è¿‡æ¥
                    gsap.to(target.mesh.position, {
                        x: showPos.x, y: showPos.y, z: showPos.z,
                        duration: 1, ease: "back.out(1.2)"
                    });
                    // æ”¾å¤§æ˜¾ç¤º
                    gsap.to(target.mesh.scale, { x: 15, y: 15, z: 1, duration: 1 });
                    // æ­£å¯¹å±å¹•
                    target.mesh.lookAt(camera.position);
                } else {
                    // æ²¡æœ‰ä¸Šä¼ ç…§ç‰‡æ—¶
                    statusEl.innerText = "æç¤º: è¯·å…ˆä¸Šä¼ ç…§ç‰‡";
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            if (!group) return;

            // å‘¼å¸å¾‹åŠ¨
            group.position.y = Math.sin(time * 0.5) * 2; 

            if (state === 'DISPERSED') {
                particles.forEach(p => {
                    // æ’é™¤æ­£åœ¨ ZOOM çš„ç²’å­ï¼Œä¸è¦è®©å®ƒä¹±åŠ¨
                    if (state === 'ZOOM' && p === activeZoomParticle) return;

                    const offset = p.mesh.userData.randomOffset;
                    p.mesh.position.x += Math.cos(time + offset) * 0.05;
                    p.mesh.position.y += Math.sin(time + offset) * 0.05;
                    
                    // ç…§ç‰‡ç²’å­è‡ªè½¬å±•ç¤º
                    if (p.isPhoto) {
                         p.mesh.lookAt(camera.position);
                    }
                });

                // æ‰‹åŠ¿æ§åˆ¶
                const targetRotY = (handPosition.x - 0.5) * 2; 
                const targetRotX = (handPosition.y - 0.5) * 1;
                group.rotation.y += (targetRotY - group.rotation.y) * 0.03;
                group.rotation.x += (targetRotX - group.rotation.x) * 0.03;
            } else if (state === 'CONVERGED') {
                group.rotation.y += 0.002;
            }

            controls.update();
            composer.render();
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('video-element');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) return;
                
                const lm = results.multiHandLandmarks[0];
                const palmX = (lm[0].x + lm[9].x) / 2;
                const palmY = (lm[0].y + lm[9].y) / 2;
                handPosition.x = 1 - palmX; 
                handPosition.y = palmY;

                // æåˆæ£€æµ‹ (é£ŸæŒ‡8 å’Œ æ‹‡æŒ‡4)
                const thumbTip = lm[4];
                const indexTip = lm[8];
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

                // çŠ¶æ€åˆ¤å®š
                const tips = [8, 12, 16, 20];
                const bases = [5, 9, 13, 17];
                let openCount = 0;
                tips.forEach((tip, i) => { if (lm[tip].y < lm[bases[i]].y) openCount++; });

                // é€»è¾‘ä¼˜å…ˆçº§ï¼š
                // 1. æåˆ -> æŠ“å–ç…§ç‰‡ (ä¼˜å…ˆ)
                // 2. å¼ å¼€ -> æ•£å¼€
                // 3. æ¡æ‹³ -> èšåˆ

                if (pinchDist < 0.05) {
                    // åŠ ä¸€ä¸ªç®€å•çš„é˜²æŠ–ï¼Œé˜²æ­¢è¿ç»­è§¦å‘
                    if (state !== 'ZOOM') updateState('ZOOM');
                } else if (openCount >= 3) {
                    if (state !== 'DISPERSED') updateState('DISPERSED');
                } else if (openCount <= 1) {
                    if (state !== 'CONVERGED') updateState('CONVERGED');
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start();
        }
    </script>
</body>
</html>
