<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D Gesture Controlled Particle Horse (Real Model)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Helvetica Neue', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 2px solid #FFD700; border-radius: 8px; opacity: 0.7; }
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 24px; color: #FFD700; text-shadow: 0 0 10px #C41E3A; letter-spacing: 2px; }
        p { font-size: 14px; color: #ddd; margin-top: 5px; }
        .instruction { font-size: 12px; color: #0F52BA; background: rgba(255,255,255,0.1); padding: 5px 10px; border-radius: 4px; display: inline-block; margin-top: 5px; border: 1px solid #0F52BA; }
        #upload-container { pointer-events: auto; margin-top: 20px; }
        input[type="file"] { display: none; }
        .btn { background: linear-gradient(45deg, #C41E3A, #FFD700); border: none; padding: 10px 20px; color: #fff; font-weight: bold; cursor: pointer; border-radius: 20px; box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); transition: all 0.3s; }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; z-index: 20; font-size: 20px; text-align: center; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        æ­£åœ¨ä¸‹è½½ 3D é©¬æ¨¡å‹èµ„æº...<br>
        <span style="font-size:14px; opacity:0.7">é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ</span>
    </div>
    
    <div id="ui-layer">
        <h1>ç²’å­çµé©¹ Â· å¹»å¢ƒ (çœŸé©¬ç‰ˆ)</h1>
        <p>Three.js GLB æ¨¡å‹åŠ è½½æ¼”ç¤º</p>
        <div>
            <div class="instruction">âœŠ æ¡æ‹³ï¼šèšåˆ (é©¬å½¢æ€)</div>
            <div class="instruction">ğŸ– å¼ å¼€ï¼šæ•£å¼€ (æ˜Ÿäº‘æ€)</div>
            <div class="instruction">ğŸ¤ æåˆï¼šæŠ“å–ç…§ç‰‡</div>
            <div class="instruction">ğŸ‘‹ æ—‹è½¬ï¼šè°ƒæ•´è§†è§’</div>
        </div>
        <div id="upload-container">
            <label class="btn">
                ä¸Šä¼ ç…§ç‰‡ç”Ÿæˆç²’å­äº‘
                <input type="file" id="file-input" multiple accept="image/*">
            </label>
        </div>
    </div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'; // å¼•å…¥åŠ è½½å™¨

        // --- Configuration ---
        const CONFIG = {
            particleCount: 3000, // å¢åŠ ç²’å­æ•°é‡ä»¥é€‚åº”çœŸå®æ¨¡å‹
            colors: [0x0F52BA, 0xFFD700, 0xC41E3A], 
            bloomStrength: 1.8,
            bloomRadius: 0.5,
            bloomThreshold: 0.1,
            // è¿™æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„å…è´¹å¼€æºé©¬æ¨¡å‹åœ°å€
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb' 
        };

        let scene, camera, renderer, composer, controls;
        let particles = [];
        let state = 'CONVERGED';
        let time = 0;
        let group;
        let activeZoomParticle = null;

        init();
        animate();
        initMediaPipe();

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 150); // è°ƒæ•´ç›¸æœºä½ç½®é€‚åº”æ¨¡å‹å¤§å°

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            // Post Processing
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = CONFIG.bloomThreshold;
            bloomPass.strength = CONFIG.bloomStrength;
            bloomPass.radius = CONFIG.bloomRadius;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true; // è‡ªåŠ¨æ—‹è½¬è®©ç”»é¢æ›´å¥½çœ‹
            controls.autoRotateSpeed = 1.0;

            // --- æ ¸å¿ƒä¿®æ”¹ï¼šåŠ è½½ç½‘ç»œæ¨¡å‹ ---
            loadModelAndCreateParticles();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
        }

        function loadModelAndCreateParticles() {
            const loader = new GLTFLoader();
            loader.load(CONFIG.modelUrl, function (gltf) {
                const model = gltf.scene;
                let targetPoints = [];
                
                // éå†æ¨¡å‹æå–é¡¶ç‚¹
                model.traverse((child) => {
                    if (child.isMesh) {
                        // ç¨å¾®æ”¾å¤§ä¸€ç‚¹æ¨¡å‹
                        child.scale.set(0.2, 0.2, 0.2); 
                        child.geometry.scale(0.2, 0.2, 0.2); // ç›´æ¥åº”ç”¨ç¼©æ”¾åˆ°å‡ ä½•ä½“
                        
                        const posAttr = child.geometry.attributes.position;
                        const count = posAttr.count;
                        const tempVec = new THREE.Vector3();
                        
                        // é‡‡æ ·é¡¶ç‚¹
                        // é©¬æ¨¡å‹é¡¶ç‚¹å¾ˆå¤šï¼Œæˆ‘ä»¬æ¯éš”å‡ ä¸ªç‚¹å–ä¸€ä¸ªï¼Œé˜²æ­¢ç²’å­å¤ªå¤šå¡é¡¿
                        for (let i = 0; i < count; i++) {
                            // éšæœºä¸¢å¼ƒä¸€äº›ç‚¹ï¼Œæˆ–è€…å…¨éƒ¨ä¿ç•™
                            if (Math.random() > 0.6) continue; 

                            tempVec.fromBufferAttribute(posAttr, i);
                            
                            // ä¿®æ­£ä½ç½®ï¼šThreejsçš„é©¬æ˜¯ä¾§ç€çš„æˆ–è€…æ˜¯åŠ¨æ€çš„ï¼Œè¿™é‡Œå±…ä¸­å¤„ç†
                            tempVec.y -= 10; 
                            
                            targetPoints.push(tempVec.clone());
                        }
                    }
                });
                
                // å¦‚æœç‚¹å¤ªå¤šï¼Œæˆªå–ä¸€ä¸‹
                if (targetPoints.length > CONFIG.particleCount) {
                    targetPoints = targetPoints.slice(0, CONFIG.particleCount);
                }

                generateParticles(targetPoints);
                document.getElementById('loading').style.display = 'none';

            }, undefined, function (error) {
                console.error(error);
                document.getElementById('loading').innerText = "æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ";
            });
        }

        function generateParticles(points) {
            group = new THREE.Group();
            scene.add(group);
            
            const baseGeomBox = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const baseGeomSphere = new THREE.SphereGeometry(0.5, 8, 8);
            
            const materials = CONFIG.colors.map(c => 
                new THREE.MeshStandardMaterial({
                    color: c,
                    roughness: 0.4,
                    metalness: 0.8,
                    emissive: c,
                    emissiveIntensity: 0.8
                })
            );

            points.forEach((point) => {
                const isSphere = Math.random() > 0.5;
                const mat = materials[Math.floor(Math.random() * materials.length)];
                const geom = isSphere ? baseGeomSphere : baseGeomBox;

                const mesh = new THREE.Mesh(geom, mat.clone());
                
                // æ•£å¼€ä½ç½®ï¼ˆéšæœºæ•£å¸ƒåœ¨å¤§èŒƒå›´å†…ï¼‰
                const scatterPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );

                mesh.position.copy(scatterPos);
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);

                group.add(mesh);

                particles.push({
                    mesh: mesh,
                    targetPos: point,
                    scatterPos: scatterPos,
                    originalMat: mat,
                    isPhoto: false
                });
            });
        }

        // --- Interaction Logic (ä¿æŒä¸å˜) ---
        function updateState(newState) {
            if (state === newState) return;
            state = newState;
            
            // çŠ¶æ€åˆ‡æ¢æ—¶å…³é—­/å¼€å¯è‡ªåŠ¨æ—‹è½¬
            if (state === 'CONVERGED') {
                controls.autoRotate = true;
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.targetPos.x,
                        y: p.targetPos.y,
                        z: p.targetPos.z,
                        duration: 1.5,
                        ease: "power2.inOut"
                    });
                    gsap.to(p.mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
                    if(p.isPhoto) gsap.to(p.mesh.rotation, { x: 0, y: 0, z: 0, duration: 1 });
                });
            } else if (state === 'DISPERSED') {
                controls.autoRotate = false; // æ‰‹åŠ¿æ§åˆ¶æ—¶å…³æ‰è‡ªåŠ¨æ—‹è½¬
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.scatterPos.x,
                        y: p.scatterPos.y,
                        z: p.scatterPos.z,
                        duration: 2,
                        ease: "power2.out"
                    });
                    if (p.isPhoto) gsap.to(p.mesh.scale, { x: 5, y: 5, z: 1, duration: 1 });
                });
            } else if (state === 'ZOOM') {
                const photoParticles = particles.filter(p => p.isPhoto);
                if (photoParticles.length > 0) {
                    const target = photoParticles[Math.floor(Math.random() * photoParticles.length)];
                    activeZoomParticle = target;
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    const targetPos = camera.position.clone().add(camDir.multiplyScalar(20)); // è·ç¦»è°ƒæ•´
                    gsap.to(target.mesh.position, { x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1 });
                    gsap.to(target.mesh.scale, { x: 15, y: 15, z: 1, duration: 1 });
                    gsap.to(target.mesh.rotation, { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z, duration: 1});
                }
            }
        }

        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;
            const textureLoader = new THREE.TextureLoader();
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        for(let i=0; i<8; i++) { // å¢åŠ æ¯å¼ ç…§ç‰‡å¯¹åº”çš„ç²’å­æ•°
                            const randIdx = Math.floor(Math.random() * particles.length);
                            const p = particles[randIdx];
                            p.isPhoto = true;
                            p.mesh.geometry = new THREE.PlaneGeometry(1, 1);
                            p.mesh.material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
                            p.mesh.lookAt(camera.position);
                        }
                    };
                };
                reader.readAsDataURL(file);
            });
            alert("ç…§ç‰‡å·²ä¸Šä¼ ï¼è¯·å¼ å¼€æ‰‹æŒæŸ¥çœ‹ç…§ç‰‡äº‘æ•ˆæœã€‚");
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            if (state === 'DISPERSED') {
                particles.forEach((p, i) => {
                    p.mesh.position.y += Math.sin(time + i) * 0.05;
                    p.mesh.rotation.y += 0.02;
                });
            }
            controls.update();
            composer.render();
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MediaPipe (ä¿æŒä¸å˜) ---
        function initMediaPipe() {
            const videoElement = document.getElementById('video-element');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onHandsResults);
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start();
        }

        function onHandsResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
            const landmarks = results.multiHandLandmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const isFingerOpen = (tip, baseIdx) => tip.y < landmarks[baseIdx].y; 
            const indexOpen = isFingerOpen(landmarks[8], 5);
            const middleOpen = isFingerOpen(landmarks[12], 9);
            const ringOpen = isFingerOpen(landmarks[16], 13);
            const pinkyOpen = isFingerOpen(landmarks[20], 17);
            const fingersOpenCount = [indexOpen, middleOpen, ringOpen, pinkyOpen].filter(Boolean).length;
            const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

            if (pinchDist < 0.05) { if (state !== 'ZOOM') updateState('ZOOM'); } 
            else if (fingersOpenCount >= 3) { 
                if (state !== 'DISPERSED') updateState('DISPERSED');
                if (state === 'DISPERSED') group.rotation.y += (landmarks[9].x - 0.5) * 0.1;
            } 
            else if (fingersOpenCount === 0) { if (state !== 'CONVERGED') updateState('CONVERGED'); }
        }
    </script>
</body>
</html>
