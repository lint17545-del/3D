<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Matrix (V18.0 Classic Logic)</title>
    <style>
        /* ç»å…¸æ·±è“èƒŒæ™¯ */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center bottom, #001122 0%, #000000 100%); font-family: "Microsoft YaHei", sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #00f3ff; pointer-events: none; user-select: none;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.6);
        }
        h1 { margin: 0; font-weight: 800; letter-spacing: 4px; font-size: 32px; color: #ffffff; }
        .subtitle { font-size: 14px; color: #0088ff; letter-spacing: 2px; margin-top: 5px; }
        .version-tag { font-size: 10px; color: #00ff00; margin-top: 10px; border: 1px solid #00ff00; display: inline-block; padding: 2px 6px; background: rgba(0,0,0,0.8);}
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #00f3ff;
            flex-direction: column; transition: opacity 0.5s;
        }
        #start-btn {
            margin-top: 30px; padding: 12px 40px; background: transparent; color: #00f3ff;
            border: 2px solid #00f3ff; cursor: pointer; font-size: 16px; font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.4); display: none;
        }
        #start-btn:hover { background: #00f3ff; color: #000; }
        
        #upload-btn {
            pointer-events: auto; background: rgba(0, 30, 60, 0.8);
            border: 1px solid #00f3ff; color: #00f3ff; padding: 8px 15px;
            cursor: pointer; margin-top: 15px; display: inline-block; font-size: 12px;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
        
        .guide-text { margin-top: 10px; font-size: 12px; color: #88aacc; line-height: 1.8; }
        .hl { color: #fff; font-weight: bold; }
    </style>
</head>
<body>
    <div id="loader">
        <div style="font-size: 28px; font-weight: bold; letter-spacing: 5px;">èƒ½æºçŸ©é˜µ</div>
        <div id="loading-text" style="font-size: 12px; color: #666; margin-top: 10px;">æ­£åœ¨åŠ è½½ V3.4 æ ¸å¿ƒå¼•æ“...</div>
        <button id="start-btn">å¯åŠ¨ç³»ç»Ÿ</button>
    </div>

    <div id="ui-layer">
        <h1>æ™ºæ…§èƒ½æº</h1>
        <div class="subtitle">Interactive Particle System V18.0</div>
        <div class="version-tag">Classic CPU Physics</div>
        <div class="status" id="gesture-status">ç­‰å¾…æŒ‡ä»¤...</div>
        <div class="guide-text">
            <span class="hl">ğŸ– å¼ å¼€æ‰‹</span> : ç²’å­ç‚¸è£‚æ•£å¼€ (SCATTER)<br>
            <span class="hl">âœŒï¸ å‰ªåˆ€æ‰‹</span> : èšåˆ/è¿è¡Œ (ASSEMBLE)<br>
            <span class="hl">ğŸ‘Œ æåˆ</span> : æŠ“å–ç…§ç‰‡ (GRAB)<br>
            <span class="hl">ğŸ–±ï¸ é¼ æ ‡</span> : è§†è§’æ—‹è½¬
        </div>
        <label id="upload-btn">
            [+] ä¸Šä¼ ç…§ç‰‡
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- æ ¸å¿ƒå˜é‡ (å›å½’ V3.4 æ¶æ„) ---
        const CONFIG = { 
            particleCount: 15000, // CPU å¤„ç† 1.5ä¸‡ä¸ªç‚¹æ˜¯æµç•…æé™
            cameraZ: 85,
            colors: { blue: 0x00f3ff, gold: 0xffaa00, white: 0xffffff, grey: 0x556677 }
        };
        const STATE = { mode: 'ENERGY', handVisible: false, handX: 0.5, handY: 0.5 };
        
        let scene, camera, renderer, composer, particlesMesh, photoGroup, dummy = new THREE.Object3D();
        const particlesData = [], photosData = [];
        let time = 0;

        window.onload = function() {
            const btn = document.getElementById('start-btn');
            setTimeout(() => { btn.style.display = 'block'; }, 2000); // 2ç§’å¼ºåˆ¶æ˜¾ç¤º
            btn.onclick = () => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                initThree();
                try { startAI(); } catch(e) {}
            };
        };

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000811, 0.0015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, CONFIG.cameraZ);
            camera.lookAt(0, 15, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // è¾‰å…‰
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.2; bloomPass.strength = 1.0; bloomPass.radius = 0.5;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene); composer.addPass(bloomPass);
            } catch(e) { composer = null; }

            createIndustrialParticles(); // æ ¸å¿ƒç”Ÿæˆå‡½æ•°
            
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            document.addEventListener('mousemove', e => {
                if(!STATE.handVisible && STATE.mode === 'SCATTER') {
                    // é¼ æ ‡æ¼«æ¸¸
                    const x = (e.clientX/window.innerWidth-0.5)*2;
                    const y = (e.clientY/window.innerHeight-0.5)*2;
                    camera.position.x += (x*30 - camera.position.x)*0.05;
                    camera.position.y += (-y*20 + 20 - camera.position.y)*0.05;
                    camera.lookAt(0, 15, 0);
                }
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if(composer) composer.setSize(window.innerWidth, window.innerHeight);
            });
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            
            animate();
        }

        // --- æ ¸å¿ƒï¼šV3.4 é£æ ¼çš„ç²’å­ç”Ÿæˆä¸ç®¡ç† ---
        function createIndustrialParticles() {
            // ä½¿ç”¨ InstancedMesh (é«˜æ€§èƒ½ CPU æ§åˆ¶)
            // ç²’å­å½¢çŠ¶ï¼šå°å››é¢ä½“ (æ›´æœ‰ç§‘æŠ€æ„Ÿ)
            const geo = new THREE.TetrahedronGeometry(0.3, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            particlesMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
            
            const col = new THREE.Color();
            let pIndex = 0;

            // è¾…åŠ©ï¼šæ·»åŠ ç²’å­æ•°æ®
            function addP(x, y, z, colorHex, type) {
                if(pIndex >= CONFIG.particleCount) return;
                
                // è®¾ç½®é¢œè‰²
                col.setHex(colorHex);
                particlesMesh.setColorAt(pIndex, col);
                
                // åˆå§‹ä½ç½®
                dummy.position.set(x, y, z);
                dummy.scale.setScalar(1);
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(pIndex, dummy.matrix);

                // **å…³é”®**ï¼šä¿å­˜â€œå®¶â€å’Œâ€œè¿œæ–¹â€
                particlesData.push({
                    idx: pIndex,
                    current: new THREE.Vector3(x, y, z), // å½“å‰ä½ç½®
                    home: new THREE.Vector3(x, y, z),    // ç›®æ ‡å½¢æ€ä½ç½®
                    scatter: new THREE.Vector3(          // æ•£å¼€ä½ç½® (éšæœºç‚¸å¼€)
                        (Math.random()-0.5) * 200,
                        (Math.random()-0.5) * 100 + 20,
                        (Math.random()-0.5) * 100
                    ),
                    type: type, // 0:å¡”, 1:é£æœºå¶ç‰‡, 2:å…‰ä¼, 3:è£…é¥°
                    speed: 0.05 + Math.random() * 0.05, // è¿åŠ¨é€Ÿåº¦
                    offset: Math.random() * 100 // åŠ¨ç”»ç›¸ä½
                });
                pIndex++;
            }

            // === 1. å‡‰æ°´å¡” (åŒæ›²é¢) ===
            const towerCenter = {x: 10, z: -10};
            for(let y=0; y<40; y+=0.8) {
                let r = 8 * Math.sqrt(1 + Math.pow((y-30)/30, 2) * 0.8); // ç®€å•çš„åŒæ›²çº¿æ¨¡æ‹Ÿ
                let count = Math.floor(r * 6);
                for(let i=0; i<count; i++) {
                    let a = (i/count) * Math.PI * 2;
                    let px = towerCenter.x + Math.cos(a)*r;
                    let pz = towerCenter.z + Math.sin(a)*r;
                    // éšæœºç»™ç‚¹é¢œè‰²å˜åŒ–
                    let c = (Math.random()>0.8) ? CONFIG.colors.white : CONFIG.colors.blue;
                    addP(px, y, pz, c, 0);
                }
            }

            // === 2. é£æœº (åŠ¨æ€) ===
            const windPos = {x: -25, z: -10};
            // å¡”æŸ±
            for(let y=0; y<35; y+=0.5) {
                for(let i=0; i<8; i++) {
                    let a = (i/8)*Math.PI*2;
                    addP(windPos.x + Math.cos(a)*1.5, y, windPos.z + Math.sin(a)*1.5, CONFIG.colors.white, 0);
                }
            }
            // å¶ç‰‡ (ç²’å­æ•°æ®æ ‡è®°ä¸º Type 1)
            // æˆ‘ä»¬ç”Ÿæˆâ€œæ°´å¹³â€çš„å¶ç‰‡ï¼ŒåŠ¨ç”»æ—¶å†è½¬
            for(let b=0; b<3; b++) {
                for(let l=2; l<22; l+=0.5) {
                    let w = 1.5 * Math.sin((l/22)*Math.PI);
                    for(let k=-w/2; k<w/2; k+=0.3) {
                        // åŸå§‹ä½ç½®åªæ˜¯ä¸ºäº†å­˜å‚¨ï¼ŒåŠ¨ç”»é‡Œä¼šè¦†ç›–
                        addP(windPos.x, 35+l, windPos.z+k, CONFIG.colors.white, 1); 
                        // è¿™é‡Œæˆ‘ä»¬ç”¨ particlesData çš„ extra data æ¥å­˜å¶ç‰‡ä¿¡æ¯
                        let lastP = particlesData[particlesData.length-1];
                        lastP.bladeInfo = { bladeIdx: b, len: l, width: k }; // å­˜ä¸‹æ¥ç»™ CPU ç®—æ—‹è½¬
                    }
                }
            }

            // === 3. å…‰ä¼ ===
            for(let x=-30; x<10; x+=3) {
                for(let z=5; z<25; z+=3) {
                    // æ¿å­
                    for(let i=0; i<5; i++) {
                        for(let j=0; j<3; j++) {
                            let px = x + i*0.5;
                            let pz = z + j*0.5;
                            let py = 2 + j*0.3; // å€¾æ–œ
                            let c = (i===0||i===4||j===0||j===2) ? CONFIG.colors.gold : 0x113355;
                            addP(px, py, pz, c, 2);
                        }
                    }
                }
            }

            scene.add(particlesMesh);
        }

        // --- æ ¸å¿ƒï¼šV3.4 çš„ CPU åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // 1. å†³å®šç›®æ ‡ä½ç½® (Target)
            //    - SCATTER æ¨¡å¼ï¼šç›®æ ‡æ˜¯ d.scatter
            //    - ENERGY æ¨¡å¼ï¼šç›®æ ‡æ˜¯ d.home (ä½†éƒ¨åˆ†éœ€è¦åŠ¨èµ·æ¥)
            
            // ä¼˜åŒ–ï¼šé£æœºæ—‹è½¬å‚æ•°
            let windAngle = time * 2; 
            const windCenter = new THREE.Vector3(-25, 35, -10);

            for(let i=0; i<CONFIG.particleCount; i++) {
                if(!particlesData[i]) break;
                const d = particlesData[i];
                let target = d.home; // é»˜è®¤å›å®¶

                // å¦‚æœæ˜¯â€œè¿è¡Œâ€çŠ¶æ€ï¼Œè®¡ç®—åŠ¨æ€ä½ç½®
                if (STATE.mode === 'ENERGY' || STATE.mode === 'OPERATING') {
                    // é£æœºå¶ç‰‡ CPU æ—‹è½¬
                    if (d.type === 1 && d.bladeInfo) {
                        // é‡æ–°è®¡ç®—å¶ç‰‡ä½ç½®
                        let angleOffset = (d.bladeInfo.bladeIdx / 3) * Math.PI * 2;
                        let totalAngle = windAngle + angleOffset;
                        if(STATE.mode === 'OPERATING') totalAngle = time * 8 + angleOffset; // åŠ é€Ÿ

                        let l = d.bladeInfo.len;
                        let w = d.bladeInfo.width;
                        
                        // ç®€å•çš„ 2D æ—‹è½¬ (Zè½´)
                        let rx = l * Math.cos(totalAngle) - w * Math.sin(totalAngle);
                        let ry = l * Math.sin(totalAngle) + w * Math.cos(totalAngle);
                        
                        target = new THREE.Vector3(windCenter.x + rx, windCenter.y + ry, windCenter.z);
                    }
                    // å…‰ä¼é—ªçƒ
                    if (d.type === 2) {
                        // ä¸éœ€è¦åŠ¨ä½ç½®ï¼Œåªæ˜¯æƒ³åŠ¨é¢œè‰²ï¼ŸInstancedMesh æ”¹é¢œè‰²æ¯”è¾ƒè´µï¼Œæˆ‘ä»¬åŠ¨ä¸€ä¸‹é«˜åº¦ä»£æ›¿é—ªçƒ
                        if (Math.sin(time*5 + d.current.x) > 0.8) d.current.y += 0.02;
                    }
                }

                // 2. æœ€ç»ˆç›®æ ‡åˆ¤å®š
                let finalDest = (STATE.mode === 'SCATTER') ? d.scatter : target;

                // 3. ç‰©ç†æ’å€¼ (Lerp) - è¿™å°±æ˜¯ä½ è¦çš„â€œé£è¿‡å»â€çš„æ•ˆæœ
                // æ•£å¼€æ—¶å¿«ä¸€ç‚¹ï¼Œèšåˆæ—¶æ…¢ä¸€ç‚¹
                let lerpSpeed = (STATE.mode === 'SCATTER') ? 0.05 : 0.08;
                d.current.lerp(finalDest, lerpSpeed);

                // 4. æ›´æ–°çŸ©é˜µ
                dummy.position.copy(d.current);
                // æ•£å¼€æ—¶åŠ ç‚¹æ—‹è½¬
                if(STATE.mode === 'SCATTER') {
                    dummy.rotation.x += 0.05;
                    dummy.rotation.y += 0.05;
                } else {
                    dummy.rotation.set(0,0,0);
                }
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate = true;

            // ç…§ç‰‡é€»è¾‘
            photosData.forEach(p => {
                const d = p.userData;
                let tgt = (STATE.mode === 'SCATTER') ? d.scat : d.home;
                if(d.focus) {
                    const v = new THREE.Vector3(0,0,-20).applyQuaternion(camera.quaternion);
                    tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position);
                } else {
                    p.lookAt(camera.position);
                }
                p.position.lerp(tgt, 0.05);
            });

            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        // --- æ‚é¡¹ ---
        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }
        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8*aspect, 8), mat);
            const border = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.PlaneGeometry(8*aspect, 8)), new THREE.LineBasicMaterial({color:0x00f3ff}));
            mesh.add(border);
            // åˆå§‹ä½ç½®ï¼šå¡”é¡¶
            mesh.position.set(10, 45, -10);
            mesh.userData = { 
                home: mesh.position.clone(), 
                scat: new THREE.Vector3((Math.random()-0.5)*150, (Math.random()-0.5)*100, (Math.random()-0.5)*150),
                focus: false 
            };
            photoGroup.add(mesh); photosData.push(mesh);
        }

        // --- AI æ‰‹åŠ¿ ---
        async function startAI() {
            const video = document.getElementsByClassName('input_video')[0];
            const stat = document.getElementById('gesture-status');
            if(typeof Hands === 'undefined') { stat.innerText = "ä»…é¼ æ ‡æ¨¡å¼"; return; }
            const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults(res => {
                if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    const lm = res.multiHandLandmarks[0];
                    STATE.handVisible = true;
                    
                    // 1. æ•°æ‰‹æŒ‡ (æœ€ç¨³)
                    let openCount = 0;
                    if(lm[8].y < lm[6].y) openCount++;
                    if(lm[12].y < lm[10].y) openCount++;
                    if(lm[16].y < lm[14].y) openCount++;
                    if(lm[20].y < lm[18].y) openCount++;

                    // 2. æåˆ
                    const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;

                    if(pinch) {
                        stat.innerText = "ğŸ‘Œ æŠ“å– (GRAB)";
                        if(photosData.length>0 && STATE.mode!=='SCATTER') {
                            photosData.forEach(p=>p.userData.focus=false);
                            photosData[photosData.length-1].userData.focus = true;
                        }
                    } else if(openCount >= 4) {
                        STATE.mode = 'SCATTER'; stat.innerText = "ğŸ– ç²’å­ç‚¸è£‚ (SCATTER)";
                        photosData.forEach(p=>p.userData.focus=false);
                    } else if(openCount === 2) {
                        STATE.mode = 'OPERATING'; stat.innerText = "âœŒï¸ è¿è¡Œ (RUN)";
                    } else {
                        STATE.mode = 'ENERGY'; stat.innerText = "âœŠ èšåˆ (ASSEMBLE)";
                    }
                } else {
                    STATE.handVisible = false;
                    stat.innerText = "ç­‰å¾…æŒ‡ä»¤...";
                }
            });
            const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
            await cam.start(); stat.innerText = "AI æ¿€æ´»";
        }
    </script>
</body>
</html>
