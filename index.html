
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNY Red Horse (Skeleton V8.0)</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #220000 0%, #000000 100%); font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #ffd700; pointer-events: none; user-select: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.9);
        }
        h1 { margin: 0; font-weight: bold; letter-spacing: 3px; font-size: 28px; color: #ff3333; text-shadow: 0 0 15px rgba(255, 0, 0, 0.8); }
        .version-tag { font-size: 10px; color: #00ff00; margin-bottom: 10px; border: 1px solid #00ff00; display: inline-block; padding: 2px 5px; background: rgba(0,0,0,0.7);}
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a0000; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #ff3333;
            flex-direction: column; transition: opacity 0.5s;
        }
        #start-btn {
            padding: 15px 40px; background: #ffd700; color: #550000;
            border: 2px solid #ff3333; cursor: pointer; font-weight: bold; font-size: 16px;
            border-radius: 50px; box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); display: none;
        }
        #loading-text { margin-top: 10px; color: #aa5555; font-size: 14px; }
        
        #upload-btn {
            pointer-events: auto; background: rgba(50, 0, 0, 0.8);
            border: 1px solid #ffd700; color: #ffd700; padding: 8px 15px;
            cursor: pointer; margin-top: 15px; display: inline-block;
            font-size: 12px; border-radius: 4px; text-transform: uppercase;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
    </style>
</head>
<body>
    <div id="loader">
        <div id="loading-text">æ­£åœ¨ç»„è£…éª¨éª¼ç²’å­ (Assembling Skeleton)...</div>
        <button id="start-btn">å¼€å¯æ–°å¹´ (START)</button>
    </div>

    <div id="ui-layer">
        <h1>é¾™é©¬ç²¾ç¥ Â· 2026</h1>
        <div class="version-tag">Ver 8.0 (Skeleton Rig)</div>
        <div class="status" id="gesture-status">ç­‰å¾…å¯åŠ¨...</div>
        <div style="margin-top:5px; font-size:12px; color:#ffaaaa; line-height: 1.5;">
            âœŒï¸ å‰ªåˆ€æ‰‹: å¥”è·‘ (Gallop) | ğŸ– å¼ å¼€: æ¼«æ¸¸ <br>
            ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡
        </div>
        <label id="upload-btn">
            ä¸Šä¼ ç…§ç‰‡ (Upload Photos)
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- å…¨å±€å˜é‡ ---
        const CONFIG = { 
            cameraZ: 60, 
            colors: { red: 0xff0000, gold: 0xffcc00, white: 0xffffff } 
        };
        const STATE = { mode: 'HORSE', handVisible: false, handX: 0.5, handY: 0.5, gesture: 'NONE', runSpeed: 0 };
        
        let scene, camera, renderer, composer;
        let photoGroup;
        let raycaster = new THREE.Raycaster();
        let centerVector = new THREE.Vector2(0, 0); 
        let photosData = [];
        let currentLookAt = new THREE.Vector3(0, 5, 0);
        let runTime = 0;

        // éª¨éª¼ç³»ç»Ÿå˜é‡
        let horseRoot; // æ•´ä¸ªé©¬çš„å®¹å™¨
        let joints = {}; // å­˜å‚¨æ‰€æœ‰å…³èŠ‚ä»¥ä¾¿åŠ¨ç”»æ§åˆ¶
        let horseParts = []; // å­˜å‚¨æ‰€æœ‰å¸¦ç²’å­çš„éƒ¨åˆ†

        window.onload = function() {
            const startBtn = document.getElementById('start-btn');
            const loadingText = document.getElementById('loading-text');
            
            // ç®€å•æ£€æµ‹ Three.js
            if(typeof THREE === 'undefined') {
                loadingText.innerText = "èµ„æºåŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°";
                return;
            }

            loadingText.style.display = 'none';
            startBtn.style.display = 'block';

            startBtn.addEventListener('click', () => {
                document.getElementById('loader').style.opacity = 0; 
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                initThree(); 
                startCamera(); 
            });
        };

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // è§†é¢‘åŒæ¬¾ï¼šåº•éƒ¨äº‘é›¾ï¼ŒèƒŒæ™¯æ˜Ÿç©º
            scene.fog = new THREE.FogExp2(0x110000, 0.002); 

            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000); 
            camera.position.set(0, 10, CONFIG.cameraZ);
            camera.lookAt(0, 5, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; 
            container.appendChild(renderer.domElement);

            // ç¯å…‰ï¼šæ¨¡ä»¿è§†é¢‘é‡Œçš„è½®å»“å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.1));
            const sunLight = new THREE.DirectionalLight(0xffd700, 1.5); // é‡‘è‰²ä¸»å…‰
            sunLight.position.set(20, 30, 20);
            scene.add(sunLight);
            const rimLight = new THREE.SpotLight(0xff0000, 5.0); // çº¢è‰²è¾¹ç¼˜å…‰
            rimLight.position.set(-20, 10, -10);
            rimLight.lookAt(0,0,0);
            scene.add(rimLight);
            
            // è¾‰å…‰
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.5; bloomPass.strength = 1.0; bloomPass.radius = 0.5;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
            } catch(e) { composer = null; }

            // === æ ¸å¿ƒï¼šæ„å»ºéª¨éª¼é©¬ ===
            buildHorseSkeleton();
            
            // ç…§ç‰‡ç»„
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            // äº‘é›¾åœ°é¢
            createCloudFloor();

            // äº‹ä»¶
            document.addEventListener('mousemove', e => {
                if (!STATE.handVisible && STATE.mode === 'SCATTER') updateCameraFromInput(e.clientX/window.innerWidth, e.clientY/window.innerHeight);
            });
            document.addEventListener('click', e => {
                if(['upload-btn', 'file-input', 'start-btn'].includes(e.target.id)) return;
                if(!STATE.handVisible && photosData.length > 0) { STATE.mode = STATE.mode === 'HORSE' ? 'SCATTER' : 'HORSE'; }
            });
            window.addEventListener('resize', onResize);
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            
            animate();
        }

        // --- 1. éª¨éª¼æ„å»ºç³»ç»Ÿ ---
        // è¿™æ˜¯ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œç”¨æ¥åˆ›å»ºä¸€ä¸ªå¡«å……äº†ç²’å­çš„â€œèº«ä½“éƒ¨ä»¶â€
        function createParticleBone(geo, count, color, scale = 1) {
            // 1. åœ¨å‡ ä½•ä½“è¡¨é¢/å†…éƒ¨é‡‡æ ·ç‚¹
            const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({visible: false}));
            const sampler = new THREE.Mesh(geo); // ä¸´æ—¶ç”¨
            const posAttribute = geo.getAttribute('position');
            
            // ç²’å­å‡ ä½•ä½“ (èŠ±ç“£/è±å½¢)
            const pGeo = new THREE.TetrahedronGeometry(0.15 * scale, 0);
            pGeo.scale(1, 1.5, 0.5);
            
            const pMat = new THREE.MeshBasicMaterial({ color: color });
            const instancedMesh = new THREE.InstancedMesh(pGeo, pMat, count);
            
            const dummy = new THREE.Object3D();
            const tempVec = new THREE.Vector3();

            for(let i=0; i<count; i++) {
                // ç®€å•çš„ä½“ç§¯é‡‡æ ·ï¼šéšæœºå–é¡¶ç‚¹æ’å€¼ï¼Œæˆ–è€…ç›´æ¥ç”¨åŒ…å›´ç›’éšæœºå‰”é™¤
                // è¿™é‡Œç”¨ç®€åŒ–çš„åŒ…å›´ç›’æ³•ï¼Œæ•ˆç‡é«˜
                // ä¸ºäº†å½¢çŠ¶å‡†ç¡®ï¼Œæˆ‘ä»¬ç”¨å‡ ä½•ä½“é¡¶ç‚¹éšæœºåŠ æƒ
                const a = Math.floor(Math.random() * posAttribute.count);
                const b = Math.floor(Math.random() * posAttribute.count);
                const c = Math.floor(Math.random() * posAttribute.count);
                
                const w1 = Math.random(); const w2 = Math.random(); const w3 = Math.random();
                const s = w1 + w2 + w3;
                
                tempVec.x = (posAttribute.getX(a)*w1 + posAttribute.getX(b)*w2 + posAttribute.getX(c)*w3) / s;
                tempVec.y = (posAttribute.getY(a)*w1 + posAttribute.getY(b)*w2 + posAttribute.getY(c)*w3) / s;
                tempVec.z = (posAttribute.getZ(a)*w1 + posAttribute.getZ(b)*w2 + posAttribute.getZ(c)*w3) / s;

                // ç¨å¾®æŠ–åŠ¨å¢åŠ ä½“ç§¯æ„Ÿ
                tempVec.x += (Math.random()-0.5)*0.2;
                tempVec.y += (Math.random()-0.5)*0.2;
                tempVec.z += (Math.random()-0.5)*0.2;

                dummy.position.copy(tempVec);
                dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                dummy.scale.setScalar(0.5 + Math.random());
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
            }
            
            mesh.add(instancedMesh);
            horseParts.push({ mesh: instancedMesh, baseMatrix: instancedMesh.instanceMatrix.clone() }); // ä¿å­˜ä»¥ä¾¿æ•£å¼€åŠ¨ç”»
            return mesh;
        }

        function buildHorseSkeleton() {
            horseRoot = new THREE.Group();
            scene.add(horseRoot);
            
            const red = CONFIG.colors.red;
            const gold = CONFIG.colors.gold;

            // 1. èº«ä½“ (Torso) - æ ¸å¿ƒ
            // ä½¿ç”¨æ‹‰é•¿çš„çƒä½“
            const bodyGeo = new THREE.SphereGeometry(3.5, 16, 16);
            bodyGeo.scale(1, 0.8, 1.8); 
            joints.body = createParticleBone(bodyGeo, 800, red, 1.2);
            joints.body.position.set(0, 8, 0);
            horseRoot.add(joints.body);

            // 2. è„–å­ (Neck) - è¿åœ¨èº«ä½“ä¸Š
            const neckGeo = new THREE.CylinderGeometry(1.2, 2.5, 5, 8);
            // è°ƒæ•´ä¸­å¿ƒç‚¹ï¼Œè®©æ—‹è½¬è½´åœ¨åº•éƒ¨
            neckGeo.translate(0, 2.5, 0); 
            // ç¨å¾®å¼¯æ›²ä¸€ç‚¹é€ å‹
            joints.neck = createParticleBone(neckGeo, 400, red);
            joints.neck.position.set(0, 1.5, 4.5); // èº«ä½“å‰æ–¹åä¸Š
            joints.neck.rotation.x = Math.PI / 4; // æ˜‚èµ·
            joints.body.add(joints.neck);

            // 3. å¤´ (Head)
            const headGeo = new THREE.BoxGeometry(2, 2.5, 4.5);
            headGeo.translate(0, 0, 1.5); // é¼»å­å‘å‰
            joints.head = createParticleBone(headGeo, 250, gold); // é‡‘è‰²çš„å¤´
            joints.head.position.set(0, 5, 0); // è„–å­é¡¶ç«¯
            joints.head.rotation.x = -Math.PI / 6; // å¾®å¾®ä½å¤´
            joints.neck.add(joints.head);

            // 4. å››è‚¢ (Legs) - å…³é”®çš„å…³èŠ‚ç»“æ„
            // è¾…åŠ©å‡½æ•°ï¼šé€ è…¿
            function createLeg(offsetX, offsetZ, isBack) {
                const legGroup = new THREE.Group();
                legGroup.position.set(offsetX, 0, offsetZ);
                
                // å¤§è…¿ (Thigh)
                const thighGeo = new THREE.CylinderGeometry(1.2, 0.8, 4.5, 6);
                thighGeo.translate(0, -2.25, 0); // è½´å¿ƒåœ¨é¡¶ç«¯
                const thigh = createParticleBone(thighGeo, 150, red);
                legGroup.add(thigh);

                // å°è…¿ (Shin)
                const shinGeo = new THREE.CylinderGeometry(0.7, 0.5, 4, 6);
                shinGeo.translate(0, -2, 0);
                const shin = createParticleBone(shinGeo, 120, isBack ? red : gold); // å‰è…¿é‡‘è‰²
                shin.position.set(0, -4.5, 0);
                thigh.add(shin);

                // è¹„å­ (Hoof)
                const hoofGeo = new THREE.CylinderGeometry(0.6, 0.8, 1.5, 6);
                hoofGeo.translate(0, -0.75, 0);
                const hoof = createParticleBone(hoofGeo, 80, gold);
                hoof.position.set(0, -4, 0);
                shin.add(hoof);

                return { root: legGroup, thigh: thigh, shin: shin, hoof: hoof };
            }

            // å‰å·¦ FL
            joints.fl = createLeg(1.8, 4, false);
            joints.body.add(joints.fl.root);
            
            // å‰å³ FR
            joints.fr = createLeg(-1.8, 4, false);
            joints.body.add(joints.fr.root);

            // åå·¦ BL
            joints.bl = createLeg(1.8, -4, true);
            joints.body.add(joints.bl.root);

            // åå³ BR
            joints.br = createLeg(-1.8, -4, true);
            joints.body.add(joints.br.root);

            // 5. é¬ƒæ¯›å’Œå°¾å·´ (ç²’å­æµ)
            // å°¾å·´
            const tailGeo = new THREE.ConeGeometry(1, 7, 8);
            tailGeo.translate(0, -3.5, 0);
            tailGeo.rotateX(-Math.PI/4);
            joints.tail = createParticleBone(tailGeo, 300, gold);
            joints.tail.position.set(0, 1, -5);
            joints.body.add(joints.tail);
        }

        function createCloudFloor() {
            const geo = new THREE.PlaneGeometry(200, 200, 20, 20);
            const mat = new THREE.MeshBasicMaterial({ color: 0x440000, transparent: true, opacity: 0.3, wireframe: true });
            const floor = new THREE.Mesh(geo, mat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -8;
            scene.add(floor);
        }

        // --- 2. åŠ¨ç”»ç³»ç»Ÿ ---
        function updateHorseAnimation(time, speed) {
            // å¦‚æœé€Ÿåº¦ä¸º0ï¼Œè¿›å…¥å‘¼å¸å¾…æœºçŠ¶æ€
            const t = time * (3 + speed * 8); // å¥”è·‘é¢‘ç‡
            
            // èº«ä½“èµ·ä¼
            horseRoot.position.y = Math.sin(t * 2) * 0.5 * speed;
            horseRoot.rotation.x = Math.sin(t) * 0.1 * speed; // èº«ä½“å‰åæ‘‡æ‘†

            // è„–å­å’Œå¤´
            joints.neck.rotation.x = Math.PI / 4 + Math.sin(t) * 0.1;
            joints.head.rotation.x = -Math.PI / 6 + Math.cos(t) * 0.1;

            // è…¿éƒ¨æ­¥æ€ (Gallop/Canter Cycle)
            // å‰åè…¿ç›¸ä½å·®ï¼Œå·¦å³ç›¸ä½å·®
            // ç®€åŒ–çš„è·‘æ­¥é€»è¾‘ï¼š
            // FL & FR ç¨å¾®é”™å¼€, BL & BR ç¨å¾®é”™å¼€
            
            const animateLeg = (leg, offset) => {
                // å¤§è…¿æ‘†åŠ¨
                const thighAngle = Math.sin(t + offset) * 0.8 * speed;
                leg.thigh.rotation.x = thighAngle;
                
                // å°è…¿ (è†ç›–) - åªèƒ½å‘åå¼¯
                const shinAngle = Math.sin(t + offset - 1.5) * 0.8 * speed;
                leg.shin.rotation.x = Math.abs(shinAngle); // è†ç›–å¼¯æ›²
                
                // è¹„å­
                leg.hoof.rotation.x = Math.sin(t + offset - 1.0) * 0.5 * speed;
            };

            // å‰è…¿
            animateLeg(joints.fl, 0);
            animateLeg(joints.fr, 0.5); // ç¨å¾®é”™å¼€

            // åè…¿ (åç›¸)
            animateLeg(joints.bl, Math.PI);
            animateLeg(joints.br, Math.PI + 0.5);

            // å°¾å·´
            joints.tail.rotation.x = Math.sin(time * 5) * 0.2 + (speed * 0.5); // è·‘èµ·æ¥å°¾å·´ç¿˜é«˜
            joints.tail.rotation.z = Math.cos(time * 8) * 0.3; // å·¦å³æ‘†
        }

        // --- 3. æ•£å¼€ä¸èšåˆ ---
        function updateScatter(isScatter, time) {
            // æˆ‘ä»¬ä¸ä¸€ä¸ªä¸ªç§»åŠ¨ç²’å­ï¼Œè€Œæ˜¯æŠŠæ•´ä¸ªéª¨éª¼ç‚¸å¼€
            // æˆ–è€…ï¼šéå†æ‰€æœ‰ horsePartsï¼Œä¿®æ”¹ instancedMesh çš„çŸ©é˜µ
            // è¿™é‡Œä¸ºäº†æ€§èƒ½ï¼Œæˆ‘ä»¬åšä¸ªç®€å•çš„ï¼šå¦‚æœæ•£å¼€ï¼Œå°±æ—‹è½¬æ•´ä¸ª horseParts é‡Œçš„ç²’å­
            
            horseParts.forEach((part, index) => {
                const mesh = part.mesh;
                const count = mesh.count;
                const dummy = new THREE.Object3D();
                
                // å¦‚æœæ˜¯æ•£å¼€æ¨¡å¼ï¼Œæˆ‘ä»¬éœ€è¦æ¯å¸§æ›´æ–°ç²’å­ä½ç½®ï¼ˆæ€§èƒ½æ¶ˆè€—å¤§ï¼Œä½†æ•ˆæœå¥½ï¼‰
                // ä¸ºäº†æµç•…ï¼Œæˆ‘ä»¬åªåœ¨åˆ‡æ¢æ—¶åšä¸€ä¸ªè¿‡æ¸¡ï¼Œæˆ–è€…åªè®©å®ƒä»¬æ•´ä½“è†¨èƒ€
                
                // ç®€å•æ–¹æ¡ˆï¼šæ•£å¼€æ—¶ï¼Œè®©æ•´ä¸ªé©¬é€æ˜åº¦é™ä½ï¼Œæ˜¾ç¤ºå‘¨å›´çš„éšæœºç…§ç‰‡
                // æˆ–è€…ï¼šè®©éª¨éª¼å…³èŠ‚ä¹±é£
                if (isScatter) {
                    // è®©å…³èŠ‚ä¹±é£
                    mesh.parent.rotation.x += 0.01;
                    mesh.parent.rotation.y += 0.02;
                    mesh.parent.position.add(new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)));
                } else {
                    // å¤ä½é€»è¾‘åœ¨ updateHorseAnimation é‡Œä¼šè¦†ç›– rotation/position
                    // ä½†éœ€è¦æŠŠ position çš„ç´¯ç§¯åç§»æ¸…é›¶
                    if (mesh.parent !== horseRoot && mesh.parent.parent !== horseRoot) {
                         // è¿™æœ‰ç‚¹å¤æ‚ï¼Œå› ä¸ºæ˜¯å±‚çº§ç»“æ„ã€‚
                         // V8.0 ç­–ç•¥ï¼šæ•£å¼€æ¨¡å¼ä¸‹ï¼Œä»…ä»…åˆ‡æ¢ç›¸æœºè§†è§’ï¼Œä¸åšç²’å­ç‚¸æ•£ï¼Œ
                         // å› ä¸ºéª¨éª¼ç²’å­ç‚¸æ•£å¾ˆéš¾å¤åŸã€‚
                         // æ›¿ä»£æ–¹æ¡ˆï¼šæ•£å¼€æ—¶ï¼Œé©¬å˜é€æ˜/æ¶ˆå¤±ï¼Œæ˜¾ç¤ºç…§ç‰‡æµ·ã€‚
                    }
                }
            });
            
            if (isScatter) {
                horseRoot.visible = Math.sin(time * 10) > 0; // é—ªçƒæ•ˆæœ
                horseRoot.visible = false; // ç›´æ¥éšè—é©¬ï¼Œçœ‹ç…§ç‰‡
            } else {
                horseRoot.visible = true;
            }
        }

        // --- 4. ä¸»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            // çŠ¶æ€æ§åˆ¶
            let targetSpeed = 0;
            if (STATE.gesture === 'VICTORY') targetSpeed = 1.2; // ç‹‚å¥”
            else if (STATE.gesture === 'FIST') targetSpeed = 0; // åœæ­¢
            else targetSpeed = 0.2; // æ…¢èµ° (é»˜è®¤)

            // å¹³æ»‘é€Ÿåº¦
            STATE.runSpeed += (targetSpeed - STATE.runSpeed) * 0.05;
            runTime += STATE.runSpeed * 0.1;

            if (STATE.mode === 'HORSE') {
                updateHorseAnimation(runTime, STATE.runSpeed);
                horseRoot.visible = true;
                
                // å¥”è·‘æ—¶ç›¸æœºè·Ÿéšéœ‡åŠ¨
                if (STATE.runSpeed > 0.5) {
                    camera.position.y = 10 + Math.sin(time * 20) * 0.2;
                }
            } else {
                // æ•£å¼€æ¨¡å¼ï¼šéšè—é©¬
                horseRoot.visible = false;
            }

            // ç…§ç‰‡åŠ¨ç”»
            photosData.forEach(p => {
                const d = p.userData; 
                let tgt = (STATE.mode === 'SCATTER') ? d.scat : d.tree; // d.tree æ˜¯æ”¶æ‹¢ä½ç½®
                
                // å¦‚æœæ˜¯é©¬æ¨¡å¼ï¼Œç…§ç‰‡æ”¶æ‹¢åˆ°é©¬å‘¨å›´ç¯ç»•
                if (STATE.mode === 'HORSE') {
                    // è®©ç…§ç‰‡åœ¨é©¬å‘¨å›´è½¬åœˆ
                    const angle = time * 0.5 + d.angleOffset;
                    tgt.x = Math.cos(angle) * 20;
                    tgt.z = Math.sin(angle) * 20;
                    tgt.y = 10 + Math.sin(time + d.angleOffset)*5;
                }

                let scale = 1;
                if(d.focus) {
                    const v = new THREE.Vector3(0,0,-15).applyQuaternion(camera.quaternion); 
                    tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position); scale=3.0; 
                } else {
                    p.lookAt(camera.position);
                }
                d.cur.lerp(tgt, 0.04); 
                p.position.copy(d.cur); 
                p.scale.lerp(new THREE.Vector3(scale,scale,scale), 0.1);
            });

            // ç›¸æœºæ§åˆ¶
            if(STATE.mode==='SCATTER' && STATE.handVisible) {
                updateCameraFromInput(STATE.handX, STATE.handY);
            } else {
                // è‡ªåŠ¨è§†è§’
                camera.position.lerp(new THREE.Vector3(0, 10, CONFIG.cameraZ), 0.05);
                camera.lookAt(0, 5, 0);
            }

            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        // --- æ‚é¡¹ ---
        function updateCameraFromInput(x, y) {
            const theta = (x-0.5) * 4 * Math.PI; 
            const phi = (1-y) * Math.PI * 0.5 + 0.2; 
            const r = CONFIG.cameraZ;
            camera.position.x = r * Math.sin(theta) * Math.sin(phi);
            camera.position.z = r * Math.cos(theta) * Math.sin(phi);
            camera.position.y = r * Math.cos(phi) + 10;
            camera.lookAt(0, 5, 0);
        }

        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }

        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.generateMipmaps=true; tex.encoding = THREE.sRGBEncoding;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(5*aspect, 5), mat);
            const frame = new THREE.Mesh(new THREE.BoxGeometry(5*aspect+0.2, 5.2, 0.1), new THREE.MeshStandardMaterial({color:0xffffff}));
            mesh.position.z = 0.06; frame.add(mesh);
            frame.userData = { 
                angleOffset: Math.random() * Math.PI * 2,
                scat: new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*80, (Math.random()-0.5)*100), 
                cur: new THREE.Vector3(0,0,0), focus: false 
            };
            photoGroup.add(frame); photosData.push(frame);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(composer) composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- AI ---
        async function startCamera() {
            const video = document.getElementsByClassName('input_video')[0];
            try {
                const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
                hands.onResults(onResults);
                const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
                await cam.start(); 
                document.getElementById('gesture-status').innerText = "AI Ready!";
            } catch(e) { console.error(e); }
        }

        function onResults(res) {
            const status = document.getElementById('gesture-status');
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                STATE.handVisible = true; 
                const lm = res.multiHandLandmarks[0];
                STATE.handX = 1 - lm[0].x; STATE.handY = lm[0].y;
                
                // ç®€å•çš„æ‰‹åŠ¿åˆ¤æ–­
                // Pinch
                const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;
                // V-Sign (Index & Middle up, others down)
                const isIndexUp = lm[8].y < lm[5].y;
                const isMiddleUp = lm[12].y < lm[9].y;
                const isRingDown = lm[16].y > lm[13].y;
                
                if(pinch) {
                    STATE.gesture = 'PINCH'; status.innerText = "ğŸ‘Œ æŠ“å– (Grab)";
                    // ç®€å•çš„æŠ“å–é€»è¾‘
                    if(photosData.length > 0) {
                         // æ‰¾åˆ°æœ€è¿‘çš„
                         photosData.forEach(p => p.userData.focus = false);
                         photosData[photosData.length-1].userData.focus = true;
                         STATE.mode = 'ZOOM';
                    }
                } else if (isIndexUp && isMiddleUp && isRingDown) {
                    STATE.gesture = 'VICTORY'; STATE.mode = 'HORSE'; status.innerText = "âœŒï¸ å¥”è·‘ (Gallop)";
                } else if (!isIndexUp && !isMiddleUp) { // Fist-ish
                    STATE.gesture = 'FIST'; STATE.mode = 'HORSE'; status.innerText = "âœŠ åœæ­¢ (Stop)";
                } else {
                    STATE.gesture = 'OPEN'; STATE.mode = 'SCATTER'; status.innerText = "ğŸ– æ¼«æ¸¸ (Scatter)";
                }
            } else {
                STATE.handVisible = false;
                status.innerText = "No Hand";
            }
        }
    </script>
</body>
</html>
