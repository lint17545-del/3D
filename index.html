<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Tree (V3.4 Stable)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #ffffff; pointer-events: none; user-select: none;
            text-shadow: 0 1px 3px rgba(0,0,0,0.9);
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; font-size: 24px; color: #d4af37; text-shadow: 0 0 15px rgba(212, 175, 55, 0.8); }
        
        .version-tag { font-size: 10px; color: #00ffea; margin-bottom: 10px; border: 1px solid #00ffea; display: inline-block; padding: 2px 5px; background: rgba(0,0,0,0.7);}
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #d4af37;
            flex-direction: column; transition: opacity 0.5s;
        }
        #start-btn {
            padding: 12px 30px; border: 1px solid #d4af37; background: rgba(212, 175, 55, 0.1);
            color: #d4af37; font-size: 16px; cursor: pointer; letter-spacing: 2px;
            transition: 0.3s; margin-top: 20px; display: none;
        }
        #start-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 20px #d4af37; }
        #loading-text { margin-top: 10px; color: #888; font-size: 14px; }
        
        #upload-btn {
            pointer-events: auto; background: rgba(50, 50, 50, 0.8);
            border: 1px solid #ffffff; color: #ffffff; padding: 8px 15px;
            cursor: pointer; margin-top: 15px; display: inline-block;
            font-size: 12px; border-radius: 4px; text-transform: uppercase;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
        
        #console-log { position: fixed; bottom: 0; left: 0; width: 100%; height: 100px; background: rgba(0,0,0,0.8); color: red; font-size: 10px; pointer-events: none; z-index: 999; overflow: auto; display: none; }
    </style>
</head>
<body>
    <div id="console-log"></div>
    <div id="loader">
        <div id="loading-text">Loading Assets...</div>
        <button id="start-btn">START CAMERA</button>
    </div>

    <div id="ui-layer">
        <h1>NOEL PARTICLES</h1>
        <div class="version-tag">Ver 3.4 (Anti-Dizzy & Easy Grab)</div>
        <div class="status" id="gesture-status">Wait for start...</div>
        <div style="margin-top:5px; font-size:12px; color:#ccc; line-height: 1.5;">
            âœŠFist: Tree | ğŸ–Open: Look Around <br>
            ğŸ‘ŒPinch: Grab (Center of screen)
        </div>
        <label id="upload-btn">
            Upload Photos (Upload multiple!)
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        function log(msg) { const el = document.getElementById('console-log'); el.style.display='block'; el.innerHTML+=`> ${msg}<br>`; console.log(msg); }
        window.onload = function() {
            const startBtn = document.getElementById('start-btn'); const loadingText = document.getElementById('loading-text');
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') { log("Error: Not HTTPS."); loadingText.innerText="Please use HTTPS"; return; }
            loadingText.style.display = 'none'; startBtn.style.display = 'block';
            startBtn.addEventListener('click', () => {
                document.getElementById('loader').style.opacity = 0; setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                initThree(); startCamera(); 
            });
        };

        const CONFIG = { particleCount: 1600, treeHeight: 50, baseRadius: 18, colors: { green: 0x1a3322, gold: 0xffd700, red: 0xb30000 }, cameraZ: 65 };
        const STATE = { mode: 'TREE', handVisible: false, handX: 0.5, handY: 0.5, gesture: 'NONE' };
        let scene, camera, renderer, composer, particlesMesh, photoGroup, dummy = new THREE.Object3D();
        let raycaster = new THREE.Raycaster();
        const centerVector = new THREE.Vector2(0, 0); 
        const particlesData = [], photosData = [];
        
        // V3.4 æ–°å¢ï¼šè§†è§’å¹³æ»‘æ§åˆ¶å˜é‡
        let lookAtTarget = new THREE.Vector3(0, 10, 0);
        let currentLookAt = new THREE.Vector3(0, 10, 0);

        function initThree() {
            try {
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x020202, 0.0008); 

                camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000); 
                camera.position.set(0, 12, CONFIG.cameraZ);
                camera.lookAt(0, 10, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.4; 
                container.appendChild(renderer.domElement);

                scene.add(new THREE.AmbientLight(0xffffff, 0.15));
                const l1 = new THREE.PointLight(CONFIG.colors.gold, 2.5, 150); l1.position.set(10,30,30); scene.add(l1);
                const l2 = new THREE.PointLight(CONFIG.colors.red, 1.5, 120); l2.position.set(-15,0,15); scene.add(l2);

                try {
                    const renderScene = new THREE.RenderPass(scene, camera);
                    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.8);
                    bloomPass.threshold = 0.7; bloomPass.strength = 0.8; bloomPass.radius = 0.3;
                    composer = new THREE.EffectComposer(renderer);
                    composer.addPass(renderScene);
                    composer.addPass(bloomPass);
                } catch(e) { log("Bloom skipped."); composer = null; }

                createParticles();
                photoGroup = new THREE.Group();
                scene.add(photoGroup);

                document.addEventListener('mousemove', e => {
                    if (!STATE.handVisible && STATE.mode === 'SCATTER') updateCameraFromInput(e.clientX/window.innerWidth, e.clientY/window.innerHeight);
                });
                document.addEventListener('click', e => {
                    if(['upload-btn', 'file-input', 'start-btn'].includes(e.target.id)) return;
                    if(!STATE.handVisible && photosData.length > 0) { STATE.mode = STATE.mode === 'TREE' ? 'SCATTER' : 'TREE'; }
                });

                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    if(composer) composer.setSize(window.innerWidth, window.innerHeight);
                });
                document.getElementById('file-input').addEventListener('change', handleImageUpload);
                animate();
            } catch(err) { log("3D Init Error: " + err.message); }
        }

        function createParticles() {
            const geo = new THREE.IcosahedronGeometry(0.4, 1);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.8 });
            particlesMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
            const col = new THREE.Color();
            for(let i=0; i<CONFIG.particleCount; i++) {
                const p = i/CONFIG.particleCount;
                const angle = p * Math.PI * 22; 
                const r = CONFIG.baseRadius * (1-p*p*0.8);
                const tx = Math.cos(angle)*r + (Math.random()-0.5)*2;
                const tz = Math.sin(angle)*r + (Math.random()-0.5)*2;
                const ty = (CONFIG.treeHeight*p) - CONFIG.treeHeight/2 + 5;
                let t = Math.random();
                if(t>0.65) col.setHex(t>0.9 ? CONFIG.colors.red : CONFIG.colors.gold); else col.setHex(CONFIG.colors.green);
                particlesMesh.setColorAt(i, col);
                dummy.position.set(tx, ty, tz);
                dummy.scale.setScalar(0.5+Math.random());
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
                
                // ã€ä¿®æ”¹1ï¼šç´§å‡‘ç©ºé—´ã€‘èŒƒå›´ç¼©å°è‡³ 80ï¼Œæ›´å¯†é›†ï¼Œæ›´å®¹æ˜“è§¦è¾¾
                particlesData.push({ idx: i, cur: new THREE.Vector3(tx,ty,tz), tree: new THREE.Vector3(tx,ty,tz), 
                    scat: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80), 
                    speed: 0.01+Math.random()*0.02 });
            }
            scene.add(particlesMesh);
        }

        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }

        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.generateMipmaps=true; tex.encoding = THREE.sRGBEncoding;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, fog: false, toneMapped: false });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(5*aspect, 5), mat);
            const frame = new THREE.Mesh(new THREE.BoxGeometry(5*aspect+0.2, 5.2, 0.1), new THREE.MeshStandardMaterial({color:0xffffff, roughness: 0.4, metalness: 0.2}));
            mesh.position.z = 0.06; frame.add(mesh);
            const ty = Math.random()*CONFIG.treeHeight - CONFIG.treeHeight/2 + 5;
            frame.position.set(0, ty, 20);
            // ã€ä¿®æ”¹1ï¼šç´§å‡‘ç…§ç‰‡å¢™ã€‘èŒƒå›´ç¼©å°è‡³ 90
            frame.userData = { tree: new THREE.Vector3((Math.random()-0.5)*10, ty, CONFIG.baseRadius+2), 
                scat: new THREE.Vector3((Math.random()-0.5)*90, (Math.random()-0.5)*80, (Math.random()-0.5)*90), 
                cur: frame.position.clone(), focus: false };
            photoGroup.add(frame); photosData.push(frame);
        }

        function animate() {
            requestAnimationFrame(animate);
            const targetState = STATE.mode; const time = Date.now() * 0.0005;
            
            // ç²’å­è¿åŠ¨
            for(let i=0; i<CONFIG.particleCount; i++) {
                const d = particlesData[i]; let tgt = (targetState==='TREE'||targetState==='ZOOM') ? d.tree : d.scat;
                if(targetState!=='TREE') d.cur.y += Math.sin(time+i*0.1)*0.01;
                d.cur.lerp(tgt, d.speed); dummy.position.copy(d.cur);
                if(targetState==='SCATTER') { dummy.rotation.x+=0.005; dummy.rotation.y+=0.008; } else dummy.rotation.set(0,0,0);
                dummy.updateMatrix(); particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate=true;
            
            // ç…§ç‰‡è¿åŠ¨
            photosData.forEach(p => {
                const d = p.userData; let tgt = (targetState==='TREE') ? d.tree : d.scat; let scale = 1;
                if(d.focus) {
                    const v = new THREE.Vector3(0,0,-15).applyQuaternion(camera.quaternion); tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position); scale=3.0; 
                } else {
                    if(targetState!=='TREE') p.lookAt(camera.position); else p.lookAt(tgt.x*2, tgt.y, tgt.z*2);
                }
                d.cur.lerp(tgt, 0.04); p.position.copy(d.cur); p.scale.lerp(new THREE.Vector3(scale,scale,scale), 0.1);
            });

            // ã€ä¿®æ”¹2ï¼šç›¸æœºé€»è¾‘é‡æ„ã€‘
            if(STATE.mode==='SCATTER' && STATE.handVisible) {
                updateCameraFromInput(STATE.handX, STATE.handY);
            } 
            else if(STATE.mode==='TREE') {
                // å›åˆ°æ ‘å½¢æ€
                camera.position.lerp(new THREE.Vector3(0, 12, CONFIG.cameraZ), 0.03);
                currentLookAt.lerp(new THREE.Vector3(0, 10, 0), 0.05);
                camera.lookAt(currentLookAt);
            }
            
            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        // ã€ä¿®æ”¹2ï¼šé˜²æ™•è½¦é€»è¾‘ã€‘
        // æ‰‹åŠ¿ä¸å†æ§åˆ¶ç›¸æœºâ€œä½ç½®â€(Orbit)ï¼Œè€Œæ˜¯æ§åˆ¶ç›¸æœºâ€œæœå‘â€(LookAt)
        function updateCameraFromInput(x, y) {
            // 1. ç›¸æœºä½ç½®å¾®åŠ¨ (Parallax Effect)ï¼Œå¢åŠ ç«‹ä½“æ„Ÿä½†ä¸å¤§èŒƒå›´ç§»åŠ¨
            const targetCamX = (x - 0.5) * 20; 
            const targetCamY = (y - 0.5) * 10 + 12;
            camera.position.lerp(new THREE.Vector3(targetCamX, targetCamY, CONFIG.cameraZ), 0.05);

            //
