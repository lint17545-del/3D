<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D Particle V8 - The Final Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010103; font-family: 'Microsoft YaHei', sans-serif; }
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; opacity: 0.5; }
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 26px; color: #FFD700; letter-spacing: 2px; text-shadow: 0 0 15px rgba(255, 0, 0, 0.5); font-weight: bold; }
        .cycle-info { font-size: 20px; margin-top: 10px; color: #fff; font-weight: bold; }
        .status { font-size: 15px; color: rgba(255,255,255,0.7); margin-top: 5px; letter-spacing: 1px;}
        #upload-container { pointer-events: auto; display: inline-block; margin-top: 20px; }
        input[type="file"] { display: none; }
        .btn { background: linear-gradient(45deg, #C41E3A, #FFD700); border: none; padding: 10px 22px; color: #fff; font-size: 14px; font-weight: bold; cursor: pointer; border-radius: 30px; box-shadow: 0 0 15px rgba(255, 215, 0, 0.2); transition: all 0.3s; }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(255, 215, 0, 0.5); }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; z-index: 20; font-size: 18px; text-align: center; letter-spacing: 2px; }
        #hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 13px; letter-spacing: 1px; pointer-events: none; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loading">æ­£åœ¨è¿›è¡Œæœ€ç»ˆçš„é«˜å¯†åº¦è®¡ç®—...</div>
    <div id="ui-layer">
        <h1>ç²’å­å™äº‹ V8 (ç»ˆæä¿®æ­£)</h1>
        <div class="cycle-info" id="shape-name" style="color:#FFD700">ğŸ æˆ˜é©¬ (é«˜äº®çº¢é‡‘)</div>
        <div class="status" id="status-text">ç­‰å¾…æ‰‹åŠ¿...</div>
        <div id="upload-container">
            <label class="btn">+ æ³¨å…¥ç…§ç‰‡è®°å¿† <input type="file" id="file-input" multiple accept="image/*"></label>
        </div>
    </div>
    <div id="hint">âœŠæ¡æ‹³:èšåˆ | ğŸ–å…¨å¼ å¼€:æ•£å¼€ | ğŸ‘Œæåˆ:ç¨³å®šæŠ“å–ç…§ç‰‡(é”å®š2ç§’)</div>
    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="genCanvas" width="4096" height="2048" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        const CONFIG = {
            particleCount: 16000, // æé™å¯†åº¦
            maxPhotos: 30,
            colors: {
                horse: [0xD4AF37, 0xC41E3A, 0xFFD700, 0xFF0000], // æ›´äº®çš„çº¢é‡‘
                text:  [0x88CCFF], // æ˜Ÿå…‰è“
                spic:  [0x00008B],  // ææ·±è“
                logoGreen: 0x00FF00, logoRed: 0xFF0000
            },
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb'
        };

        let scene, camera, renderer, composer, mainGroup, photoGroup;
        let particles = []; let photoClouds = [];
        let state = 'CONVERGED'; let time = 0;
        let handPosition = { x: 0.5, y: 0.5 };
        let activeZoomPhoto = null;
        // æ ¸å¿ƒäº¤äº’å˜é‡ï¼šæŠ“å–é”
        let zoomLocked = false; let zoomTimeout = null;

        let currentShapeIndex = 0; 
        const SHAPES = { HORSE: [], TEXT: [], LOGO: [] };
        let pendingShapeChange = false;

        // å‡ ä½•ä½“
        const sphereGeom = new THREE.SphereGeometry(0.6, 8, 8); // åŠ å¤§
        const boxGeom = new THREE.BoxGeometry(0.8, 0.8, 0.8);

        init(); animate(); initMediaPipe();

        async function init() {
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x010103, 0.0008);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 4000);
            camera.position.set(0, 20, 400);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç¯å…‰ç‚¸è£‚
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const sun = new THREE.DirectionalLight(0xFFD700, 1.8); sun.position.set(100, 100, 50); scene.add(sun);
            const red = new THREE.PointLight(0xFF0000, 2.5, 600); red.position.set(-100, -50, 100); scene.add(red);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.7);
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

            mainGroup = new THREE.Group(); photoGroup = new THREE.Group();
            scene.add(mainGroup); scene.add(photoGroup);

            await generateAllShapes(); createParticles();
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            document.getElementById('loading').style.display = 'none';
        }

        // --- 1. å½¢æ€ç”Ÿæˆ (ç»ˆæç‰ˆ) ---
        async function generateAllShapes() {
            // A. é©¬ (é«˜å¯†åº¦é‡‡æ ·)
            await new Promise(r => new GLTFLoader().load(CONFIG.modelUrl, g => {
                SHAPES.HORSE = samplePoints(getPoints(g.scene.children[0], 1.3), CONFIG.particleCount); r();
            }));
            // B. æ–‡å­— (4Kç”»å¸ƒé«˜æ¸…æ™°åº¦)
            SHAPES.TEXT = generateTextPoints("é£å…‰æ— é™ å›½å®¶ç”µæŠ•");
            // C. Logo (è·¯å¾„ç»˜åˆ¶+æ‰«æï¼Œç¡®ä¿å½¢çŠ¶å‡†ç¡®)
            SHAPES.LOGO = generatePreciseLogo();
        }

        function generateTextPoints(text) {
            const ctx = document.getElementById('genCanvas').getContext('2d');
            ctx.clearRect(0,0,4096,2048);
            ctx.font = "bold 220px 'Microsoft YaHei'"; ctx.fillStyle = "white";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, 2048, 1024);
            return scanCanvas(ctx, 4096, 2048, 4, 25, CONFIG.particleCount); // é«˜å¯†åº¦æ‰«æ
        }

        function generatePreciseLogo() {
            const ctx = document.getElementById('genCanvas').getContext('2d');
            ctx.clearRect(0,0,4096,2048);
            ctx.fillStyle = "white";
            const cx = 1500, cy = 1024, r = 300, w = 120;
            // ç»˜åˆ¶å‡†ç¡®çš„ S å‹ä¸å¸¦è·¯å¾„
            ctx.beginPath();
            // ä¸ŠåŠç»¿ç¯
            ctx.arc(cx, cy - r + w/2, r, Math.PI*0.5, Math.PI*1.5, true);
            ctx.arc(cx, cy - r + w/2, r - w, Math.PI*1.5, Math.PI*0.5, false);
            ctx.fill();
            // ä¸‹åŠçº¢ç¯
            ctx.beginPath();
            ctx.arc(cx, cy + r - w/2, r, Math.PI*1.5, Math.PI*0.5, true);
            ctx.arc(cx, cy + r - w/2, r - w, Math.PI*0.5, Math.PI*1.5, false);
            ctx.fill();
            
            const ribbonPoints = scanCanvas(ctx, 3000, 2048, 6, 40, Math.floor(CONFIG.particleCount * 0.7));
            
            // SPIC æ–‡å­—
            ctx.clearRect(0,0,4096,2048);
            ctx.font = "bold 300px Arial";
            ctx.fillText("SPIC", 2600, 1024);
            const spicPoints = scanCanvas(ctx, 4096, 2048, 6, 10, CONFIG.particleCount - ribbonPoints.length);
            spicPoints.forEach(p => p.isSpic = true);

            return samplePoints(ribbonPoints.concat(spicPoints), CONFIG.particleCount);
        }

        function scanCanvas(ctx, w, h, step, depthVar, targetCount) {
            const data = ctx.getImageData(0,0,w,h).data;
            const points = [];
            for(let y=0; y<h; y+=step) {
                for(let x=0; x<w; x+=step) {
                    if(data[(y*w+x)*4+3] > 128) {
                        points.push(new THREE.Vector3((x-w/2)*0.2, -(y-h/2)*0.2, (Math.random()-0.5)*depthVar));
                    }
                }
            }
            return samplePoints(points, targetCount);
        }

        function getPoints(mesh, scale) {
            const pos = mesh.geometry.attributes.position; const pts = []; const v = new THREE.Vector3();
            for(let i=0; i<pos.count; i++) pts.push(v.fromBufferAttribute(pos,i).multiplyScalar(scale).clone());
            return pts;
        }
        function samplePoints(src, count) {
            if(!src.length) return [];
            const box = new THREE.Box3().setFromPoints(src); const c = box.getCenter(new THREE.Vector3());
            src.forEach(p => p.sub(c)); const res = [];
            for(let i=0; i<count; i++) res.push(src[i%src.length].clone());
            return res.sort(()=>Math.random()-0.5);
        }

        // --- 2. ç²’å­ç³»ç»Ÿ ---
        function createParticles() {
            for(let i=0; i<CONFIG.particleCount; i++) {
                // 30% é«˜äº®è£…é¥°ç²’å­
                const isDeco = Math.random() < 0.3;
                const mat = new THREE.MeshStandardMaterial({
                    color: 0xffffff, roughness: 0.3, metalness: 0.7,
                    emissive: 0x000000, emissiveIntensity: isDeco ? 1.2 : 0.3
                });
                const mesh = new THREE.Mesh(sphereGeom, mat);
                const scatterPos = new THREE.Vector3((Math.random()-0.5)*800, (Math.random()-0.5)*600, (Math.random()-0.5)*600);
                mesh.position.copy(scatterPos); mainGroup.add(mesh);
                particles.push({
                    mesh, targets: [SHAPES.HORSE[i], SHAPES.TEXT[i], SHAPES.LOGO[i]],
                    scatterPos, baseColor: new THREE.Color(), isDeco, seed: Math.random()
                });
            }
            updateVisuals(0); updateState('DISPERSED');
        }

        function updateVisuals(idx) {
            const isHorse=idx===0, isText=idx===1, isLogo=idx===2;
            const ui=document.getElementById('shape-name');
            if(isHorse){ui.innerText="ğŸ æˆ˜é©¬ (é«˜äº®çº¢é‡‘)"; ui.style.color="#FFD700";}
            else if(isText){ui.innerText="ğŸ’ æ–‡å­— (æ¸…æ™°æ˜Ÿå…‰è“)"; ui.style.color="#88CCFF";}
            else{ui.innerText="ğŸ—ï¸ Logo (ç²¾å‡†å½¢çŠ¶+æ·±è“SPIC)"; ui.style.color="#FF0000";}

            particles.forEach(p => {
                let hex, op=1, trans=false, geom=sphereGeom;
                if(isHorse) { hex = CONFIG.colors.horse[Math.floor(Math.random()*CONFIG.colors.horse.length)]; }
                else if(isText) { hex = CONFIG.colors.text[0]; geom=boxGeom; op=0.85; trans=true; }
                else if(isLogo) {
                    const t = p.targets[2];
                    // SPIC å¼ºåˆ¶æ·±è“ï¼Œä¸”ä¸å‘å…‰
                    if(t.isSpic) { hex = CONFIG.colors.spic[0]; p.isDeco=false; } 
                    else { hex = t.y>0 ? CONFIG.colors.logoGreen : CONFIG.colors.logoRed; }
                }
                p.baseColor.setHex(hex); p.mesh.geometry = p.isDeco ? sphereGeom : geom;
                p.mesh.material.transparent = trans;
                gsap.to(p.mesh.material.color, {r:p.baseColor.r, g:p.baseColor.g, b:p.baseColor.b, duration:0.6});
                gsap.to(p.mesh.material, {opacity:op, duration:0.6});
                gsap.to(p.mesh.material.emissive, {
                    r: p.isDeco?p.baseColor.r:0, g:p.isDeco?p.baseColor.g:0, b:p.isDeco?p.baseColor.b:0, duration:0.6
                });
            });
        }

        // --- 3. äº¤äº’ä¸çŠ¶æ€ (æ ¸å¿ƒä¿®å¤ï¼šæŠ“å–é”) ---
        function updateState(newState) {
            if (state === newState && state !== 'ZOOM') return;
            // æŠ“å–é”ï¼šå¦‚æœåœ¨é”å®šæœŸé—´ï¼Œç¦æ­¢åˆ‡æ¢åˆ° DISPERSED
            if (zoomLocked && newState === 'DISPERSED') return;

            if(state==='DISPERSED' && newState==='CONVERGED') {
                if(pendingShapeChange) { currentShapeIndex=(currentShapeIndex+1)%3; updateVisuals(currentShapeIndex); pendingShapeChange=false;}
            } else if (newState==='DISPERSED') pendingShapeChange=true;

            if (state==='ZOOM' && newState!=='ZOOM' && activeZoomPhoto) {
                 gsap.to(activeZoomPhoto.scale, {x:1,y:1,z:1, duration:0.8}); activeZoomPhoto=null;
            }
            state = newState;
            const stEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                stEl.innerText = "çŠ¶æ€: âœŠ èšåˆ (è·Ÿéšæ‰‹åŠ¿)";
                particles.forEach(p => gsap.to(p.mesh.position, {...p.targets[currentShapeIndex], duration: 1.2+p.seed*0.5, ease:"power2.inOut"}));
                photoClouds.forEach(p => { gsap.to(p.position, {...p.homePos, duration:1.5, ease:"power2.inOut"}); gsap.to(p.scale, {x:1,y:1,z:1, duration:1}); });
            } else if (state === 'DISPERSED') {
                stEl.innerText = "çŠ¶æ€: ğŸ– æ•£å¼€";
                particles.forEach(p => gsap.to(p.mesh.position, {...p.scatterPos, duration: 1.8, ease:"power3.out"}));
                photoClouds.forEach(p => { gsap.to(p.position, {...p.scatterPos, duration:2, ease:"power2.out"}); gsap.to(p.scale, {x:1.5,y:1.5,z:1.5, duration:1}); });
            } else if (state === 'ZOOM') {
                stEl.innerText = "çŠ¶æ€: ğŸ‘Œ æŠ“å–é”å®š (2ç§’)";
                // æ¿€æ´»æŠ“å–é”
                zoomLocked = true; clearTimeout(zoomTimeout);
                zoomTimeout = setTimeout(() => { zoomLocked = false; stEl.innerText = "çŠ¶æ€: ğŸ‘Œ æŠ“å–ç»“æŸ (è¯·å¼ å¼€æ‰‹)"; }, 2000); // 2ç§’é”
                
                if(photoClouds.length > 0) {
                    activeZoomPhoto = photoClouds[Math.floor(Math.random()*photoClouds.length)];
                    const vec = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                    const tPos = camera.position.clone().add(vec.multiplyScalar(40)); // æ›´è¿‘
                    gsap.to(activeZoomPhoto.position, {x:tPos.x, y:tPos.y, z:tPos.z, duration:1.2, ease:"power2.out"}); // æ…¢ä¸€ç‚¹
                    gsap.to(activeZoomPhoto.scale, {x:10, y:10, z:10, duration:1.2});
                    activeZoomPhoto.lookAt(camera.position);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate); time+=0.01;
            const tRotY = (handPosition.x-0.5)*3; const tRotX = (handPosition.y-0.5)*2;
            mainGroup.rotation.y += (tRotY - mainGroup.rotation.y)*0.08;
            mainGroup.rotation.x += (tRotX - mainGroup.rotation.x)*0.08;
            photoGroup.rotation.copy(mainGroup.rotation); // ç…§ç‰‡ç»„å®Œå…¨åŒæ­¥

            if(state==='DISPERSED') particles.forEach(p => { p.mesh.position.y+=Math.sin(time+p.seed*10)*0.15; p.mesh.position.x+=Math.cos(time+p.seed*10)*0.15; });
            photoClouds.forEach(p => { if(p!==activeZoomPhoto) p.lookAt(camera.position); });
            composer.render();
        }

        function handleFileUpload(e) {
            const files = e.target.files; if(!files.length) return;
            const limit = Math.min(files.length, CONFIG.maxPhotos);
            photoClouds.forEach(p=>photoGroup.remove(p)); photoClouds=[];
            Array.from(files).slice(0,limit).forEach((f,i)=>{
                const r = new FileReader();
                r.onload=ev=>{
                    const img=new Image(); img.src=ev.target.result;
                    img.onload=()=>{
                        const tex=new THREE.Texture(img); tex.needsUpdate=true; tex.colorSpace=THREE.SRGBColorSpace;
                        const mat=new THREE.MeshBasicMaterial({map:tex, side:THREE.DoubleSide, transparent:true, color:0xffffff}); // çº¯ç™½æ— æ»¤é•œ
                        const mesh=new THREE.Mesh(new THREE.PlaneGeometry(12,12), mat);
                        const ang=(i/limit)*Math.PI*2, rad=180;
                        mesh.homePos=new THREE.Vector3(Math.cos(ang)*rad, (Math.random()-0.5)*120, Math.sin(ang)*rad);
                        mesh.scatterPos=new THREE.Vector3((Math.random()-0.5)*900, (Math.random()-0.5)*700, (Math.random()-0.5)*900);
                        mesh.position.copy(mesh.scatterPos); photoGroup.add(mesh); photoClouds.push(mesh);
                    }
                }
                r.readAsDataURL(f);
            });
            alert(`å·²åŠ è½½ ${limit} å¼ ç…§ç‰‡ã€‚æåˆæ‰‹æŒ‡æŠ“å–ã€‚`);
        }

        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); }
        function initMediaPipe() {
            const v=document.getElementById('video-element'); const h=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            h.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.7, minTrackingConfidence:0.7});
            h.onResults(res=>{
                if(!res.multiHandLandmarks.length) return; const lm=res.multiHandLandmarks[0];
                handPosition.x=1-(lm[0].x+lm[9].x)/2; handPosition.y=(lm[0].y+lm[9].y)/2;
                const pinch=Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                let open=0; [8,12,16,20].forEach((t,i)=>{if(lm[t].y<lm[bases[i]].y)open++}); var bases=[5,9,13,17];
                
                if(pinch<0.04) { if(state!=='ZOOM') updateState('ZOOM'); } // æ›´çµæ•çš„æåˆ
                // åªæœ‰åœ¨å…¨å¼ å¼€ä¸”æ²¡æœ‰é”å®šçš„æƒ…å†µä¸‹æ‰æ•£å¼€
                else if(open>=4 && !zoomLocked) { if(state!=='DISPERSED') updateState('DISPERSED'); }
                else if(open<=1) { if(state!=='CONVERGED') updateState('CONVERGED'); }
            });
            new Camera(v,{onFrame:async()=>await h.send({image:v}),width:320,height:240}).start();
        }
    </script>
</body>
</html>
