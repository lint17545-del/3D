<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>SPIC V18 - China Optimized</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; }
        
        /* åŠ è½½å±‚ */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020205; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #00ffff; transition: opacity 0.5s;
        }
        .loader-text { font-size: 18px; margin-bottom: 20px; letter-spacing: 2px; }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #00ffff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* å¼ºåˆ¶å¯åŠ¨æŒ‰é’® (ç½‘ç»œé”™è¯¯æ—¶å‡ºç°) */
        #force-start-btn {
            margin-top: 30px; padding: 10px 25px;
            background: transparent; border: 1px solid #FF4500; color: #FF4500;
            cursor: pointer; display: none; font-size: 14px;
        }
        #force-start-btn:hover { background: #FF4500; color: #fff; }

        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .header { position: absolute; top: 30px; width: 100%; text-align: center; }
        h1 { margin: 0; font-size: 28px; color: #fff; text-shadow: 0 0 15px rgba(0,255,255,0.5); letter-spacing: 4px; }
        .status-pill {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); padding: 6px 20px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.2); color: #FFD700; font-size: 14px;
        }
        .controls { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 12px; }
        
        /* äº¤äº’å…‰æ ‡ */
        #cursor {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 30px; height: 30px; border: 1px solid rgba(255,255,255,0.3); border-radius: 50%;
            pointer-events: none; transition: 0.2s; z-index: 20;
        }
        #cursor.active { width: 50px; height: 50px; border-color: #00ff00; background: rgba(0,255,0,0.1); }

        #upload-btn {
            position: absolute; right: 20px; top: 20px; pointer-events: auto;
            border: 1px solid #00ffff; color: #00ffff; padding: 8px 15px; font-size: 12px; cursor: pointer;
        }
        input[type="file"] { display: none; }
        
        #video-element { position: absolute; bottom: 10px; left: 10px; width: 100px; opacity: 0.3; transform: scaleX(-1); pointer-events: none; }
    </style>

    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text" id="loader-msg">æ­£åœ¨è¿æ¥èµ„æº...</div>
        <button id="force-start-btn" onclick="forceStart()">ç½‘ç»œå¡é¡¿ï¼Ÿç‚¹å‡»å¼ºåˆ¶å¯åŠ¨ (æ— æ‰‹åŠ¿)</button>
    </div>

    <div id="ui-layer">
        <div class="header">
            <h1>SPIC èƒ½æºè§†ç•Œ V18</h1>
        </div>
        <div class="status-pill" id="status">ç³»ç»Ÿå°±ç»ª</div>
        <label id="upload-btn">+ æ³¨å…¥ç…§ç‰‡ <input type="file" id="file-input" multiple accept="image/*"></label>
        <div id="cursor"></div>
        <div class="controls">ğŸ–±ï¸é¼ æ ‡/ğŸ–æ‰‹åŠ¿å‡å¯æ§åˆ¶ | ç‚¹å‡»/æåˆæŠ“å– | ç§»åŠ¨æ—‹è½¬</div>
    </div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    <canvas id="genCanvas" width="2048" height="1024" style="display:none;"></canvas>

    <script>
        // --- æˆ˜é©¬éª¨éª¼æ•°æ® (ç¡¬ç¼–ç ) ---
        const HORSE_PTS = [
            0,20,10, 5,20,8, 10,22,5, 15,25,0, 20,28,-2, 25,20,-2, 28,15,-3, 20,5,0, 15,0,2, 
            -5,18,12, -15,18,10, -25,10,5, -5,5,10, -15,5,8, -20,8,5, 
            5,-10,5, 5,-30,5, -20,-10,5, -25,-30,8, -35,10,5
        ];

        // --- å…¨å±€å˜é‡ ---
        const CONFIG = { count: 20000 };
        let scene, camera, renderer, composer, particles, particleGeo;
        let photoGroup, photos = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // çŠ¶æ€
        const STATE = { mode: 'SCATTER', shapeIdx: 0, handX: 0.5, isHandActive: false, autoRot: 0 };
        const POSITIONS = { HORSE:[], TOWER:[], SCENE:[], TEXT:[], SCATTER:[] };
        
        let grabbedPhoto = null;
        let hoveredPhoto = null;

        // åˆå§‹åŒ–è¶…æ—¶æ£€æµ‹
        setTimeout(() => {
            if(document.getElementById('loader').style.display !== 'none') {
                document.getElementById('loader-msg').innerText = "AI ç»„ä»¶åŠ è½½ç¼“æ…¢...";
                document.getElementById('force-start-btn').style.display = "block";
            }
        }, 3000);

        function forceStart() {
            startApp(); // å¼ºåˆ¶è¿›å…¥
        }

        // æ ¸å¿ƒå¯åŠ¨å…¥å£
        window.onload = function() {
            // æ£€æŸ¥ Three.js æ˜¯å¦åŠ è½½æˆåŠŸ
            if (typeof THREE === 'undefined') {
                alert("Three.js åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æ›´æ¢ç½‘ç»œç¯å¢ƒã€‚");
                return;
            }
            startApp();
        };

        function startApp() {
            document.getElementById('loader').style.display = 'none';
            initThree();
            generateData();
            createParticles();
            switchMode('SCATTER');
            animate();
            
            // å°è¯•å¯åŠ¨ AIï¼Œå¤±è´¥ä¸å½±å“ä¸»ç¨‹åº
            try { initMediaPipe(); } catch(e) { console.log("AI Init failed, using mouse mode"); }
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 4000);
            camera.position.set(0, 0, 400);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            container.appendChild(renderer.domElement);

            // è¾‰å…‰
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.15; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            // äº‹ä»¶
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            });
            window.addEventListener('mousemove', e => {
                if(!STATE.isHandActive) STATE.handX = e.clientX / window.innerWidth;
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            window.addEventListener('click', onClick);
            document.getElementById('file-input').addEventListener('change', handleUpload);
        }

        // --- æ•°æ®ç”Ÿæˆ (æ•°å­¦ç®—æ³•) ---
        function generateData() {
            // 1. é©¬ (éª¨éª¼æ’å€¼)
            const horse = [];
            for(let i=0; i<CONFIG.count; i++) {
                const idx1 = Math.floor(Math.random()*(HORSE_PTS.length/3))*3;
                const idx2 = Math.floor(Math.random()*(HORSE_PTS.length/3))*3;
                const t = Math.random();
                let x = HORSE_PTS[idx1] + (HORSE_PTS[idx2]-HORSE_PTS[idx1])*t;
                let y = HORSE_PTS[idx1+1] + (HORSE_PTS[idx2+1]-HORSE_PTS[idx1+1])*t;
                let z = HORSE_PTS[idx1+2] + (HORSE_PTS[idx2+2]-HORSE_PTS[idx1+2])*t;
                x += (Math.random()-0.5)*8; y += (Math.random()-0.5)*8; z += (Math.random()-0.5)*5;
                horse.push(x*4, y*4, z*4);
            }
            POSITIONS.HORSE = new Float32Array(horse);

            // 2. å‡‰æ°´å¡” (åŒæ›²çº¿)
            const tower = []; const h=300;
            for(let i=0; i<CONFIG.count; i++) {
                const r = i/CONFIG.count; 
                const y = (r-0.5)*h; 
                const v = (y+h/2)/h;
                let rad = 70 * Math.sqrt(1 + Math.pow(v*2.2-1.3, 2)*0.6);
                if(r>0.9) rad = Math.random()*80; // è’¸æ±½
                const ang = r*Math.PI*100;
                tower.push(Math.cos(ang)*rad, y, Math.sin(ang)*rad);
            }
            POSITIONS.TOWER = new Float32Array(tower);

            // 3. é£å…‰äº’è¡¥
            const scene = [];
            const addWind = (ox, oz) => {
                for(let k=0; k<1500; k++) { // æŸ±
                    const y=(Math.random()-0.5)*220;
                    scene.push(ox+(Math.random()-0.5)*10, y, oz+(Math.random()-0.5)*10);
                }
                for(let k=0; k<3; k++) { // å¶
                    const ang = k/3*6.28;
                    for(let j=0; j<500; j++) {
                        const l = Math.random()*100;
                        scene.push(ox+Math.cos(ang)*l, 110+Math.sin(ang)*l, oz);
                    }
                }
            };
            addWind(-100, -50); addWind(100, 50);
            const remain = CONFIG.count - scene.length/3;
            for(let i=0; i<remain; i++) {
                const c = Math.floor(Math.random()*10); const r = Math.floor(Math.random()*5);
                scene.push((c-5)*40, -120, (r-2)*40+100);
            }
            POSITIONS.SCENE = new Float32Array(scene);

            // 4. æ–‡å­—
            POSITIONS.TEXT = createText("é£å…‰æ— é™  å›½å®¶ç”µæŠ•");

            // 5. æ•£å¼€
            POSITIONS.SCATTER = new Float32Array(CONFIG.count*3);
            for(let i=0; i<CONFIG.count*3; i++) POSITIONS.SCATTER[i] = (Math.random()-0.5)*1500;
        }

        function createText(t) {
            const c=document.getElementById('genCanvas').getContext('2d');
            c.clearRect(0,0,2048,1024); c.font="bold 200px 'Microsoft YaHei'"; 
            c.fillStyle="#fff"; c.textAlign="center"; c.textBaseline="middle"; 
            c.fillText(t,1024,512);
            const d=c.getImageData(0,0,2048,1024).data; const p=[]; const v=[];
            for(let y=0;y<1024;y+=8)for(let x=0;x<2048;x+=8)if(d[(y*2048+x)*4+3]>100)v.push({x,y});
            for(let i=0;i<CONFIG.count;i++){const pt=v[i%v.length]; p.push((pt.x-1024)*0.4, -(pt.y-512)*0.4, 0);}
            return new Float32Array(p);
        }

        function createParticles() {
            // è´´å›¾
            const cvs=document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx=cvs.getContext('2d');
            const g=ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32); const tex=new THREE.CanvasTexture(cvs);

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.count*3);
            const col = new Float32Array(CONFIG.count*3);
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

            const mat = new THREE.PointsMaterial({
                size: 2.2, map: tex, vertexColors: true,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        function switchMode(m) {
            STATE.mode = m;
            const st = document.getElementById('status');
            const cols = particles.geometry.attributes.color.array;
            let trg, c1, c2;

            if(m === 'SCATTER') {
                st.innerText = "ğŸ– ç”»å»Šæ¨¡å¼ (æŒ¥æ‰‹/é¼ æ ‡æ—‹è½¬)";
                st.style.color = "#00ffff";
                photos.forEach((p,i) => {
                    const a = i/photos.length * Math.PI * 2;
                    p.target.set(Math.cos(a)*250, (Math.random()-0.5)*100, Math.sin(a)*250);
                    p.mesh.lookAt(0,0,0);
                });
            } else if(m === 'MORPH') {
                photos.forEach(p => p.target.set(0,-2000,0)); // è—ç…§ç‰‡
                
                if(STATE.shapeIdx === 0) {
                    st.innerText = "ğŸ æˆ˜é©¬å½¢æ€"; st.style.color = "#FFD700";
                    c1 = new THREE.Color(0xFFD700); c2 = new THREE.Color(0xFF4500);
                } else if(STATE.shapeIdx === 1) {
                    st.innerText = "ğŸ’ å“ç‰Œæ„¿æ™¯"; st.style.color = "#88CCFF";
                    c1 = new THREE.Color(0x88CCFF); c2 = new THREE.Color(0xFFFFFF);
                } else if(STATE.shapeIdx === 2) {
                    st.innerText = "ğŸ­ ç»¿è‰²ç«ç”µ"; st.style.color = "#00FF00";
                    c1 = new THREE.Color(0x00BFFF); c2 = new THREE.Color(0x228B22);
                } else {
                    st.innerText = "âš¡ é£å…‰äº’è¡¥"; st.style.color = "#00FFAA";
                    c1 = new THREE.Color(0x00FF7F); c2 = new THREE.Color(0xFFA500);
                }

                for(let i=0; i<CONFIG.count; i++) {
                    const c = Math.random()>0.5 ? c1 : c2;
                    cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
                }
                particles.geometry.attributes.color.needsUpdate = true;
            } else if(m === 'ZOOM') {
                st.innerText = "ğŸ‘Œ æŠ“å–æˆåŠŸ"; st.style.color = "#FF00FF";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const positions = particles.geometry.attributes.position.array;
            let target;
            if(STATE.mode==='SCATTER' || STATE.mode==='ZOOM') target = POSITIONS.SCATTER;
            else if(STATE.shapeIdx===0) target = POSITIONS.HORSE;
            else if(STATE.shapeIdx===1) target = POSITIONS.TEXT;
            else if(STATE.shapeIdx===2) target = POSITIONS.TOWER;
            else target = POSITIONS.SCENE;

            for(let i=0; i<CONFIG.count; i++) {
                const x=i*3;
                positions[x] += (target[x] - positions[x]) * 0.08;
                positions[x+1] += (target[x+1] - positions[x+1]) * 0.08;
                positions[x+2] += (target[x+2] - positions[x+2]) * 0.08;
                
                if(STATE.mode==='SCATTER') positions[x+1] += Math.sin(Date.now()*0.002 + i)*0.2;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // æ—‹è½¬
            if(STATE.mode==='SCATTER') {
                STATE.autoRot += (STATE.handX - 0.5) * 0.05;
                photos.forEach((p,i) => {
                    if(p === grabbedPhoto) return;
                    const a = i/photos.length * Math.PI*2 + STATE.autoRot;
                    p.target.set(Math.cos(a)*250, (Math.random()-0.5)*100, Math.sin(a)*250);
                    p.mesh.lookAt(0,0,0);
                });
            } else if(STATE.mode==='MORPH') {
                particles.rotation.y += 0.003;
            }

            updatePhotos();
            composer.render();
        }

        function updatePhotos() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
            let best = null; let maxD = 0.96;

            photos.forEach(p => {
                p.mesh.position.lerp(p.target, 0.1);
                
                if(p === grabbedPhoto) {
                    const t = camera.position.clone().add(camDir.clone().multiplyScalar(30));
                    p.target.copy(t);
                    p.mesh.lookAt(camera.position);
                    p.mesh.scale.lerp(new THREE.Vector3(2,2,2), 0.1);
                } else if(STATE.mode==='SCATTER') {
                    const dir = p.mesh.position.clone().sub(camera.position).normalize();
                    const dot = camDir.dot(dir);
                    if(dot > maxD) { maxD = dot; best = p; }
                    p.mesh.scale.lerp(new THREE.Vector3(0.6,0.6,0.6), 0.1);
                }
            });

            const cur = document.getElementById('cursor');
            if(best && !grabbedPhoto) {
                hoveredPhoto = best;
                hoveredPhoto.mesh.scale.lerp(new THREE.Vector3(0.8,0.8,0.8), 0.2);
                cur.className = 'active';
            } else if(grabbedPhoto) {
                cur.className = 'active';
            } else {
                hoveredPhoto = null;
                cur.className = '';
            }
        }

        function handleUpload(e) {
            const f = e.target.files; if(!f.length) return;
            photos.forEach(p => photoGroup.remove(p.mesh)); photos = [];
            Array.from(f).forEach(file => {
                const r = new FileReader();
                r.onload = ev => {
                    const img = new Image(); img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img); tex.needsUpdate=true; 
                        const ar = img.width/img.height;
                        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(10*ar, 10), new THREE.MeshBasicMaterial({map:tex, side:THREE.DoubleSide}));
                        // è¾¹æ¡†
                        const border = new THREE.Mesh(new THREE.PlaneGeometry(10*ar+0.5, 10.5), new THREE.MeshBasicMaterial({color:0x00ffff}));
                        border.position.z = -0.1; mesh.add(border);
                        photoGroup.add(mesh);
                        photos.push({ mesh, target: new THREE.Vector3(0,-2000,0) });
                    }
                }
                r.readAsDataURL(file);
            });
            switchMode('SCATTER');
        }

        function onClick() {
            if(grabbedPhoto) { grabbedPhoto=null; switchMode('SCATTER'); }
            else if(hoveredPhoto) { grabbedPhoto=hoveredPhoto; switchMode('ZOOM'); }
            else if(STATE.mode==='SCATTER') {
                STATE.shapeIdx = (STATE.shapeIdx+1)%4; switchMode('MORPH');
            }
        }

        function initMediaPipe() {
            const v = document.getElementById('video-element');
            const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6});
            hands.onResults(res => {
                if(!res.multiHandLandmarks.length) { STATE.isHandActive=false; return; }
                STATE.isHandActive = true;
                const lm = res.multiHandLandmarks[0];
                STATE.handX = 1 - lm[9].x; 
                
                const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;
                let open=0; [8,12,16,20].forEach(t=>{if(lm[t].y<lm[t-2].y)open++});

                if(pinch) {
                    if(STATE.mode==='SCATTER' && hoveredPhoto) { grabbedPhoto=hoveredPhoto; switchMode('ZOOM'); }
                } else if(open>=4) {
                    if(STATE.mode==='ZOOM') { grabbedPhoto=null; switchMode('SCATTER'); }
                    else if(STATE.mode==='MORPH') switchMode('SCATTER');
                } else if(open<=1) {
                    if(STATE.mode==='SCATTER') { STATE.shapeIdx=(STATE.shapeIdx+1)%4; switchMode('MORPH'); }
                }
            });
            const cam = new Camera(v, {onFrame: async()=>{await hands.send({image:v})}, width:320, height:240});
            cam.start();
        }
    </script>
</body>
</html>
