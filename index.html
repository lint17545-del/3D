<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Tree (GitHub Edition)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #d4af37; pointer-events: none; user-select: none;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; font-size: 24px; text-shadow: 0 0 15px rgba(212, 175, 55, 0.6); }
        .version-tag { font-size: 10px; color: #666; margin-bottom: 10px; border: 1px solid #333; display: inline-block; padding: 2px 5px; }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #d4af37;
            flex-direction: column; transition: opacity 0.5s;
        }
        #start-btn {
            padding: 12px 30px; border: 1px solid #d4af37; background: rgba(212, 175, 55, 0.1);
            color: #d4af37; font-size: 16px; cursor: pointer; letter-spacing: 2px;
            transition: 0.3s; margin-top: 20px; display: none;
        }
        #start-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 20px #d4af37; }
        #loading-text { margin-top: 10px; color: #888; font-size: 14px; }
        
        #upload-btn {
            pointer-events: auto; background: rgba(20, 20, 20, 0.8);
            border: 1px solid #d4af37; color: #d4af37; padding: 8px 15px;
            cursor: pointer; margin-top: 15px; display: inline-block;
            font-size: 12px; border-radius: 4px; text-transform: uppercase;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
        
        /* ÈîôËØØÊó•Âøó */
        #console-log {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 100px;
            background: rgba(0,0,0,0.8); color: red; font-size: 10px;
            pointer-events: none; z-index: 999; overflow: auto; display: none;
        }
    </style>
</head>
<body>
    <div id="console-log"></div>

    <div id="loader">
        <div id="loading-text">Loading Assets (GitHub Mode)...</div>
        <button id="start-btn">START CAMERA</button>
    </div>

    <div id="ui-layer">
        <h1>NOEL PARTICLES</h1>
        <div class="version-tag">Ver 3.0 (GitHub Stable)</div>
        <div class="status" id="gesture-status">Wait for start...</div>
        <div style="margin-top:5px; font-size:12px; color:#aaa;">
            ‚úäFist: Tree | üñêOpen: Scatter | üëåPinch: Grab
        </div>
        <label id="upload-btn">
            Upload Photos
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        function log(msg) {
            const el = document.getElementById('console-log');
            el.style.display = 'block';
            el.innerHTML += `> ${msg}<br>`;
            console.log(msg);
        }

        window.onload = function() {
            const startBtn = document.getElementById('start-btn');
            const loadingText = document.getElementById('loading-text');

            // GitHub Pages HTTPS Check
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                log("Error: Not HTTPS. Camera blocked.");
                loadingText.innerText = "Please use HTTPS (GitHub Pages)";
                return;
            }

            loadingText.style.display = 'none';
            startBtn.style.display = 'block';

            startBtn.addEventListener('click', () => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                initThree();
                startCamera(); 
            });
        };

        const CONFIG = { particleCount: 1500, treeHeight: 45, baseRadius: 16, colors: { green: 0x1a3322, gold: 0xffd700, red: 0xb30000 }, cameraZ: 65 };
        const STATE = { mode: 'TREE', handVisible: false, handX: 0.5, handY: 0.5, gesture: 'NONE' };
        let scene, camera, renderer, composer, particlesMesh, photoGroup, dummy = new THREE.Object3D();
        const particlesData = [], photosData = [];

        function initThree() {
            try {
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x050505, 0.002);
                camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.set(0, 12, CONFIG.cameraZ);
                camera.lookAt(0, 10, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                container.appendChild(renderer.domElement);

                scene.add(new THREE.AmbientLight(0xffffff, 0.1));
                const l1 = new THREE.PointLight(CONFIG.colors.gold, 2.0, 120); l1.position.set(10,30,30); scene.add(l1);
                const l2 = new THREE.PointLight(CONFIG.colors.red, 1.5, 100); l2.position.set(-15,0,15); scene.add(l2);

                // Bloom Try-Catch
                try {
                    const renderScene = new THREE.RenderPass(scene, camera);
                    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                    bloomPass.threshold = 0.7; bloomPass.strength = 1.0; bloomPass.radius = 0.4;
                    composer = new THREE.EffectComposer(renderer);
                    composer.addPass(renderScene);
                    composer.addPass(bloomPass);
                } catch(e) { log("Bloom skipped."); composer = null; }

                createParticles();
                photoGroup = new THREE.Group();
                scene.add(photoGroup);

                // Inputs
                document.addEventListener('mousemove', e => {
                    if (!STATE.handVisible && STATE.mode === 'SCATTER') updateCameraFromInput(e.clientX/window.innerWidth, e.clientY/window.innerHeight);
                });
                document.addEventListener('click', e => {
                    if(['upload-btn', 'file-input', 'start-btn'].includes(e.target.id)) return;
                    if(!STATE.handVisible) { STATE.mode = STATE.mode === 'TREE' ? 'SCATTER' : 'TREE'; }
                });

                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    if(composer) composer.setSize(window.innerWidth, window.innerHeight);
                });
                document.getElementById('file-input').addEventListener('change', handleImageUpload);
                
                animate();
            } catch(err) { log("3D Init Error: " + err.message); }
        }

        function createParticles() {
            const geo = new THREE.IcosahedronGeometry(0.4, 1);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.8 });
            particlesMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
            const col = new THREE.Color();
            for(let i=0; i<CONFIG.particleCount; i++) {
                const p = i/CONFIG.particleCount;
                const angle = p * Math.PI * 22; 
                const r = CONFIG.baseRadius * (1-p*p*0.8);
                const tx = Math.cos(angle)*r + (Math.random()-0.5)*2;
                const tz = Math.sin(angle)*r + (Math.random()-0.5)*2;
                const ty = (CONFIG.treeHeight*p) - CONFIG.treeHeight/2 + 5;
                
                let t = Math.random();
                if(t>0.65) col.setHex(t>0.9 ? CONFIG.colors.red : CONFIG.colors.gold); else col.setHex(CONFIG.colors.green);
                particlesMesh.setColorAt(i, col);
                
                dummy.position.set(tx, ty, tz);
                dummy.scale.setScalar(0.5+Math.random());
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);

                particlesData.push({
                    idx: i, cur: new THREE.Vector3(tx,ty,tz), tree: new THREE.Vector3(tx,ty,tz),
                    scat: new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60),
                    speed: 0.015+Math.random()*0.03
                });
            }
            scene.add(particlesMesh);
        }

        function handleImageUpload(e) {
            const files = e.target.files;
            if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => createPhoto(img);
                };
                r.readAsDataURL(f);
            });
        }

        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.generateMipmaps=true;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(5*aspect, 5), mat);
            // Frame
            const frame = new THREE.Mesh(new THREE.BoxGeometry(5*aspect+0.2, 5.2, 0.1), new THREE.MeshStandardMaterial({color:0xffd700}));
            mesh.position.z = 0.06; frame.add(mesh);
            
            const ty = Math.random()*CONFIG.treeHeight - CONFIG.treeHeight/2 + 5;
            frame.position.set(0, ty, 20);
            frame.userData = {
                tree: new THREE.Vector3((Math.random()-0.5)*10, ty, CONFIG.baseRadius),
                scat: new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*50, (Math.random()-0.5)*80),
                cur: frame.position.clone(), focus: false
            };
            photoGroup.add(frame); photosData.push(frame);
        }

        function animate() {
            requestAnimationFrame(animate);
            const targetState = STATE.mode;
            const time = Date.now() * 0.0005;

            // Particles
            for(let i=0; i<CONFIG.particleCount; i++) {
                const d = particlesData[i];
                let tgt = (targetState==='TREE'||targetState==='ZOOM') ? d.tree : d.scat;
                if(targetState!=='TREE') d.cur.y += Math.sin(time+i)*0.01;
                d.cur.lerp(tgt, d.speed);
                dummy.position.copy(d.cur);
                if(targetState==='SCATTER') { dummy.rotation.x+=0.01; dummy.rotation.y+=0.01; } else dummy.rotation.set(0,0,0);
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate=true;

            // Photos
            photosData.forEach(p => {
                const d = p.userData;
                let tgt = (targetState==='TREE') ? d.tree : d.scat;
                let scale = 1;
                if(d.focus) {
                    const v = new THREE.Vector3(0,0,-12).applyQuaternion(camera.quaternion);
                    tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position); scale=2.5;
                } else {
                    if(targetState!=='TREE') p.lookAt(camera.position);
                    else p.lookAt(tgt.x*2, tgt.y, tgt.z*2);
                }
                d.cur.lerp(tgt, 0.05);
                p.position.copy(d.cur);
                p.scale.lerp(new THREE.Vector3(scale,scale,scale), 0.1);
            });

            // Camera
            if(STATE.mode==='SCATTER' && STATE.handVisible) updateCameraFromInput(STATE.handX, STATE.handY);
            else if(STATE.mode==='TREE') { camera.position.lerp(new THREE.Vector3(0,12,CONFIG.cameraZ), 0.04); camera.lookAt(0,10,0); }

            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        function updateCameraFromInput(x, y) {
            const theta = (x-0.5)*3 * Math.PI * 0.5;
            const phi = (1-y)*Math.PI*0.3 + 0.1;
            const cx = CONFIG.cameraZ * Math.sin(theta);
            const cz = CONFIG.cameraZ * Math.cos(theta);
            camera.position.lerp(new THREE.Vector3(cx, (y-0.5)*40+15, cz), 0.04);
            camera.lookAt(0, 8, 0);
        }

        // --- AI LOGIC ---
        async function startCamera() {
            log("Init AI...");
            const video = document.getElementsByClassName('input_video')[0];
            try {
                if(typeof Hands === 'undefined') throw new Error("Hands lib not loaded");
                
                const hands = new Hands({locateFile: (file) => {
                    return `https://unpkg.com/@mediapipe/hands/${file}`;
                }});
                
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
                hands.onResults(onResults);
                
                const camera = new Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 640, height: 480
                });
                
                await camera.start();
                document.getElementById('gesture-status').innerText = "AI Active!";
                log("Camera Started");
            } catch(e) {
                log("Cam Fail: " + e.message);
                document.getElementById('gesture-status').innerText = "Cam Failed. Mouse Mode.";
            }
        }

        function onResults(res) {
            const status = document.getElementById('gesture-status');
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                STATE.handVisible = true;
                const lm = res.multiHandLandmarks[0];
                STATE.handX = 1 - lm[0].x; STATE.handY = lm[0].y;
                
                // Gesture Logic
                const tips=[8,12,16,20], bases=[5,9,13,17];
                let open=0;
                tips.forEach((t,i) => { 
                    if(Math.hypot(lm[t].x-lm[0].x, lm[t].y-lm[0].y) > Math.hypot(lm[bases[i]].x-lm[0].x, lm[bases[i]].y-lm[0].y)*1.3) open++; 
                });
                if(Math.hypot(lm[4].x-lm[0].x, lm[4].y-lm[0].y)>0.15) open++;
                const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;

                if(pinch) { STATE.gesture='PINCH'; status.innerText="üëå Pinch"; checkPhoto(); }
                else if(open<=1) { STATE.gesture='FIST'; STATE.mode='TREE'; resetPhoto(); status.innerText="‚úä Fist"; }
                else if(open>=4) { 
                    STATE.gesture='OPEN'; 
                    if(STATE.mode==='ZOOM' && !pinch) { STATE.mode='SCATTER'; resetPhoto(); }
                    else if(STATE.mode!=='ZOOM') STATE.mode='SCATTER';
                    status.innerText="üñê Open"; 
                }
            } else {
                STATE.handVisible = false;
                status.innerText = "No Hand";
            }
        }
        function checkPhoto() {
            if(STATE.mode==='ZOOM' || !photosData.length) return;
            STATE.mode='ZOOM';
            photosData.forEach(p=>p.userData.focus=false);
            photosData[photosData.length-1].userData.focus=true;
        }
        function resetPhoto() { photosData.forEach(p=>p.userData.focus=false); }
    </script>
</body>
</html>
