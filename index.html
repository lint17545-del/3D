<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNY Running Horse (V21.0 Final Fix)</title>
    <style>
        /* çº¢åŒ…é£æ ¼æ·±çº¢èƒŒæ™¯ */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #550000 0%, #220000 100%); font-family: "Microsoft YaHei", sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #ffd700; pointer-events: none; user-select: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        h1 { margin: 0; font-weight: bold; letter-spacing: 4px; font-size: 28px; color: #ffd700; }
        .version-tag { font-size: 12px; color: #fff; margin-top: 5px; opacity: 0.8; }
        
        #status-box {
            margin-top: 15px; padding: 10px 20px;
            border: 2px solid #ffd700; background: rgba(0,0,0,0.5);
            font-size: 18px; font-weight: bold; color: #fff;
            display: inline-block; border-radius: 8px;
        }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #220000; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #ffd700;
            flex-direction: column; transition: opacity 0.5s;
        }
        
        #start-btn {
            margin-top: 30px; padding: 15px 50px; 
            background: #ffd700; color: #550000;
            border: 2px solid #fff; cursor: pointer;
            font-size: 18px; font-weight: bold;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
            border-radius: 50px; 
        }
        
        #upload-btn {
            pointer-events: auto; background: rgba(50, 0, 0, 0.6);
            border: 1px solid #ffd700; color: #ffd700; padding: 8px 15px;
            cursor: pointer; margin-top: 15px; display: inline-block; font-size: 12px;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
    </style>
</head>
<body>
    <div id="loader">
        <div style="font-size: 32px; font-weight: bold; letter-spacing: 5px;">é¾™é©¬ç²¾ç¥</div>
        <div id="loading-text" style="font-size: 14px; margin-top: 10px;">æ­£åœ¨æ„å»ºå¥”è·‘å½¢æ€...</div>
        <button id="start-btn">ç«‹å³å¼€å§‹ (START)</button>
    </div>

    <div id="ui-layer">
        <h1>ä¸‡é©¬å¥”è…¾ Â· åŠ¨æ€é‡æ„ç‰ˆ</h1>
        <div class="version-tag">V21.0 (Canvas Shape + Running Animation)</div>
        <div id="status-box">ç­‰å¾…æ‰‹åŠ¿...</div>
        <div style="margin-top:15px; font-size:12px; color:#ffaaaa; line-height: 1.8;">
            âœŠ <b>æ¡æ‹³/è‡ªç„¶</b>: å¥”è·‘ (RUN)<br>
            ğŸ– <b>å¼ å¼€</b>: æ•£å¼€ (SCATTER)<br>
            ğŸ‘Œ <b>æåˆ</b>: æŠ“å–ç…§ç‰‡ (GRAB)
        </div>
        <label id="upload-btn">
            ä¸Šä¼ ç…§ç‰‡
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        const CONFIG = {
            particleCount: 0, // åŠ¨æ€
            cameraZ: 70,
            colors: { gold: 0xffd700, blue: 0x00ccff, white: 0xffffff }
        };

        const STATE = { mode: 'ASSEMBLE', handVisible: false, gesture: 'NONE' };
        let scene, camera, renderer, composer;
        let particlesMesh, dummy = new THREE.Object3D();
        let particlesData = [], photoGroup, photosData = [];
        let time = 0;

        window.onload = function() {
            const btn = document.getElementById('start-btn');
            // 2ç§’åå¼ºåˆ¶æ˜¾ç¤ºæŒ‰é’®ï¼Œé˜²æ­¢å¡æ­»
            setTimeout(() => { btn.style.display = 'block'; document.getElementById('loading-text').innerText="å‡†å¤‡å°±ç»ª"; }, 2000);
            btn.onclick = () => {
                if (typeof THREE === 'undefined') { alert("èµ„æºåŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°"); return; }
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                init();
                try { startAI(); } catch(e) {}
            };
        };

        // --- æ ¸å¿ƒ1ï¼šç»˜åˆ¶ç²¾ç¡®çš„å¥”é©¬å‰ªå½± ---
        function drawRunningHorseCanvas() {
            const canvas = document.createElement('canvas');
            const size = 256; canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000'; ctx.fillRect(0,0,size,size);
            
            // ä½¿ç”¨ä¸åŒé¢œè‰²åŒºåˆ†èº«ä½“éƒ¨ä½ï¼Œç”¨äºåŠ¨ç”»æ§åˆ¶
            // èº«ä½“ (çº¢è‰² RGB 255,0,0)
            ctx.fillStyle = '#ff0000'; 
            ctx.beginPath();
            const ox = 120, oy = 130; const s = 0.6;
            ctx.moveTo(ox-80*s, oy+20*s); // è‡€
            ctx.quadraticCurveTo(ox, oy-40*s, ox+60*s, oy-60*s); // èƒŒåˆ°é¢ˆåŸºéƒ¨
            ctx.quadraticCurveTo(ox+80*s, oy+20*s, ox+40*s, oy+60*s); // èƒ¸è…¹
            ctx.lineTo(ox-40*s, oy+40*s); // è…¹éƒ¨ä¸‹æ²¿
            ctx.fill();

            // å¤´éƒ¨å’Œé¢ˆéƒ¨ (ç»¿è‰² RGB 0,255,0)
            ctx.fillStyle = '#00ff00'; 
            ctx.beginPath();
            ctx.moveTo(ox+60*s, oy-60*s);
            ctx.lineTo(ox+90*s, oy-100*s); // å¤´é¡¶
            ctx.lineTo(ox+110*s, oy-80*s); // é¼»å°–
            ctx.lineTo(ox+80*s, oy-40*s); // ä¸‹é¢š
            ctx.fill();

            // è…¿éƒ¨ (è“è‰² RGB 0,0,255)
            ctx.fillStyle = '#0000ff';
            // å‰è…¿è…¾ç©º
            ctx.beginPath(); ctx.moveTo(ox+70*s, oy+50*s); ctx.lineTo(ox+100*s, oy+20*s); ctx.lineTo(ox+120*s, oy+60*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(ox+50*s, oy+60*s); ctx.lineTo(ox+70*s, oy+90*s); ctx.lineTo(ox+50*s, oy+120*s); ctx.fill();
            // åè…¿è¹¬åœ°
            ctx.beginPath(); ctx.moveTo(ox-60*s, oy+30*s); ctx.lineTo(ox-90*s, oy+80*s); ctx.lineTo(ox-120*s, oy+110*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(ox-40*s, oy+40*s); ctx.lineTo(ox-60*s, oy+90*s); ctx.lineTo(ox-40*s, oy+130*s); ctx.fill();

            // é¬ƒæ¯›å’Œå°¾å·´ (ç™½è‰² RGB 255,255,255)
            ctx.fillStyle = '#ffffff';
            ctx.beginPath(); // é¬ƒæ¯›
            ctx.ellipse(ox+80*s, oy-80*s, 30*s, 15*s, -Math.PI/4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); // å°¾å·´
            ctx.moveTo(ox-80*s, oy+10*s); ctx.quadraticCurveTo(ox-120*s, oy, ox-150*s, oy+50*s); ctx.lineTo(ox-100*s, oy+40*s); ctx.fill();

            return { canvas, ctx };
        }

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x220000, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, CONFIG.cameraZ);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const l1 = new THREE.PointLight(CONFIG.colors.gold, 3, 150); l1.position.set(30,50,30); scene.add(l1);

            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.2; bloomPass.strength = 1.3; bloomPass.radius = 0.6;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene); composer.addPass(bloomPass);
            } catch(e) { composer = null; }

            createAnimatedHorse();
            
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            document.addEventListener('mousemove', e => {
                if(!STATE.handVisible && STATE.mode === 'SCATTER') {
                    camera.position.x += ((e.clientX/window.innerWidth-0.5)*40 - camera.position.x)*0.05;
                    camera.position.y += (-(e.clientY/window.innerHeight-0.5)*40 - camera.position.y)*0.05;
                    camera.lookAt(0,0,0);
                }
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if(composer) composer.setSize(window.innerWidth, window.innerHeight);
            });
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            
            animate();
        }

        // --- æ ¸å¿ƒ2ï¼šç”Ÿæˆç²’å­å¹¶æ ‡è®°éƒ¨ä½ ---
        function createAnimatedHorse() {
            const { canvas, ctx } = drawRunningHorseCanvas();
            const w = canvas.width; const h = canvas.height;
            const data = ctx.getImageData(0,0,w,h).data;
            
            const points = [];
            for(let y=0; y<h; y+=2) {
                for(let x=0; x<w; x+=2) {
                    const i = (y*w + x)*4;
                    const r=data[i], g=data[i+1], b=data[i+2];
                    if(r+g+b > 50) { // æœ‰é¢œè‰²çš„åƒç´ 
                        const px = (x - w/2) * 0.35;
                        const py = -(y - h/2) * 0.35;
                        const pz = (Math.random()-0.5) * 3;
                        // æ ¹æ®é¢œè‰²åˆ¤æ–­éƒ¨ä½
                        let type = 0; // èº«ä½“
                        if(g > 200) type = 1; // å¤´é¢ˆ
                        else if(b > 200) type = 2; // è…¿
                        else if(r > 200 && g > 200 && b > 200) type = 3; // é¬ƒæ¯›å°¾å·´
                        points.push({pos: new THREE.Vector3(px, py, pz), type: type});
                    }
                }
            }
            
            CONFIG.particleCount = points.length;
            // ä½¿ç”¨å°å››é¢ä½“ï¼Œæ›´æœ‰æ£±è§’æ„Ÿ
            const geo = new THREE.TetrahedronGeometry(0.3, 0); 
            const mat = new THREE.MeshStandardMaterial({ roughness: 0.4, metalness: 0.7, color: 0xffffff });
            particlesMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
            const col = new THREE.Color();
            
            for(let i=0; i<CONFIG.particleCount; i++) {
                const pt = points[i];
                // é…è‰²ï¼šé‡‘è“ä¸ºä¸»
                let r = Math.random();
                if(r > 0.6) col.setHex(CONFIG.colors.gold);
                else if(r > 0.3) col.setHex(CONFIG.colors.blue);
                else col.setHex(CONFIG.colors.white);
                particlesMesh.setColorAt(i, col);

                const startPos = new THREE.Vector3((Math.random()-0.5)*180, (Math.random()-0.5)*120, (Math.random()-0.5)*120);
                dummy.position.copy(startPos);
                dummy.scale.setScalar(0.4 + Math.random()*0.6);
                dummy.rotation.set(Math.random()*3,Math.random()*3,Math.random()*3);
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);

                particlesData.push({
                    current: startPos.clone(),
                    homeBase: pt.pos, // é™æ€åŸºå‡†ä½ç½®
                    scatter: startPos.clone(),
                    type: pt.type, // éƒ¨ä½ç±»å‹
                    speed: 0.04 + Math.random()*0.04,
                    phase: Math.random() * Math.PI * 2 // åŠ¨ç”»ç›¸ä½
                });
            }
            scene.add(particlesMesh);
        }

        // --- æ ¸å¿ƒ3ï¼šå¥”è·‘åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.02;

            const box = document.getElementById('status-box');
            if(STATE.mode === 'ASSEMBLE') {
                box.innerHTML = "ğŸ çŠ¶æ€ï¼šå¥”è·‘ (RUNNING)"; box.style.color = "#00ff00";
            } else {
                box.innerHTML = "ğŸŒŒ çŠ¶æ€ï¼šæ•£å¼€ (SCATTER)"; box.style.color = "#00ffff";
            }

            for(let i=0; i<CONFIG.particleCount; i++) {
                const d = particlesData[i];
                let target = d.current.clone(); 
                
                if (STATE.mode === 'ASSEMBLE') {
                    // è®¡ç®—åŠ¨æ€çš„â€œå®¶â€ä½ç½®
                    let animHome = d.homeBase.clone();
                    
                    // å¥”è·‘åŠ¨ç”»æ ¸å¿ƒé€»è¾‘
                    const runCycle = time * 6; // å¥”è·‘é¢‘ç‡
                    
                    if(d.type === 2) { // è…¿éƒ¨ï¼šåˆ’åœ†è¿åŠ¨
                        animHome.x += Math.sin(runCycle + d.phase) * 3.0;
                        animHome.y += Math.cos(runCycle + d.phase) * 2.0;
                    } else if(d.type === 3) { // é¬ƒæ¯›å°¾å·´ï¼šå‘åé£˜åŠ¨
                        animHome.x -= Math.sin(runCycle * 0.5 + d.phase)*1.5 + 2.0; // æŒç»­å‘å+æ‘†åŠ¨
                        animHome.y += Math.cos(runCycle * 0.7 + d.phase)*1.0;
                    } else if(d.type === 1) { // å¤´é¢ˆï¼šè½»å¾®ä¸Šä¸‹
                        animHome.y += Math.sin(runCycle + d.phase) * 0.8;
                        animHome.x += Math.cos(runCycle + d.phase) * 0.5;
                    } else { // èº«ä½“ï¼šæ•´ä½“èµ·ä¼
                         animHome.y += Math.sin(runCycle * 2) * 0.6;
                    }
                    target = animHome;
                } else {
                    target = d.scatter;
                }
                
                // ç‰©ç†Lerp
                d.current.lerp(target, d.speed);
                
                dummy.position.copy(d.current);
                if(STATE.mode !== 'ASSEMBLE') dummy.rotation.y += 0.02; // æ•£å¼€æ—¶è‡ªè½¬
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate = true;

            // ç…§ç‰‡é€»è¾‘ (ä¿®å¤ä½ç½®)
            photosData.forEach(p => {
                let tgt;
                if(p.userData.focus) {
                    let v = new THREE.Vector3(0,0,-25).applyQuaternion(camera.quaternion);
                    tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position);
                } else {
                    if (STATE.mode === 'ASSEMBLE') tgt = p.userData.home;
                    else tgt = p.userData.scat;
                    p.lookAt(camera.position);
                }
                p.position.lerp(tgt, 0.05);
            });

            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        async function startAI() {
            if(typeof Hands === 'undefined') return;
            const video = document.getElementsByClassName('input_video')[0];
            const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            
            hands.onResults(res => {
                if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    STATE.handVisible = true;
                    const lm = res.multiHandLandmarks[0];
                    
                    let count = 0;
                    if(lm[8].y < lm[6].y) count++; if(lm[12].y < lm[10].y) count++;
                    if(lm[16].y < lm[14].y) count++; if(lm[20].y < lm[18].y) count++;
                    const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;

                    if(pinch && photosData.length>0 && STATE.mode==='ASSEMBLE') {
                        photosData.forEach(p=>p.userData.focus=false);
                        photosData[photosData.length-1].userData.focus = true;
                    } else if(count >= 4) {
                        STATE.mode = 'SCATTER';
                        photosData.forEach(p=>p.userData.focus=false);
                    } else {
                        STATE.mode = 'ASSEMBLE';
                    }
                } else { STATE.handVisible = false; }
            });
            const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
            await cam.start();
        }

        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }
        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.encoding=THREE.sRGBEncoding;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(10*aspect, 10), mat);
            const border = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.PlaneGeometry(10*aspect, 10)), new THREE.LineBasicMaterial({color:0xffd700}));
            mesh.add(border);
            // ä¿®å¤ç…§ç‰‡ä½ç½®ï¼šåœ¨é©¬çš„ä¸Šæ–¹
            mesh.position.set(0, 30, 0);
            mesh.userData = { home: new THREE.Vector3(0, 25, 5), scat: new THREE.Vector3((Math.random()-0.5)*150, (Math.random()-0.5)*100, (Math.random()-0.5)*150), focus: false };
            photoGroup.add(mesh); photosData.push(mesh);
        }
    </script>
</body>
</html>
