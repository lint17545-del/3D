<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>SPIC 3D Interactive System - Stable V9</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010103; font-family: 'Microsoft YaHei', sans-serif; }
        
        /* è§†é¢‘æ¡†ï¼šåŠé€æ˜ï¼Œç”¨äºç¡®è®¤æ‰‹åŠ¿ */
        #video-element { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; z-index: 2; transform: scaleX(-1); border: 2px solid #FFD700; border-radius: 8px; opacity: 0.4; }
        
        /* UI å±‚ï¼šå¼ºåˆ¶æ˜¾ç¤º */
        #ui-layer { position: absolute; top: 20px; right: 20px; z-index: 10; color: #fff; text-align: right; pointer-events: none; }
        h1 { margin: 0; font-size: 26px; color: #FFD700; letter-spacing: 2px; text-shadow: 0 0 10px rgba(255, 0, 0, 0.5); font-weight: bold; }
        
        .cycle-info { font-size: 20px; margin-top: 10px; color: #fff; font-weight: bold; transition: color 0.5s; }
        .status { font-size: 16px; color: rgba(255,255,255,0.8); margin-top: 5px; font-weight: normal; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 4px; display: inline-block;}
        
        /* æç¤ºåˆ—è¡¨ */
        .tips-box { margin-top: 15px; font-size: 13px; color: #aaa; line-height: 1.6; border-right: 2px solid #0088ff; padding-right: 10px; }
        .tips-box span { display: block; }

        #upload-container { pointer-events: auto; display: inline-block; margin-top: 20px; }
        input[type="file"] { display: none; }
        .btn { 
            background: linear-gradient(90deg, #C41E3A, #FFD700); 
            border: none; padding: 12px 25px; 
            color: #fff; font-size: 14px; font-weight: bold; 
            cursor: pointer; border-radius: 4px; 
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.3); 
        }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; z-index: 20; font-size: 18px; text-align: center; }
        #hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 14px; pointer-events: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...<br>ä¿®å¤æ‰‹åŠ¿è¯†åˆ«æ¨¡å—</div>
    
    <div id="ui-layer">
        <h1>SPIC ç²’å­è§†ç•Œ</h1>
        <div class="cycle-info" id="shape-name">ğŸ æˆ˜é©¬å½¢æ€</div>
        <div class="status" id="status-text">ç­‰å¾…æ‰‹åŠ¿...</div>
        
        <div class="tips-box">
            <span>âœŠ æ¡æ‹³ï¼šèšåˆ (æ‰‹åŠ¿æ—‹è½¬)</span>
            <span>ğŸ– å¼ å¼€ï¼šæ•£å¼€ (æ‰‹åŠ¿å¾®è°ƒ)</span>
            <span>ğŸ‘Œ æåˆï¼šé”å®šæŸ¥çœ‹ç…§ç‰‡</span>
        </div>

        <div id="upload-container">
            <label class="btn">
                + ä¸Šä¼ ç…§ç‰‡ (æ— æ»¤é•œåŸè‰²)
                <input type="file" id="file-input" multiple accept="image/*">
            </label>
        </div>
    </div>
    
    <div id="hint">æåˆæ‰‹æŒ‡åï¼Œç…§ç‰‡å°†å¼ºåˆ¶é”å®š 2 ç§’ï¼Œè¯·æ”¾å¿ƒè§‚å¯Ÿ</div>

    <video id="video-element" playsinline></video>
    <div id="canvas-container"></div>
    
    <canvas id="genCanvas" width="2048" height="1024" style="display:none;"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- ç³»ç»Ÿé…ç½® ---
        const CONFIG = {
            particleCount: 15000,
            maxPhotos: 30,
            colors: {
                horse: [0xD4AF37, 0xC41E3A, 0xFFD700, 0x8B0000], // çº¢é‡‘ç³»
                text: [0x88CCFF], // çº¯å‡€æ˜Ÿå…‰è“
                spic: [0x00008B], // æ·±è“
                logoGreen: 0x00AA00,
                logoRed: 0xDD0000
            },
            modelUrl: 'https://threejs.org/examples/models/gltf/Horse.glb'
        };

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer;
        let mainGroup, photoGroup;
        let particles = [];
        let photoClouds = [];
        let state = 'CONVERGED';
        let time = 0;
        
        // äº¤äº’çŠ¶æ€
        let handPosition = { x: 0.5, y: 0.5 };
        let activeZoomPhoto = null;
        let zoomLocked = false;
        let zoomTimer = null;

        // å½¢æ€çŠ¶æ€
        let currentShapeIndex = 0; 
        // 0: Horse, 1: Text, 2: Logo
        const SHAPES = { HORSE: [], TEXT: [], LOGO: [] };
        let pendingShapeChange = false;

        // èµ„æº
        const sphereGeom = new THREE.SphereGeometry(0.5, 8, 8);
        const boxGeom = new THREE.BoxGeometry(0.7, 0.7, 0.7);

        init();
        animate();
        initMediaPipe();

        async function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x010103, 0.001);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.position.set(0, 20, 400);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            container.appendChild(renderer.domElement);

            // ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const sunLight = new THREE.DirectionalLight(0xFFD700, 1.5);
            sunLight.position.set(100, 100, 100);
            scene.add(sunLight);
            const blueLight = new THREE.PointLight(0x0088FF, 2, 500);
            blueLight.position.set(-100, 0, 100);
            scene.add(blueLight);

            // åå¤„ç†
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // åˆ†ç»„
            mainGroup = new THREE.Group();
            photoGroup = new THREE.Group();
            scene.add(mainGroup);
            scene.add(photoGroup);

            // åŠ è½½æ•°æ®
            await generateAllShapes();
            
            // åˆ›å»ºç²’å­
            createParticles();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            document.getElementById('loading').style.display = 'none';
        }

        // --- å½¢æ€ç”Ÿæˆé€»è¾‘ ---
        async function generateAllShapes() {
            // 1. é©¬
            await new Promise(resolve => {
                new GLTFLoader().load(CONFIG.modelUrl, (gltf) => {
                    const positions = getPointsFromMesh(gltf.scene.children[0], 1.3);
                    SHAPES.HORSE = samplePoints(positions, CONFIG.particleCount);
                    resolve();
                });
            });

            // 2. æ–‡å­— (ä¿®å¤æ˜¾ç¤º)
            SHAPES.TEXT = generateTextPoints("é£å…‰æ— é™  å›½å®¶ç”µæŠ•");

            // 3. Logo (ç”»å¸ƒç»˜åˆ¶æ³•)
            SHAPES.LOGO = generatePreciseLogo();
        }

        function generateTextPoints(text) {
            const canvas = document.getElementById('genCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,2048,1024);
            
            ctx.font = "bold 180px 'Microsoft YaHei'";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 1024, 512);

            return scanCanvas(ctx, 2048, 1024, 4); // 4æ˜¯æ­¥é•¿ï¼Œè¶Šå°è¶Šå¯†
        }

        function generatePreciseLogo() {
            const canvas = document.getElementById('genCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,2048,1024);
            
            const cx = 800;
            const cy = 512;
            const r = 250;
            const w = 90;

            // ç»˜åˆ¶ç»¿è‰²éƒ¨åˆ† (ä¸ŠåŠå¼§)
            ctx.beginPath();
            ctx.arc(cx, cy - r*0.3, r, Math.PI*0.8, Math.PI*2.2, false); 
            ctx.lineWidth = w;
            ctx.strokeStyle = "#00FF00"; // çº¯ç»¿æ ‡è®°
            ctx.stroke();

            // ç»˜åˆ¶çº¢è‰²éƒ¨åˆ† (ä¸‹åŠå¼§)
            ctx.beginPath();
            ctx.arc(cx, cy + r*0.3, r, Math.PI*1.8, Math.PI*3.2, false);
            ctx.lineWidth = w;
            ctx.strokeStyle = "#FF0000"; // çº¯çº¢æ ‡è®°
            ctx.stroke();

            // æ‰«æå¹¶æ ‡è®°é¢œè‰²
            const logoPoints = scanCanvasColor(ctx, 2048, 1024, 5);

            // ç»˜åˆ¶ SPIC
            ctx.clearRect(0,0,2048,1024);
            ctx.font = "900 250px Arial"; // æç²—å­—ä½“
            ctx.fillStyle = "#0000FF"; // çº¯è“æ ‡è®°
            ctx.fillText("SPIC", 1500, 512 + 80);
            
            const spicPoints = scanCanvasColor(ctx, 2048, 1024, 4);
            
            // åˆå¹¶
            const combined = logoPoints.concat(spicPoints);
            return samplePoints(combined, CONFIG.particleCount);
        }

        function scanCanvas(ctx, w, h, step) {
            const data = ctx.getImageData(0,0,w,h).data;
            const points = [];
            for(let y=0; y<h; y+=step) {
                for(let x=0; x<w; x+=step) {
                    if(data[(y*w+x)*4+3] > 128) {
                        points.push(new THREE.Vector3((x-1024)*0.3, -(y-512)*0.3, (Math.random()-0.5)*10));
                    }
                }
            }
            return samplePoints(points, CONFIG.particleCount);
        }

        function scanCanvasColor(ctx, w, h, step) {
            const data = ctx.getImageData(0,0,w,h).data;
            const points = [];
            for(let y=0; y<h; y+=step) {
                for(let x=0; x<w; x+=step) {
                    const idx = (y*w+x)*4;
                    if(data[idx+3] > 128) {
                        const vec = new THREE.Vector3((x-1024)*0.3, -(y-512)*0.3, (Math.random()-0.5)*10);
                        // æ ¹æ®é¢œè‰²æ ‡è®°ç±»å‹
                        if(data[idx] > 200) vec.type = 'red';
                        else if(data[idx+1] > 200) vec.type = 'green';
                        else if(data[idx+2] > 200) vec.type = 'blue';
                        points.push(vec);
                    }
                }
            }
            return points;
        }

        function getPointsFromMesh(mesh, scale) {
            const positions = [];
            const posAttr = mesh.geometry.attributes.position;
            const v = new THREE.Vector3();
            for(let i=0; i<posAttr.count; i++) {
                v.fromBufferAttribute(posAttr, i).multiplyScalar(scale);
                positions.push(v.clone());
            }
            return positions;
        }

        function samplePoints(src, count) {
            if(src.length === 0) return [];
            // å±…ä¸­
            const box = new THREE.Box3().setFromPoints(src);
            const center = box.getCenter(new THREE.Vector3());
            src.forEach(p => p.sub(center));

            const res = [];
            for(let i=0; i<count; i++) {
                const p = src[i % src.length].clone();
                if(src[i % src.length].type) p.type = src[i % src.length].type;
                res.push(p);
            }
            return res.sort(() => Math.random() - 0.5);
        }


        // --- ç²’å­ç³»ç»Ÿ ---
        function createParticles() {
            for(let i=0; i<CONFIG.particleCount; i++) {
                // 30% ç²’å­ä¸ºé«˜äº®è£…é¥°
                const isDeco = Math.random() < 0.3;
                
                const mat = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.4,
                    metalness: 0.6,
                    emissive: 0x000000,
                    emissiveIntensity: 0
                });
                
                const geom = sphereGeom; // é»˜è®¤åœ†çƒ
                const mesh = new THREE.Mesh(geom, mat);
                
                const scatterPos = new THREE.Vector3(
                    (Math.random()-0.5)*800,
                    (Math.random()-0.5)*600,
                    (Math.random()-0.5)*600
                );
                
                mesh.position.copy(scatterPos);
                mainGroup.add(mesh);

                particles.push({
                    mesh: mesh,
                    targets: [SHAPES.HORSE[i], SHAPES.TEXT[i], SHAPES.LOGO[i]],
                    scatterPos: scatterPos,
                    baseColor: new THREE.Color(),
                    isDeco: isDeco,
                    seed: Math.random()
                });
            }
            
            updateVisuals(0);
            updateState('DISPERSED');
        }

        function updateVisuals(idx) {
            const isHorse = idx === 0;
            const isText = idx === 1;
            const isLogo = idx === 2;
            
            const label = document.getElementById('shape-name');

            if(isHorse) {
                label.innerText = "ğŸ æˆ˜é©¬å½¢æ€ (çº¢é‡‘)";
                label.style.color = "#FFD700";
            } else if(isText) {
                label.innerText = "ğŸ’ æ„¿æ™¯æ–‡å­— (æ˜Ÿå…‰è“)";
                label.style.color = "#88CCFF";
            } else {
                label.innerText = "ğŸ—ï¸ å“ç‰Œ Logo (SPIC)";
                label.style.color = "#00FF00";
            }

            particles.forEach(p => {
                let colorHex, opacity=1, transparent=false, geom=sphereGeom;

                if(isHorse) {
                    colorHex = CONFIG.colors.horse[Math.floor(Math.random()*CONFIG.colors.horse.length)];
                    geom = p.isDeco ? sphereGeom : boxGeom; // æ··æ­
                } else if(isText) {
                    colorHex = CONFIG.colors.text[0];
                    geom = boxGeom;
                    opacity = 0.8; 
                    transparent = true;
                } else if(isLogo) {
                    const type = p.targets[2].type;
                    if(type === 'blue') {
                        colorHex = CONFIG.colors.spic[0]; // æ·±è“
                        geom = boxGeom; // SPIC ç”¨æ–¹å—æ›´ç¡¬æœ—
                    } else if(type === 'green') {
                        colorHex = CONFIG.colors.logoGreen;
                        geom = sphereGeom;
                    } else {
                        colorHex = CONFIG.colors.logoRed;
                        geom = sphereGeom;
                    }
                }

                p.baseColor.setHex(colorHex);
                p.mesh.geometry = geom;
                p.mesh.material.transparent = transparent;
                
                gsap.to(p.mesh.material.color, {
                    r: p.baseColor.r, g: p.baseColor.g, b: p.baseColor.b, duration: 0.8
                });
                gsap.to(p.mesh.material, {opacity: opacity, duration: 0.8});
                
                // è£…é¥°ç²’å­å‘å…‰ (ä»…åœ¨é©¬å’Œæ–‡å­—å½¢æ€)
                const emissiveInt = (p.isDeco && !isLogo) ? 1.0 : 0;
                gsap.to(p.mesh.material.emissive, {
                    r: p.baseColor.r, g: p.baseColor.g, b: p.baseColor.b, duration: 0.8
                });
                gsap.to(p.mesh.material, {emissiveIntensity: emissiveInt, duration: 0.8});
            });
        }

        // --- äº¤äº’ç³»ç»Ÿ ---
        function updateState(newState) {
            if (state === newState && state !== 'ZOOM') return;
            if (zoomLocked && newState === 'DISPERSED') return; // é”å®šæœŸé—´ä¸æ•£å¼€

            // å½¢æ€åˆ‡æ¢
            if(state==='DISPERSED' && newState==='CONVERGED' && pendingShapeChange) {
                currentShapeIndex = (currentShapeIndex+1)%3;
                updateVisuals(currentShapeIndex);
                pendingShapeChange = false;
            } else if(newState==='DISPERSED') {
                pendingShapeChange = true;
            }

            // é€€å‡º ZOOM
            if(state === 'ZOOM' && newState !== 'ZOOM' && activeZoomPhoto) {
                gsap.to(activeZoomPhoto.scale, {x:1, y:1, z:1, duration: 0.5});
                activeZoomPhoto = null;
            }

            state = newState;
            const statusEl = document.getElementById('status-text');

            if (state === 'CONVERGED') {
                statusEl.innerText = "çŠ¶æ€: âœŠ èšåˆ (æ‰‹åŠ¿æ—‹è½¬)";
                statusEl.style.color = "#FFD700";
                
                particles.forEach(p => {
                    const t = p.targets[currentShapeIndex];
                    gsap.to(p.mesh.position, {
                        x: t.x, y: t.y, z: t.z, 
                        duration: 1.5 + p.seed, 
                        ease: "power2.inOut"
                    });
                });
                
                // ç…§ç‰‡å½’ä½
                photoClouds.forEach(p => {
                    gsap.to(p.position, {
                        x: p.homePos.x, y: p.homePos.y, z: p.homePos.z,
                        duration: 2, ease: "power2.out"
                    });
                    gsap.to(p.scale, {x:1, y:1, z:1, duration: 1});
                    p.lookAt(camera.position);
                });

            } else if (state === 'DISPERSED') {
                statusEl.innerText = "çŠ¶æ€: ğŸ– æ•£å¼€ (å‡†å¤‡åˆ‡æ¢)";
                statusEl.style.color = "#00FFFF";
                
                particles.forEach(p => {
                    gsap.to(p.mesh.position, {
                        x: p.scatterPos.x, y: p.scatterPos.y, z: p.scatterPos.z, 
                        duration: 2.0, ease: "power2.out"
                    });
                });
                
                photoClouds.forEach(p => {
                    gsap.to(p.position, {
                        x: p.scatterPos.x, y: p.scatterPos.y, z: p.scatterPos.z,
                        duration: 2.5, ease: "power2.out"
                    });
                });

            } else if (state === 'ZOOM') {
                statusEl.innerText = "çŠ¶æ€: ğŸ‘Œ å·²é”å®šç…§ç‰‡";
                statusEl.style.color = "#FF00FF";
                
                // å¯åŠ¨é”å®šé€»è¾‘
                zoomLocked = true;
                clearTimeout(zoomTimer);
                zoomTimer = setTimeout(() => {
                    zoomLocked = false;
                    statusEl.innerText = "çŠ¶æ€: ğŸ‘Œ é”å®šç»“æŸ";
                }, 2000); // é”å®š2ç§’

                if(photoClouds.length > 0) {
                    activeZoomPhoto = photoClouds[Math.floor(Math.random() * photoClouds.length)];
                    
                    const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                    const targetPos = camera.position.clone().add(camDir.multiplyScalar(40)); // è·ç¦»40
                    
                    gsap.to(activeZoomPhoto.position, {
                        x: targetPos.x, y: targetPos.y, z: targetPos.z,
                        duration: 1.0, ease: "power2.out"
                    });
                    gsap.to(activeZoomPhoto.scale, { x: 8, y: 8, z: 8, duration: 1.0 });
                    activeZoomPhoto.lookAt(camera.position);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // æ‰‹åŠ¿è·Ÿéšé€»è¾‘
            const targetRotY = (handPosition.x - 0.5) * 3;
            const targetRotX = (handPosition.y - 0.5) * 2;
            
            // èšåˆå’Œæ•£å¼€æ—¶éƒ½å…è®¸æ—‹è½¬ï¼Œä½†æ•£å¼€æ—¶é˜»å°¼æ›´å¤§(è½¬å¾—æ›´æ…¢)
            const damping = state === 'DISPERSED' ? 0.02 : 0.08;
            
            mainGroup.rotation.y += (targetRotY - mainGroup.rotation.y) * damping;
            mainGroup.rotation.x += (targetRotX - mainGroup.rotation.x) * damping;
            photoGroup.rotation.copy(mainGroup.rotation);

            // ç²’å­å‘¼å¸
            if(state === 'DISPERSED') {
                particles.forEach(p => {
                    p.mesh.position.y += Math.sin(time + p.seed * 10) * 0.1;
                });
            }
            
            // ç…§ç‰‡å§‹ç»ˆé¢å‘ç›¸æœº (é™¤äº†è¢«æŠ“å–çš„é‚£å¼ )
            photoClouds.forEach(p => {
                if(p !== activeZoomPhoto) {
                    // ä½¿ç”¨ quaternion æ‹·è´ç›¸æœºçš„æ—‹è½¬ï¼Œä¿è¯ç»å¯¹æ­£å¯¹
                    p.quaternion.copy(camera.quaternion);
                }
            });

            composer.render();
        }

        function handleFileUpload(e) {
            const files = e.target.files;
            if(!files.length) return;
            const limit = Math.min(files.length, CONFIG.maxPhotos);
            
            // æ¸…ç©ºæ—§ç…§ç‰‡
            photoClouds.forEach(p => photoGroup.remove(p));
            photoClouds = [];

            Array.from(files).slice(0, limit).forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        
                        const geom = new THREE.PlaneGeometry(10, 10);
                        const mat = new THREE.MeshBasicMaterial({
                            map: tex, side: THREE.DoubleSide, transparent: true, color: 0xffffff
                        });
                        const mesh = new THREE.Mesh(geom, mat);
                        
                        // ç¯ç»•åˆ†å¸ƒ
                        const angle = (i / limit) * Math.PI * 2;
                        const r = 160;
                        mesh.homePos = new THREE.Vector3(Math.cos(angle)*r, (Math.random()-0.5)*100, Math.sin(angle)*r);
                        mesh.scatterPos = new THREE.Vector3((Math.random()-0.5)*800, (Math.random()-0.5)*600, (Math.random()-0.5)*800);
                        
                        mesh.position.copy(mesh.scatterPos);
                        photoGroup.add(mesh);
                        photoClouds.push(mesh);
                    }
                }
                reader.readAsDataURL(file);
            });
            alert(`æˆåŠŸå¯¼å…¥ ${limit} å¼ ç…§ç‰‡ã€‚å®ƒä»¬ç°åœ¨æ˜¯ç‹¬ç«‹çš„é«˜æ¸…å›¾å±‚ã€‚`);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ä¿®å¤åçš„ MediaPipe æ¨¡å— ---
        function initMediaPipe() {
            const videoElement = document.getElementById('video-element');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });
            
            hands.onResults((results) => {
                if (!results.multiHandLandmarks || !results.multiHandLandmarks.length) return;
                
                const lm = results.multiHandLandmarks[0];
                
                // 1. æ‰‹åŠ¿ä½ç½®
                handPosition.x = 1 - (lm[0].x + lm[9].x) / 2;
                handPosition.y = (lm[0].y + lm[9].y) / 2;

                // 2. æ‰‹æŒ‡çŠ¶æ€
                const tips = [8, 12, 16, 20];
                const bases = [5, 9, 13, 17]; // ä¹‹å‰è¿™é‡Œå®šä¹‰æ™šäº†å¯¼è‡´å´©æºƒï¼Œç°åœ¨ç§»åˆ°äº†å¾ªç¯å‰
                let openCount = 0;
                
                tips.forEach((tip, i) => {
                    if (lm[tip].y < lm[bases[i]].y) openCount++;
                });

                // 3. æåˆè®¡ç®—
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

                // 4. çŠ¶æ€æœº
                if (pinchDist < 0.05) {
                    if (state !== 'ZOOM') updateState('ZOOM');
                } 
                else if (openCount >= 3) {
                    // åªæœ‰åœ¨æ²¡é”å®šçš„æ—¶å€™æ‰èƒ½æ•£å¼€
                    if (state !== 'DISPERSED' && !zoomLocked) updateState('DISPERSED');
                } 
                else if (openCount <= 1) {
                    if (state !== 'CONVERGED') updateState('CONVERGED');
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 320, height: 240
            });
            cameraUtils.start();
        }
    </script>
</body>
</html>
