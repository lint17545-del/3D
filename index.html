<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Matrix (V15.0 Cyber-Industrial)</title>
    <style>
        /* èµ›åšæœ‹å…‹é£æ ¼æ·±è‰²èƒŒæ™¯ */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center bottom, #000b1a 0%, #000000 100%); font-family: "Microsoft YaHei", sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #00f3ff; pointer-events: none; user-select: none;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.6);
        }
        h1 { margin: 0; font-weight: 800; letter-spacing: 6px; font-size: 36px; color: #ffffff; text-transform: uppercase; }
        .subtitle { font-size: 12px; color: #0088ff; letter-spacing: 3px; margin-top: 5px; border-left: 3px solid #00f3ff; padding-left: 10px;}
        
        .version-tag { font-size: 10px; color: #00ffaa; margin-top: 15px; border: 1px solid #00ffaa; display: inline-block; padding: 4px 8px; background: rgba(0,0,0,0.8);}
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #00050a; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #00f3ff;
            flex-direction: column; transition: opacity 0.8s;
        }
        
        #force-start-btn {
            margin-top: 40px; padding: 15px 60px; 
            background: transparent; color: #00f3ff;
            border: 2px solid #00f3ff; cursor: pointer;
            font-size: 16px; letter-spacing: 4px; font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            text-transform: uppercase;
            transition: 0.3s;
            display: none; /* å»¶æ—¶æ˜¾ç¤º */
        }
        #force-start-btn:hover { background: #00f3ff; color: #000; box-shadow: 0 0 50px rgba(0, 243, 255, 1.0); }

        #loading-text { margin-top: 15px; color: #446688; font-size: 12px; font-family: monospace; }

        /* ä¸Šä¼ æŒ‰é’®ç¾åŒ– */
        #upload-btn {
            pointer-events: auto; background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00f3ff; color: #00f3ff; padding: 8px 20px;
            cursor: pointer; margin-top: 20px; display: inline-block;
            font-size: 12px; letter-spacing: 1px;
            transition: 0.3s;
        }
        #upload-btn:hover { background: #00f3ff; color: #000; }
        input[type="file"] { display: none; }
        .input_video { display: none; }
        
        /* äº¤äº’æç¤ºå›¾æ ‡ */
        .icon-guide { margin-top: 15px; font-size: 12px; color: #88aacc; line-height: 2.0; }
        .highlight { color: #ffffff; font-weight: bold; }
    </style>
</head>
<body>
    <div id="loader">
        <div style="font-size: 32px; letter-spacing: 8px; font-weight: bold; text-shadow: 0 0 20px #00f3ff;">èƒ½æºçŸ©é˜µ</div>
        <div style="font-size: 14px; letter-spacing: 4px; color: #ffffff; opacity: 0.7; margin-top: 5px;">ENERGY MATRIX V15.0</div>
        <div id="loading-text">INITIALIZING QUANTUM PARTICLES...</div>
        <button id="force-start-btn">INITIALIZE SYSTEM</button>
    </div>

    <div id="ui-layer">
        <h1>æ™ºæ…§èƒ½æº</h1>
        <div class="subtitle">THERMAL & NEW ENERGY VISUALIZATION</div>
        <div class="version-tag">Hyper-Structure Engine</div>
        <div class="status" id="gesture-status">SYSTEM READY</div>
        <div class="icon-guide">
            <span class="highlight">âœŒï¸ å‰ªåˆ€æ‰‹</span> : å…¨è´Ÿè·è¿è¡Œ (Full Power)<br>
            <span class="highlight">âœŠ æ¡æ‹³</span> : å¾…æœºçŠ¶æ€ (Standby)<br>
            <span class="highlight">ğŸ– å¼ å¼€</span> : ç»“æ„è§£æ„ (Deconstruct)<br>
            <span class="highlight">ğŸ–±ï¸ é¼ æ ‡</span> : è§†è§’ç¯ç»• (Orbit)
        </div>
        <label id="upload-btn">
            [+] åŠ è½½å…¨æ¯å½±åƒ (Upload Photo)
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        // partType: 0=å¡”èº«(é™), 1=é£æœºå¶ç‰‡(æ—‹), 2=å…‰ä¼(é—ª), 3=è’¸æ±½(å‡), 4=å…¨æ¯åœ°é¢
        attribute float partType; 
        attribute vec3 initialPos; // åŸå§‹ä½ç½®
        attribute float randomSeed; // éšæœºç§å­

        uniform float time;
        uniform float runSpeed; // 0.1 (å¾…æœº) -> 2.0 (å…¨é€Ÿ)
        uniform float scatter;  // 0.0 -> 1.0
        uniform vec3 mousePos;
        
        varying vec3 vColor;
        varying float vAlpha;

        // æ—‹è½¬çŸ©é˜µ
        mat2 rotate2d(float _angle){
            return mat2(cos(_angle),-sin(_angle),
                        sin(_angle),cos(_angle));
        }

        void main() {
            vColor = customColor;
            vAlpha = 1.0; // åŸºç¡€é€æ˜åº¦
            vec3 pos = initialPos;
            float t = time * runSpeed;

            // --- 1. é£æœºå¶ç‰‡ (Type 1) ---
            if (partType > 0.5 && partType < 1.5) {
                // é£æœºä¸­å¿ƒç‚¹ (æ‰‹åŠ¨ç¡¬ç¼–ç è°ƒæ•´)
                vec3 center = vec3(-25.0, 35.0, -10.0);
                vec3 local = pos - center;
                // æ—‹è½¬
                float angle = -t * 3.0; // é€†æ—¶é’ˆæ—‹è½¬
                local.xy = rotate2d(angle) * local.xy;
                pos = center + local;
                // å¢åŠ ä¸€ç‚¹åŠ¨æ€å…‰æ•ˆ
                vColor += vec3(0.2) * sin(t * 5.0 + pos.x); 
            }
            
            // --- 2. å…‰ä¼é˜µåˆ— (Type 2) ---
            else if (partType > 1.5 && partType < 2.5) {
                // æ•°æ®æµå…‰æ•ˆï¼šå…‰å¸¦æ‰«è¿‡
                float flow = mod(pos.x + pos.z + t * 5.0, 20.0);
                if (flow < 2.0) {
                    vColor = mix(vColor, vec3(1.0, 1.0, 1.0), 0.8); // å˜æˆäº®ç™½
                    pos.y += 0.5; // ç¨å¾®æµ®èµ·
                }
            }

            // --- 3. å†·å´å¡”è’¸æ±½ (Type 3) ---
            else if (partType > 2.5 && partType < 3.5) {
                // å¾ªç¯ä¸Šå‡
                float cycle = mod(time * (1.0 + runSpeed) + randomSeed * 10.0, 1.0); // 0~1
                pos.y = initialPos.y + cycle * 15.0; // ä¸Šå‡ 15 å•ä½
                
                // æ‰©æ•£
                float spread = cycle * 5.0;
                pos.x += sin(time + randomSeed * 10.0) * spread * 0.5;
                pos.z += cos(time + randomSeed * 10.0) * spread * 0.5;

                // æ¸éš
                vAlpha = (1.0 - cycle) * (runSpeed * 0.8); // é€Ÿåº¦è¶Šå¿«ï¼Œè’¸æ±½è¶Šæ˜æ˜¾
            }
            
            // --- 4. å…¨æ¯åœ°é¢ (Type 4) ---
            else if (partType > 3.5) {
                // å‘¼å¸æ•ˆæœ
                vAlpha = 0.3 + 0.2 * sin(time + pos.x * 0.1);
            }

            // --- 5. æ•£å¼€æ•ˆæœ (Deconstruct) ---
            if (scatter > 0.01) {
                // å‘ä¸Šæ‚¬æµ®æ•£å¼€
                pos.y += scatter * 20.0;
                // éšæœºå™ªç‚¹æ•£å¼€
                pos.x += sin(randomSeed * 100.0) * scatter * 50.0;
                pos.z += cos(randomSeed * 100.0) * scatter * 50.0;
                vAlpha *= (1.0 - scatter);
            }

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            
            // ç²’å­å¤§å°éšè·ç¦»å˜åŒ–
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
            // ç»˜åˆ¶åœ†å½¢ç²’å­
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;

            // æ ¸å¿ƒäº®ï¼Œè¾¹ç¼˜æš— (å…‰æ™•)
            float glow = 1.0 - r;
            glow = pow(glow, 2.0);

            gl_FragColor = vec4(vColor, vAlpha * glow);
        }
    </script>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const CONFIG = {
            particleCount: 25000, // å¢åŠ åˆ° 2.5ä¸‡ä¸ªç²’å­ï¼Œä¿è¯å¯†åº¦
            cameraZ: 90,
            colors: {
                cyan: new THREE.Color(0x00f3ff),    // èµ›åšè“ (ç«ç”µå†·å´å¡”)
                orange: new THREE.Color(0xffaa00),  // èƒ½é‡æ©™ (å…‰ä¼)
                white: new THREE.Color(0xffffff),   // ç™½ (é£æœº)
                grey: new THREE.Color(0x556677),    // ç° (è’¸æ±½/åœ°é¢)
                darkBase: new THREE.Color(0x001133) // åŸºç¡€æš—è‰²
            }
        };

        let scene, camera, renderer, composer;
        let particles, uniforms;
        let photoGroup, photosData = [];
        const STATE = { mode: 'ENERGY' }; // ENERGY(å¾…æœº), OPERATING(å…¨é€Ÿ), SCATTER(æ•£å¼€)

        // --- å¯åŠ¨ç³»ç»Ÿ ---
        window.onload = function() {
            const btn = document.getElementById('force-start-btn');
            const txt = document.getElementById('loading-text');

            // 3ç§’åå¼ºåˆ¶æ˜¾ç¤ºæŒ‰é’®
            setTimeout(() => { btn.style.display = 'block'; }, 3000);

            // ç‚¹å‡»å¯åŠ¨
            btn.onclick = () => {
                if(typeof THREE === 'undefined') {
                    alert("æ ¸å¿ƒç»„ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢"); return;
                }
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 800);
                
                init();
                try { startAI(); } catch(e) { console.warn("AI skipped"); }
            };
        };

        // --- åˆå§‹åŒ– 3D åœºæ™¯ ---
        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            // æ·±ç©ºé›¾æ°”
            scene.fog = new THREE.FogExp2(0x00050a, 0.002);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 30, CONFIG.cameraZ); // ä¿¯è§†è§†è§’
            camera.lookAt(0, 10, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // è¾‰å…‰åæœŸ (Bloom) - è®©ç²’å­å‘å…‰
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.2; // é˜ˆå€¼ä½ä¸€ç‚¹ï¼Œè®©æš—å¤„ä¹Ÿå‘å…‰
                bloomPass.strength = 1.2;  // å¼ºåº¦
                bloomPass.radius = 0.5;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene); composer.addPass(bloomPass);
            } catch(e) { composer = null; }

            // === æ ¸å¿ƒï¼šæ„å»ºå·¥ä¸šçŸ©é˜µ ===
            buildIndustrialCity();

            // ç…§ç‰‡ç»„
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            // ç›‘å¬
            document.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('resize', onResize, false);
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            animate();
        }

        // --- å»ºç­‘å¸ˆï¼šç¨‹åºåŒ–ç”Ÿæˆå·¥ä¸šåœºæ™¯ ---
        function buildIndustrialCity() {
            const positions = []; const colors = []; const sizes = []; const partTypes = []; 
            const initialPos = []; const randomSeeds = [];
            
            const tempVec = new THREE.Vector3();
            const tempCol = new THREE.Color();

            // è¾…åŠ©ï¼šæ·»åŠ ç²’å­
            function pushParticle(x, y, z, color, size, type) {
                positions.push(x, y, z);
                initialPos.push(x, y, z);
                colors.push(color.r, color.g, color.b);
                sizes.push(size);
                partTypes.push(type);
                randomSeeds.push(Math.random());
            }

            // === 1. å†·å´å¡” (åŒæ›²é¢ç»“æ„) ===
            // å…¬å¼: x^2/a^2 + z^2/a^2 - y^2/b^2 = 1 (åŒæ›²é¢)
            // è¿™é‡Œæˆ‘ä»¬ç”¨å‚æ•°æ–¹ç¨‹ç”Ÿæˆ
            const towerCenter = new THREE.Vector3(10, 0, -10);
            const towerRings = 80;   // é«˜åº¦å±‚æ•°
            const towerSegs = 60;    // æ¯å±‚ç²’å­æ•°
            
            for(let y=0; y<towerRings; y++) {
                let h = (y / towerRings) * 35; // é«˜åº¦ 0 -> 35
                // åŠå¾„è®¡ç®—ï¼šåŒæ›²çº¿æ”¶è…°
                // y=12æ—¶æœ€ç»†
                let waistRel = (h - 12) / 12.0; 
                let radius = 6.0 * Math.sqrt(1.0 + waistRel * waistRel * 0.4); 
                
                for(let i=0; i<towerSegs; i++) {
                    let angle = (i / towerSegs) * Math.PI * 2;
                    let px = towerCenter.x + Math.cos(angle) * radius;
                    let pz = towerCenter.z + Math.sin(angle) * radius;
                    
                    // ç»“æ„çº¿å¢å¼º (ç»çº¬çº¿)
                    let isStructure = (i % 6 === 0) || (y % 5 === 0);
                    let pColor = isStructure ? CONFIG.colors.cyan : CONFIG.colors.darkBase;
                    let pSize = isStructure ? 0.8 : 0.4;
                    
                    pushParticle(px, h, pz, pColor, pSize, 0.0);
                }
            }
            // å¡”å†…è“å…‰æ ¸å¿ƒ
            for(let i=0; i<500; i++) {
                 let angle = Math.random() * Math.PI * 2;
                 let r = Math.random() * 5.0;
                 let h = Math.random() * 10.0;
                 pushParticle(towerCenter.x + Math.cos(angle)*r, h, towerCenter.z + Math.sin(angle)*r, CONFIG.colors.cyan, 1.2, 0.0);
            }
            // å¡”é¡¶è’¸æ±½æº
            for(let i=0; i<1000; i++) {
                 // åˆå§‹ä½ç½®åœ¨å¡”é¡¶å†…éƒ¨
                 let angle = Math.random() * Math.PI * 2;
                 let r = Math.random() * 5.0;
                 pushParticle(towerCenter.x + Math.cos(angle)*r, 30, towerCenter.z + Math.sin(angle)*r, CONFIG.colors.grey, 2.0, 3.0);
            }

            // === 2. é£åŠ›å‘ç”µæœº (æµçº¿å‹) ===
            const windPos = new THREE.Vector3(-25, 0, -10);
            const windHeight = 35;
            
            // å¡”ç­’ (é”¥å½¢)
            for(let h=0; h<windHeight; h+=0.5) {
                let r = 1.5 * (1.0 - h/windHeight * 0.6); // åº•éƒ¨ç²—é¡¶éƒ¨ç»†
                for(let i=0; i<16; i++) {
                    let angle = (i/16) * Math.PI * 2;
                    pushParticle(windPos.x + Math.cos(angle)*r, h, windPos.z + Math.sin(angle)*r, CONFIG.colors.white, 0.6, 0.0);
                }
            }
            // è½®æ¯‚
            for(let i=0; i<200; i++) {
                let v = new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*3, (Math.random()-0.5)*3);
                v.add(new THREE.Vector3(windPos.x, windHeight, windPos.z));
                pushParticle(v.x, v.y, v.z, CONFIG.colors.white, 1.0, 1.0); // Type 1 å‚ä¸æ—‹è½¬
            }
            // å¶ç‰‡ (3ç‰‡)
            const bladeLen = 22;
            for(let b=0; b<3; b++) {
                let baseAngle = (b / 3) * Math.PI * 2;
                for(let l=2; l<bladeLen; l+=0.4) {
                    // å¶ç‰‡å½¢çŠ¶ï¼šä¸­é—´å®½ï¼Œä¸¤å¤´å°–
                    let width = 1.5 * Math.sin((l/bladeLen) * Math.PI); 
                    for(let w=-width/2; w<width/2; w+=0.2) {
                        // åˆå§‹åªç”»ä¸€ç‰‡å‘ä¸Šçš„ï¼ŒShaderé‡Œåšæ—‹è½¬
                        // è¿™é‡Œæˆ‘ä»¬æ„å»ºå±€éƒ¨åæ ‡ï¼ŒShaderé‡Œç»Ÿä¸€è½¬
                        // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬æ‰‹åŠ¨ç®—å‡ºä¸‰ä¸ªå¶ç‰‡çš„åˆå§‹ç‚¹
                        
                        // å±€éƒ¨åæ ‡
                        let lx = w; 
                        let ly = l;
                        let lz = 0;
                        
                        // æ—‹è½¬åˆ°å¯¹åº”å¶ç‰‡è§’åº¦
                        let rx = lx * Math.cos(baseAngle) - ly * Math.sin(baseAngle);
                        let ry = lx * Math.sin(baseAngle) + ly * Math.cos(baseAngle);
                        
                        // ç§»åˆ°å¡”é¡¶
                        pushParticle(windPos.x + rx, windHeight + ry, windPos.z, CONFIG.colors.white, 0.5, 1.0);
                    }
                    // å¶å°–åŠ ä¸€ç‚¹è­¦ç¤ºçº¢
                    if(l > bladeLen - 2) {
                        let ry = l * Math.cos(baseAngle);
                        let rx = -l * Math.sin(baseAngle); // ç®€åŒ–çš„æ—‹è½¬
                         // è¿™é‡ŒåªåŠ å‡ ä¸ªç‚¹ç¤ºæ„
                    }
                }
            }

            // === 3. å…‰ä¼é˜µåˆ— (çŸ©é˜µç¾å­¦) ===
            const pvRows = 8;
            const pvCols = 10;
            const pvSpaceX = 6;
            const pvSpaceZ = 4;
            const pvStartX = -30;
            const pvStartZ = 5;

            for(let r=0; r<pvRows; r++) {
                for(let c=0; c<pvCols; c++) {
                    let cx = pvStartX + c * pvSpaceX;
                    let cz = pvStartZ + r * pvSpaceZ;
                    
                    // æ¯ä¸ªæ¿å­æ˜¯ä¸€ä¸ªçŸ©å½¢é¢ï¼Œå€¾æ–œ
                    for(let px=-2.5; px<=2.5; px+=0.3) {
                        for(let pz=-1.5; pz<=1.5; pz+=0.3) {
                            // å€¾æ–œè®¡ç®—: ç»•Xè½´è½¬
                            let py = 2.0 + pz * 0.5; // åé«˜å‰ä½
                            let realZ = cz + pz;
                            
                            // è¾¹ç¼˜æ£€æµ‹
                            let isBorder = (Math.abs(px)>2.3 || Math.abs(pz)>1.3);
                            let col = isBorder ? CONFIG.colors.orange : CONFIG.colors.darkBase;
                            let sz = isBorder ? 0.6 : 0.4;
                            
                            // ç¨å¾®éšæœºåŒ–ä½ç½®ï¼Œæ‰“ç ´æ‘©å°”çº¹
                            pushParticle(cx + px, py, realZ, col, sz, 2.0);
                        }
                    }
                }
            }

            // === 4. å…¨æ¯åœ°é¢ (ç½‘æ ¼) ===
            for(let x=-60; x<=60; x+=2) {
                for(let z=-40; z<=40; z+=2) {
                    if(Math.random() > 0.9) { // ç¨€ç–ç‚¹é˜µ
                        pushParticle(x, 0, z, CONFIG.colors.cyan, 0.4, 4.0);
                    }
                    // åŠ å‡ æ¡é«˜äº®çº¿
                    if(x % 20 === 0 && z % 2 === 0) {
                         pushParticle(x, 0, z, CONFIG.colors.white, 0.5, 4.0);
                    }
                }
            }

            // æ„å»ºå‡ ä½•ä½“
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('initialPos', new THREE.Float32BufferAttribute(initialPos, 3));
            geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('partType', new THREE.Float32BufferAttribute(partTypes, 1));
            geometry.setAttribute('randomSeed', new THREE.Float32BufferAttribute(randomSeeds, 1));

            // Shader æè´¨
            uniforms = {
                time: { value: 0.0 },
                runSpeed: { value: 0.1 },
                scatter: { value: 0.0 },
                mousePos: { value: new THREE.Vector3(0,0,0) }
            };

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- äº¤äº’ä¸åŠ¨ç”» ---
        function onMouseMove(e) {
            // ç®€å•çš„é¼ æ ‡è§†å·®ï¼Œä¸æ”¹å˜ uniforms.mousePos (ç»™ Shader ç”¨)
            let mx = (e.clientX / window.innerWidth) * 2 - 1;
            let my = -(e.clientY / window.innerHeight) * 2 + 1;
            
            // ç¼“æ…¢ç§»åŠ¨ç›¸æœº
            if(STATE.mode !== 'SCATTER') {
                camera.position.x += (mx * 10 - camera.position.x) * 0.05;
                camera.position.y += (20 + my * 5 - camera.position.y) * 0.05;
                camera.lookAt(0, 10, 0);
            }
        }
        
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(composer) composer.setSize(window.innerWidth, window.innerHeight);
        }

        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }
        
        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8*aspect, 8), mat);
            // èµ›åšé£æ ¼è¾¹æ¡†
            const borderGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(8*aspect, 8));
            const borderMat = new THREE.LineBasicMaterial( { color: 0x00f3ff } );
            const border = new THREE.LineSegments( borderGeo, borderMat );
            mesh.add(border);
            
            // åˆå§‹ä½ç½®ï¼šå¡”é¡¶æ¼‚æµ®
            mesh.position.set(10, 40, -10);
            mesh.userData = {
                home: mesh.position.clone(),
                scat: new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*50, (Math.random()-0.5)*100),
                focus: false
            };
            photoGroup.add(mesh); photosData.push(mesh);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            if(uniforms) {
                uniforms.time.value = time;
                
                // çŠ¶æ€å¹³æ»‘è¿‡æ¸¡
                let targetSpeed = 0.1; // å¾…æœºå¾®åŠ¨
                let targetScatter = 0.0;
                
                if (STATE.mode === 'OPERATING') targetSpeed = 2.0; // å…¨é€Ÿ
                if (STATE.mode === 'SCATTER') targetScatter = 1.0;
                
                uniforms.runSpeed.value += (targetSpeed - uniforms.runSpeed.value) * 0.02;
                uniforms.scatter.value += (targetScatter - uniforms.scatter.value) * 0.02;
            }

            // ç…§ç‰‡åŠ¨ç”»
            photosData.forEach(p => {
                const d = p.userData; 
                let tgt = (STATE.mode === 'SCATTER') ? d.scat : d.home;
                
                if(d.focus) {
                    const v = new THREE.Vector3(0,0,-20).applyQuaternion(camera.quaternion); 
                    tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position); 
                } else {
                    p.lookAt(camera.position);
                    // æµ®åŠ¨åŠ¨ç”»
                    if(STATE.mode !== 'SCATTER') {
                         p.position.y = d.home.y + Math.sin(time + p.id)*2.0;
                    }
                }
                p.position.lerp(tgt, 0.05);
            });

            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        // --- AI æ‰‹åŠ¿ (æ²¿ç”¨ç¨³å®šé€»è¾‘) ---
        async function startAI() {
            const video = document.getElementsByClassName('input_video')[0];
            const stat = document.getElementById('gesture-status');
            
            if(typeof Hands === 'undefined') return;

            const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults(res => {
                if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    const lm = res.multiHandLandmarks[0];
                    
                    // å‰ªåˆ€æ‰‹ -> Operating
                    if (lm[8].y < lm[6].y && lm[12].y < lm[10].y && lm[16].y > lm[14].y) {
                        STATE.mode = 'OPERATING'; stat.innerText = "âš¡ å…¨è´Ÿè·è¿è¡Œ (MAX POWER)";
                    } 
                    // æåˆ -> Grab
                    else if (Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05) {
                        stat.innerText = "ğŸ‘Œ æŠ“å–å…¨æ¯å›¾ (GRAB)";
                        if(photosData.length>0) {
                            photosData.forEach(p=>p.userData.focus=false);
                            photosData[photosData.length-1].userData.focus = true;
                        }
                    }
                    // æ‹³å¤´ -> Static
                    else if (lm[8].y > lm[5].y && lm[12].y > lm[9].y) {
                        STATE.mode = 'ENERGY'; stat.innerText = "ğŸ›‘ å¾…æœºçŠ¶æ€ (STANDBY)";
                    } 
                    // å¼ å¼€ -> Scatter
                    else {
                        STATE.mode = 'SCATTER'; stat.innerText = "ğŸŒŒ ç»“æ„è§£æ„ (SCATTER)";
                        photosData.forEach(p=>p.userData.focus=false);
                    }
                } else {
                    stat.innerText = "ç­‰å¾…æŒ‡ä»¤...";
                }
            });
            
            const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
            await cam.start();
            stat.innerText = "AI LINKED";
        }
    </script>
</body>
</html>
