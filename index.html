<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Horse (V4.2 Fail-Safe)</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #2a0000 0%, #000000 100%); font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #ffd700; pointer-events: none; user-select: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.9);
        }
        h1 { margin: 0; font-weight: bold; letter-spacing: 3px; font-size: 28px; color: #ff3333; text-shadow: 0 0 15px rgba(255, 0, 0, 0.8); }
        
        .version-tag { font-size: 10px; color: #ffffff; margin-bottom: 10px; border: 1px solid #ffffff; display: inline-block; padding: 2px 5px; background: rgba(0,0,0,0.7);}
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a0000; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #ff3333;
            flex-direction: column; transition: opacity 0.5s;
        }
        
        /* å¼ºåˆ¶è·³è¿‡æŒ‰é’® - æ ·å¼é†’ç›® */
        #force-start-btn {
            margin-top: 20px;
            padding: 10px 25px;
            background: #ff3333;
            color: white;
            border: 2px solid #fff;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            border-radius: 5px;
            display: block; /* é»˜è®¤æ˜¾ç¤ºï¼Œé˜²å¡æ­» */
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }

        #loading-text { margin-top: 10px; color: #aa5555; font-size: 14px; }
        
        #upload-btn {
            pointer-events: auto; background: rgba(100, 0, 0, 0.6);
            border: 1px solid #ffd700; color: #ffd700; padding: 8px 15px;
            cursor: pointer; margin-top: 15px; display: inline-block;
            font-size: 12px; border-radius: 4px; text-transform: uppercase;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
        
        #console-log { position: fixed; bottom: 0; left: 0; width: 100%; height: 80px; background: rgba(0,0,0,0.8); color: #ff9999; font-size: 10px; pointer-events: none; z-index: 999; overflow: auto; display: block; }
    </style>
</head>
<body>
    <div id="console-log">Log initialized...<br></div>
    
    <div id="loader">
        <div id="loading-text">æ­£åœ¨å°è¯•è¿æ¥å…¨çƒèŠ‚ç‚¹...</div>
        <button id="force-start-btn">âš ï¸ å¦‚æœå¡ä½ï¼Œç‚¹æ­¤å¼ºåˆ¶è¿›å…¥</button>
    </div>

    <div id="ui-layer">
        <h1>é¾™é©¬ç²¾ç¥</h1>
        <div class="version-tag">Ver 4.2 (Fail-Safe)</div>
        <div class="status" id="gesture-status">ç­‰å¾…å¯åŠ¨...</div>
        <div style="margin-top:10px; font-size:14px; color:#ffaaaa; line-height: 1.6;">
            âœŒï¸ <b>å‰ªåˆ€æ‰‹: å¥”è·‘ (Run)</b><br>
            ğŸ– å¼ å¼€æ‰‹: æ¼«æ¸¸ (Scatter)<br>
            âœŠ æ¡æ‹³: èšåˆ (Reset)<br>
            ğŸ‘Œ æåˆ: æŠ“å– (Grab)
        </div>
        <label id="upload-btn">
            ä¸Šä¼ ç…§ç‰‡ (Upload Photos)
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        function log(msg) { 
            const el = document.getElementById('console-log'); 
            el.innerHTML += `> ${msg}<br>`; 
            el.scrollTop = el.scrollHeight; // Auto scroll
            console.log(msg); 
        }

        window.onload = function() {
            const forceBtn = document.getElementById('force-start-btn'); 
            const loadingText = document.getElementById('loading-text');
            
            log("Window loaded. Checking libs...");

            // å¼ºåˆ¶å¯åŠ¨é€»è¾‘
            forceBtn.onclick = function() {
                log("User forced start.");
                document.getElementById('loader').style.opacity = 0; 
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                
                // å°è¯•åˆå§‹åŒ–
                initThree();
                
                // å°è¯•åå°åŠ è½½æ‘„åƒå¤´ï¼Œå¤±è´¥ä¹Ÿæ²¡å…³ç³»
                try {
                    startCamera();
                } catch(e) {
                    log("Camera skipped in force mode.");
                }
            };

            // æ£€æŸ¥ Three.js æ˜¯å¦åŠ è½½
            if(typeof THREE === 'undefined') {
                log("Three.js failed to load!");
                loadingText.innerText = "3D å¼•æ“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ";
                return;
            } else {
                log("Three.js loaded.");
            }

            // è‡ªåŠ¨è¿›å…¥é€»è¾‘ (å¦‚æœåŠ è½½å¿«çš„è¯)
            if(typeof Hands !== 'undefined') {
                log("AI Lib loaded. Auto-enabling button...");
                forceBtn.innerText = "ç‚¹å‡»å¼€å§‹ (CLICK START)";
                forceBtn.style.background = "#d4af37"; // å˜é‡‘
                forceBtn.style.color = "#000";
            } else {
                log("AI Lib missing. Waiting...");
            }
        };

        const CONFIG = { particleCount: 2200, cameraZ: 70, colors: { red: 0xdd0000, gold: 0xffd700, darkRed: 0x550000 }};
        const STATE = { mode: 'HORSE', handVisible: false, handX: 0.5, handY: 0.5, gesture: 'NONE', runSpeed: 0 };
        let scene, camera, renderer, composer, particlesMesh, photoGroup, dummy = new THREE.Object3D();
        let raycaster = new THREE.Raycaster();
        const centerVector = new THREE.Vector2(0, 0); 
        const particlesData = [], photosData = [];
        let currentLookAt = new THREE.Vector3(0, 5, 0);
        let runTime = 0; 
        let isInit = false; // é˜²æ­¢é‡å¤åˆå§‹åŒ–

        function initThree() {
            if(isInit) return;
            isInit = true;
            try {
                log("Initializing 3D Scene...");
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x1a0000, 0.0015); 

                camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000); 
                camera.position.set(0, 10, CONFIG.cameraZ);
                camera.lookAt(0, 5, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.3; 
                container.appendChild(renderer.domElement);

                scene.add(new THREE.AmbientLight(0xffffff, 0.2));
                const l1 = new THREE.PointLight(CONFIG.colors.gold, 3.0, 150); l1.position.set(20, 30, 30); scene.add(l1);
                const l2 = new THREE.PointLight(CONFIG.colors.red, 2.0, 120); l2.position.set(-20, 10, 15); scene.add(l2);
                const l3 = new THREE.DirectionalLight(0xffaa00, 1.0); l3.position.set(0, 50, -20); scene.add(l3); 

                try {
                    const renderScene = new THREE.RenderPass(scene, camera);
                    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.85);
                    bloomPass.threshold = 0.6; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
                    composer = new THREE.EffectComposer(renderer);
                    composer.addPass(renderScene);
                    composer.addPass(bloomPass);
                } catch(e) { log("Bloom skipped."); composer = null; }

                createHorseParticles();
                photoGroup = new THREE.Group();
                scene.add(photoGroup);

                document.addEventListener('mousemove', e => {
                    if (!STATE.handVisible && STATE.mode === 'SCATTER') updateCameraFromInput(e.clientX/window.innerWidth, e.clientY/window.innerHeight);
                });
                document.addEventListener('click', e => {
                    if(['upload-btn', 'file-input', 'force-start-btn'].includes(e.target.id)) return;
                    if(!STATE.handVisible && photosData.length > 0) { STATE.mode = STATE.mode === 'HORSE' ? 'SCATTER' : 'HORSE'; }
                });

                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    if(composer) composer.setSize(window.innerWidth, window.innerHeight);
                });
                document.getElementById('file-input').addEventListener('change', handleImageUpload);
                animate();
                log("3D Scene Ready!");
            } catch(err) { log("3D Init Error: " + err.message); }
        }

        function createHorseParticles() {
            const geo = new THREE.TetrahedronGeometry(0.5, 0); 
            geo.scale(1, 1.5, 0.5);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.3, metalness: 0.7 });
            particlesMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
            const col = new THREE.Color();
            
            for(let i=0; i<CONFIG.particleCount; i++) {
                let part = 0, x=0, y=0, z=0;
                const r = Math.random();
                if (r < 0.45) { 
                    part = 0; x = (Math.random()-0.5) * 12; y = (Math.random()-0.5) * 8 + 10; z = (Math.random()-0.5) * 8;
                } else if (r < 0.65) {
                    part = 1; const neckProgress = Math.random();
                    x = 6 + neckProgress * 4 + (Math.random()-0.5)*3; y = 12 + neckProgress * 8 + (Math.random()-0.5)*3; z = (Math.random()-0.5) * 3;
                    if(neckProgress > 0.8) { x += 2; z *= 1.5; }
                } else if (r < 0.90) {
                    part = 2; const legIndex = Math.floor(Math.random() * 4); 
                    const legX = (legIndex < 2) ? 4 : -4; const legZ = (legIndex % 2 === 0) ? 2.5 : -2.5; 
                    x = legX + (Math.random()-0.5) * 2.5; y = Math.random() * 10; z = legZ + (Math.random()-0.5) * 2;
                    part = 2 + legIndex * 0.1; 
                } else {
                    part = 3; x = -7 - Math.random() * 4; y = 10 - Math.random() * 6; z = (Math.random()-0.5) * 2;
                }

                if (Math.random() > 0.8) col.setHex(CONFIG.colors.gold); else col.setHex(CONFIG.colors.red);
                particlesMesh.setColorAt(i, col);
                dummy.position.set(x, y, z);
                dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                dummy.scale.setScalar(0.5 + Math.random());
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
                
                particlesData.push({ idx: i, part: part, cur: new THREE.Vector3(x, y, z), horsePos: new THREE.Vector3(x, y, z), 
                    scat: new THREE.Vector3((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120), 
                    speed: 0.02 + Math.random() * 0.03 });
            }
            scene.add(particlesMesh);
        }

        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }

        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.generateMipmaps=true; tex.encoding = THREE.sRGBEncoding;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, fog: false, toneMapped: false });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(5*aspect, 5), mat);
            const frame = new THREE.Mesh(new THREE.BoxGeometry(5*aspect+0.2, 5.2, 0.1), new THREE.MeshStandardMaterial({color:0xffffff}));
            mesh.position.z = 0.06; frame.add(mesh);
            const ty = Math.random()*20 + 5;
            frame.position.set(0, ty, 20);
            frame.userData = { tree: new THREE.Vector3((Math.random()-0.5)*25, ty, (Math.random()-0.5)*20), scat: new THREE.Vector3((Math.random()-0.5)*90, (Math.random()-0.5)*80, (Math.random()-0.5)*90), cur: frame.position.clone(), focus: false };
            photoGroup.add(frame); photosData.push(frame);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            let targetState = STATE.mode;
            if (STATE.gesture === 'VICTORY') {
                targetState = 'RUNNING'; STATE.runSpeed = Math.min(STATE.runSpeed + 0.02, 1.0); runTime += 0.2;
            } else {
                STATE.runSpeed = Math.max(STATE.runSpeed - 0.02, 0); 
                if(targetState !== 'SCATTER') targetState = 'HORSE';
                runTime += 0.05;
            }

            for(let i=0; i<CONFIG.particleCount; i++) {
                const d = particlesData[i]; let tgt;
                if (targetState === 'SCATTER') tgt = d.scat;
                else {
                    tgt = d.horsePos.clone();
                    if (d.part >= 2 && d.part < 3) { 
                        const legId = Math.floor((d.part - 2) * 10); 
                        const phase = (legId % 2 === 0) ? 0 : Math.PI; 
                        tgt.x += Math.sin(runTime + phase) * 3 * STATE.runSpeed;
                        tgt.y += Math.max(0, Math.cos(runTime*2 + phase) * 1.5 * STATE.runSpeed);
                    }
                    tgt.y += Math.sin(runTime * 2) * 0.5 * STATE.runSpeed; 
                }
                if(targetState === 'SCATTER') d.cur.y += Math.sin(time + i)*0.01;
                d.cur.lerp(tgt, d.speed); dummy.position.copy(d.cur);
                dummy.rotation.x += 0.01; dummy.rotation.y += 0.01;
                dummy.updateMatrix(); particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate=true;
            
            photosData.forEach(p => {
                const d = p.userData; let tgt = (targetState === 'SCATTER') ? d.scat : d.tree; let scale = 1;
                if(d.focus) {
                    const v = new THREE.Vector3(0,0,-15).applyQuaternion(camera.quaternion); tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position); scale=3.0; 
                } else {
                    p.lookAt(camera.position);
                    if(STATE.runSpeed > 0.1) tgt.z += Math.sin(time*10)*0.1;
                }
                d.cur.lerp(tgt, 0.04); p.position.copy(d.cur); p.scale.lerp(new THREE.Vector3(scale,scale,scale), 0.1);
            });

            if(STATE.mode==='SCATTER' && STATE.handVisible) {
                updateCameraFromInput(STATE.handX, STATE.handY);
            } else {
                camera.position.lerp(new THREE.Vector3(0, 10, CONFIG.cameraZ), 0.03);
                let shakeY = (Math.random()-0.5) * STATE.runSpeed * 0.5;
                currentLookAt.lerp(new THREE.Vector3(0, 5 + shakeY, 0), 0.05);
                camera.lookAt(currentLookAt);
            }
            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        function updateCameraFromInput(x, y) {
            const theta = (x-0.5) * 4 * Math.PI; const phi = (1-y) * Math.PI * 0.5 + 0.2; 
            const r = CONFIG.cameraZ * 1.1; 
            const cx = r * Math.sin(theta) * Math.sin(phi); const cz = r * Math.cos(theta) * Math.sin(phi); const cy = r * Math.cos(phi) + 10;
            camera.position.lerp(new THREE.Vector3(cx, cy, cz), 0.05); camera.lookAt(0, 10, 0);
        }

        async function startCamera() {
            log("Attempting camera init..."); 
            const video = document.getElementsByClassName('input_video')[0];
            try {
                if(typeof Hands === 'undefined') throw new Error("AI Library still loading...");
                
                // ä½¿ç”¨ unpkg æºï¼Œè¿™æ˜¯å®˜æ–¹æºï¼Œæœ€é€šç”¨
                const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
                hands.onResults(onResults);
                const camera = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
                await camera.start(); 
                document.getElementById('gesture-status').innerText = "AI Active!"; 
                log("Camera & AI Started Successfully!");
            } catch(e) { 
                log("Cam/AI Error: " + e.message); 
                document.getElementById('gesture-status').innerText = "Camera Failed. Use Mouse."; 
            }
        }

        function onResults(res) {
            const status = document.getElementById('gesture-status');
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                STATE.handVisible = true; const lm = res.multiHandLandmarks[0];
                STATE.handX = STATE.handX * 0.8 + (1 - lm[0].x) * 0.2; STATE.handY = STATE.handY * 0.8 + lm[0].y * 0.2;
                const tips=[8,12,16,20], bases=[5,9,13,17]; let open=0;
                tips.forEach((t,i) => { if(Math.hypot(lm[t].x-lm[0].x, lm[t].y-lm[0].y) > Math.hypot(lm[bases[i]].x-lm[0].x, lm[bases[i]].y-lm[0].y)*1.3) open++; });
                if(Math.hypot(lm[4].x-lm[0].x, lm[4].y-lm[0].y)>0.15) open++;
                
                const wrist = lm[0]; const iTip = lm[8], mTip = lm[12], rTip = lm[16], pTip = lm[20];
                const iBase = lm[5], mBase = lm[9], rBase = lm[13], pBase = lm[17];
                const isIndexUp = iTip.y < iBase.y; const isMiddleUp = mTip.y < mBase.y;
                const isRingDown = rTip.y > rBase.y; const isPinkyDown = pTip.y > pBase.y;
                const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05; 

                if (pinch) {
                    STATE.gesture = 'PINCH'; status.innerText = "ğŸ‘Œ æåˆ: æŠ“å– (Grab)"; raycastGrab();
                } else if (isIndexUp && isMiddleUp && isRingDown && isPinkyDown && !pinch) {
                    STATE.gesture = 'VICTORY'; STATE.mode = 'HORSE'; status.innerText = "âœŒï¸ å‰ªåˆ€æ‰‹: å¥”è·‘ (RUN!)";
                } else if (openCount >= 4) {
                    STATE.gesture = 'OPEN'; STATE.mode =
