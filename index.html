<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNY Horse (V20.0 Instant Math)</title>
    <style>
        /* çº¢åŒ…é£æ ¼æ·±çº¢èƒŒæ™¯ */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #4a0000 0%, #1a0000 100%); font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #ffd700; pointer-events: none; user-select: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        h1 { margin: 0; font-weight: bold; letter-spacing: 4px; font-size: 28px; color: #ffd700; }
        .version-tag { font-size: 12px; color: #fff; margin-top: 5px; opacity: 0.8; }
        
        #status-box {
            margin-top: 15px; padding: 10px 20px;
            border: 2px solid #ffd700; background: rgba(0,0,0,0.5);
            font-size: 18px; font-weight: bold; color: #fff;
            display: inline-block; border-radius: 8px;
        }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #2a0000; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #ffd700;
            flex-direction: column; transition: opacity 0.5s;
        }
        
        /* å¼ºåˆ¶æŒ‰é’®é»˜è®¤ç›´æ¥æ˜¾ç¤ºï¼Œä¸å†ç­‰å¾… */
        #start-btn {
            margin-top: 30px; padding: 15px 50px; 
            background: #ffd700; color: #550000;
            border: 2px solid #fff; cursor: pointer;
            font-size: 18px; font-weight: bold;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
            border-radius: 50px; 
        }
        
        #upload-btn {
            pointer-events: auto; background: rgba(50, 0, 0, 0.6);
            border: 1px solid #ffd700; color: #ffd700; padding: 8px 15px;
            cursor: pointer; margin-top: 15px; display: inline-block; font-size: 12px;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
    </style>
</head>
<body>
    <div id="loader">
        <div style="font-size: 32px; font-weight: bold; letter-spacing: 5px;">é¾™é©¬ç²¾ç¥</div>
        <div id="loading-text" style="font-size: 14px; margin-top: 10px;">ç³»ç»Ÿå°±ç»ª (System Ready)</div>
        <button id="start-btn">ç«‹å³è¿è¡Œ (RUN)</button>
    </div>

    <div id="ui-layer">
        <h1>ä¸‡é©¬å¥”è…¾ Â· æé€Ÿç‰ˆ</h1>
        <div class="version-tag">V20.0 (Math Generated - No Parsing)</div>
        <div id="status-box">ç­‰å¾…æ‰‹åŠ¿...</div>
        <div style="margin-top:15px; font-size:12px; color:#ffaaaa; line-height: 1.8;">
            âœŠ <b>æ¡æ‹³</b>: èšåˆ (ASSEMBLE)<br>
            ğŸ– <b>å¼ å¼€</b>: æ•£å¼€ (SCATTER)<br>
            ğŸ‘Œ <b>æåˆ</b>: æŠ“å– (GRAB)
        </div>
        <label id="upload-btn">
            ä¸Šä¼ ç…§ç‰‡
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        const CONFIG = {
            particleCount: 2200, // ç²’å­æ•°é€‚ä¸­ï¼Œä¿è¯æµç•…
            cameraZ: 60,
            colors: { gold: 0xffd700, blue: 0x00ccff, white: 0xffffff }
        };

        const STATE = { mode: 'ASSEMBLE', handVisible: false, gesture: 'NONE' };
        let scene, camera, renderer, composer;
        let particlesMesh, dummy = new THREE.Object3D();
        let particlesData = [], photosData = [];
        let time = 0;

        window.onload = function() {
            const btn = document.getElementById('start-btn');
            // ç‚¹å‡»å³è¿è¡Œï¼Œä¸ä¾èµ–åŠ è½½äº‹ä»¶
            btn.onclick = () => {
                if (typeof THREE === 'undefined') { alert("èµ„æºæœªåŠ è½½ï¼Œè¯·åˆ·æ–°"); return; }
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                init();
                try { startAI(); } catch(e) {}
            };
        };

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x2a0000, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, CONFIG.cameraZ);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // å…‰ç…§
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const l1 = new THREE.PointLight(CONFIG.colors.gold, 2, 100); l1.position.set(20,20,20); scene.add(l1);

            // è¾‰å…‰
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.2; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene); composer.addPass(bloomPass);
            } catch(e) { composer = null; }

            generateMathHorse(); // æ ¸å¿ƒç”Ÿæˆ
            
            let photoGroup = new THREE.Group();
            scene.add(photoGroup);

            document.addEventListener('mousemove', e => {
                if(!STATE.handVisible && STATE.mode === 'SCATTER') {
                    camera.position.x += ((e.clientX/window.innerWidth-0.5)*30 - camera.position.x)*0.05;
                    camera.position.y += (-(e.clientY/window.innerHeight-0.5)*30 - camera.position.y)*0.05;
                    camera.lookAt(0,0,0);
                }
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if(composer) composer.setSize(window.innerWidth, window.innerHeight);
            });
            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            
            animate();
        }

        // --- æ ¸å¿ƒï¼šæ•°å­¦æ–¹ç¨‹ç”Ÿæˆé©¬ (0å»¶è¿Ÿ) ---
        function generateMathHorse() {
            const geo = new THREE.TetrahedronGeometry(0.3, 0); 
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4, metalness: 0.6 });
            particlesMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
            
            const col = new THREE.Color();
            
            // è¾…åŠ©å‡½æ•°ï¼šéšæœºç‚¹åœ¨æ¤­çƒä½“å†…
            function randomInEllipsoid(cx, cy, cz, rx, ry, rz) {
                let u = Math.random(), v = Math.random();
                let theta = 2 * Math.PI * u;
                let phi = Math.acos(2 * v - 1);
                let r = Math.cbrt(Math.random()); 
                let x = cx + rx * r * Math.sin(phi) * Math.cos(theta);
                let y = cy + ry * r * Math.sin(phi) * Math.sin(theta);
                let z = cz + rz * r * Math.cos(phi);
                return {x, y, z};
            }

            let i = 0;
            // å¾ªç¯ç›´åˆ°å¡«æ»¡ç²’å­
            while(i < CONFIG.particleCount) {
                let p;
                let part = Math.random();
                
                // æŒ‰ç…§çº¢åŒ…å›¾çš„æ¯”ä¾‹æ„å»ºé©¬
                if (part < 0.4) { 
                    // 1. èº¯å¹² (Body) - ç•¥å¾®å‰é«˜åä½
                    p = randomInEllipsoid(0, 0, 0, 12, 6, 4);
                    // ç¨å¾®æ—‹è½¬èº¯å¹²
                    let ny = p.y * Math.cos(0.2) - p.x * Math.sin(0.2);
                    let nx = p.y * Math.sin(0.2) + p.x * Math.cos(0.2);
                    p.x = nx; p.y = ny;
                } else if (part < 0.6) {
                    // 2. é¢ˆéƒ¨ (Neck) - å‘ä¸Šå‘å‰
                    p = randomInEllipsoid(8, 8, 0, 4, 7, 2.5);
                    // æ—‹è½¬é¢ˆéƒ¨
                    let ang = -0.5;
                    let nx = (p.x-8)*Math.cos(ang) - (p.y-8)*Math.sin(ang) + 8;
                    let ny = (p.x-8)*Math.sin(ang) + (p.y-8)*Math.cos(ang) + 8;
                    p.x = nx; p.y = ny;
                } else if (part < 0.7) {
                    // 3. å¤´éƒ¨ (Head)
                    p = randomInEllipsoid(13, 14, 0, 3.5, 2, 2);
                    // æ—‹è½¬å¤´ (ä½å¤´)
                    let ang = 0.5;
                    let nx = (p.x-13)*Math.cos(ang) - (p.y-14)*Math.sin(ang) + 13;
                    let ny = (p.x-13)*Math.sin(ang) + (p.y-14)*Math.cos(ang) + 14;
                    p.x = nx; p.y = ny;
                } else if (part < 0.85) {
                    // 4. è…¿éƒ¨ (Legs) - åŠ¨æ€å¥”è·‘å§¿æ€
                    let leg = Math.random();
                    if(leg < 0.5) { // å‰è…¿ (è…¾ç©º)
                        p = randomInEllipsoid(10, -6, (Math.random()>0.5?2:-2), 1.5, 6, 1);
                        p.x += Math.sin(p.y)*2; // å¼¯æ›²
                    } else { // åè…¿ (è¹¬åœ°)
                        p = randomInEllipsoid(-8, -7, (Math.random()>0.5?2:-2), 2, 7, 1.5);
                        p.x -= Math.sin(p.y)*3; // åè¹¬
                    }
                } else {
                    // 5. é¬ƒæ¯›ä¸å°¾å·´ (Mane & Tail) - æ‹–å°¾æ•£è½
                    if(Math.random() > 0.5) { // é¬ƒæ¯›
                        p = randomInEllipsoid(6 + Math.random()*4, 12 + Math.random()*4, 0, 4, 2, 1);
                        p.x -= Math.random()*3; // å‘åé£˜
                    } else { // å°¾å·´
                        p = randomInEllipsoid(-12, 2, 0, 5, 2, 1);
                        p.x -= Math.random()*5; // å‘åé£˜
                        p.y -= Math.random()*2;
                    }
                }

                // é¢œè‰²é€»è¾‘ï¼šé‡‘è‰²ç‚¹ç¼€ï¼Œè“è‰²æµå…‰ï¼Œç™½è‰²ä¸»ä½“
                let r = Math.random();
                if(r > 0.7) col.setHex(CONFIG.colors.gold);
                else if(r > 0.5) col.setHex(CONFIG.colors.blue);
                else col.setHex(CONFIG.colors.white);
                particlesMesh.setColorAt(i, col);

                // åˆå§‹ä½ç½® (éšæœºæ•£å¼€)
                let startPos = new THREE.Vector3(
                    (Math.random()-0.5)*150, 
                    (Math.random()-0.5)*100, 
                    (Math.random()-0.5)*100
                );

                dummy.position.copy(startPos);
                dummy.scale.setScalar(0.5 + Math.random()*0.8);
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);

                particlesData.push({
                    current: startPos.clone(),
                    home: new THREE.Vector3(p.x, p.y, p.z), // ç›®æ ‡é©¬çš„å½¢çŠ¶
                    scatter: startPos.clone(),
                    speed: 0.04 + Math.random()*0.04
                });
                i++;
            }
            scene.add(particlesMesh);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.02;

            // çŠ¶æ€æ›´æ–°
            const box = document.getElementById('status-box');
            if(STATE.mode === 'ASSEMBLE') {
                box.innerText = "ğŸ´ çŠ¶æ€ï¼šèšåˆ (é©¬)"; box.style.color = "#00ff00";
            } else {
                box.innerText = "ğŸŒŒ çŠ¶æ€ï¼šæ•£å¼€ (æ˜Ÿç©º)"; box.style.color = "#00ffff";
            }

            for(let i=0; i<CONFIG.particleCount; i++) {
                const d = particlesData[i];
                let target = (STATE.mode === 'ASSEMBLE') ? d.home : d.scatter;
                
                // ç‰©ç†æ’å€¼ (Lerp)
                d.current.lerp(target, d.speed);
                
                // åŠ¨æ€æ•ˆæœ
                let x = d.current.x; let y = d.current.y; let z = d.current.z;
                if(STATE.mode === 'ASSEMBLE') {
                    // é©¬çš„å¥”è·‘å¾‹åŠ¨
                    y += Math.sin(time*5 + x*0.1) * 0.2; // èº«ä½“èµ·ä¼
                    if(x > 5) y += Math.sin(time*8) * 0.1; // å¤´éƒ¨éœ‡é¢¤
                } else {
                    // æ•£å¼€æ¼‚æµ®
                    y += Math.sin(time + x) * 0.05;
                }

                dummy.position.set(x, y, z);
                dummy.rotation.x += 0.01;
                dummy.updateMatrix();
                particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate = true;

            // ç…§ç‰‡é€»è¾‘
            photosData.forEach(p => {
                let tgt = (STATE.mode==='SCATTER') ? p.userData.scat : p.userData.home;
                if(p.userData.focus) {
                    let v = new THREE.Vector3(0,0,-20).applyQuaternion(camera.quaternion);
                    tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position);
                } else {
                    p.lookAt(camera.position);
                }
                p.position.lerp(tgt, 0.05);
            });

            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        // --- æ‰‹åŠ¿è¯†åˆ« ---
        async function startAI() {
            if(typeof Hands === 'undefined') return;
            const video = document.getElementsByClassName('input_video')[0];
            const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            
            hands.onResults(res => {
                if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    STATE.handVisible = true;
                    const lm = res.multiHandLandmarks[0];
                    
                    let count = 0;
                    if(lm[8].y < lm[6].y) count++;
                    if(lm[12].y < lm[10].y) count++;
                    if(lm[16].y < lm[14].y) count++;
                    if(lm[20].y < lm[18].y) count++;

                    const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;

                    if(pinch) {
                        if(photosData.length>0 && STATE.mode==='ASSEMBLE') {
                            photosData.forEach(p=>p.userData.focus=false);
                            photosData[photosData.length-1].userData.focus = true;
                        }
                    } else if(count >= 3) {
                        STATE.mode = 'SCATTER';
                        photosData.forEach(p=>p.userData.focus=false);
                    } else {
                        STATE.mode = 'ASSEMBLE';
                    }
                }
            });
            const cam = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
            await cam.start();
        }

        // --- è¾…åŠ© ---
        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }
        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8*aspect, 8), mat);
            // é‡‘è¾¹
            const border = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.PlaneGeometry(8*aspect, 8)), new THREE.LineBasicMaterial({color:0xffd700}));
            mesh.add(border);
            mesh.position.set(0, 20, 0);
            mesh.userData = { home: new THREE.Vector3(0, 15, 0), scat: new THREE.Vector3((Math.random()-0.5)*150, (Math.random()-0.5)*100, (Math.random()-0.5)*150), focus: false };
            photoGroup.add(mesh); photosData.push(mesh);
        }
    </script>
</body>
</html>
