<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNY Red Horse (Majestic V7.0)</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #330000 0%, #000000 100%); font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #ffd700; pointer-events: none; user-select: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.9);
        }
        h1 { margin: 0; font-weight: bold; letter-spacing: 3px; font-size: 28px; color: #ff3333; text-shadow: 0 0 15px rgba(255, 0, 0, 0.8); }
        
        .version-tag { font-size: 10px; color: #ffcc00; margin-bottom: 10px; border: 1px solid #ffcc00; display: inline-block; padding: 2px 5px; background: rgba(0,0,0,0.7);}
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a0000; z-index: 100; display: flex;
            justify-content: center; align-items: center; color: #ff3333;
            flex-direction: column; transition: opacity 0.5s;
        }
        #start-btn {
            padding: 12px 30px; border: 1px solid #d4af37; background: rgba(212, 175, 55, 0.1);
            color: #d4af37; font-size: 16px; cursor: pointer; letter-spacing: 2px;
            transition: 0.3s; margin-top: 20px; display: none;
        }
        #start-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 20px #d4af37; }
        #loading-text { margin-top: 10px; color: #888; font-size: 14px; }
        
        #upload-btn {
            pointer-events: auto; background: rgba(50, 0, 0, 0.8);
            border: 1px solid #ffd700; color: #ffd700; padding: 8px 15px;
            cursor: pointer; margin-top: 15px; display: inline-block;
            font-size: 12px; border-radius: 4px; text-transform: uppercase;
        }
        input[type="file"] { display: none; }
        .input_video { display: none; }
        
        #console-log { position: fixed; bottom: 0; left: 0; width: 100%; height: 100px; background: rgba(0,0,0,0.8); color: red; font-size: 10px; pointer-events: none; z-index: 999; overflow: auto; display: none; }
    </style>
</head>
<body>
    <div id="console-log"></div>
    <div id="loader">
        <div id="loading-text">æ­£åœ¨å¡‘é€ ç¥éª (Sculpting Horse)...</div>
        <button id="start-btn">å¼€å¯æ–°å¹´ (START)</button>
    </div>

    <div id="ui-layer">
        <h1>é¾™é©¬ç²¾ç¥ Â· æ–°å¹´å¿«ä¹</h1>
        <div class="version-tag">Ver 7.0 (Majestic Anatomy)</div>
        <div class="status" id="gesture-status">ç­‰å¾…å¯åŠ¨...</div>
        <div style="margin-top:5px; font-size:12px; color:#ffaaaa; line-height: 1.5;">
            âœŒï¸ å‰ªåˆ€æ‰‹: å¥”è·‘ (Run) | ğŸ– å¼ å¼€: æ¼«æ¸¸ <br>
            ğŸ‘Œ æåˆ: æŠ“å–ç…§ç‰‡
        </div>
        <label id="upload-btn">
            ä¸Šä¼ ç…§ç‰‡ (Upload Photos)
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        function log(msg) { const el = document.getElementById('console-log'); el.style.display='block'; el.innerHTML+=`> ${msg}<br>`; console.log(msg); }
        window.onload = function() {
            const startBtn = document.getElementById('start-btn'); const loadingText = document.getElementById('loading-text');
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') { log("Error: Not HTTPS."); loadingText.innerText="Please use HTTPS"; return; }
            loadingText.style.display = 'none'; startBtn.style.display = 'block';
            startBtn.addEventListener('click', () => {
                document.getElementById('loader').style.opacity = 0; setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                initThree(); startCamera(); 
            });
        };

        const CONFIG = { 
            // ã€ä¿®æ”¹ã€‘å¢åŠ ç²’å­æ•°ä»¥è·å¾—æ›´å¯†å®çš„æ¨¡å‹
            particleCount: 3800, 
            cameraZ: 75, 
            colors: { red: 0xdd0000, gold: 0xffd700, darkRed: 0x440000 } 
        };
        const STATE = { mode: 'HORSE', handVisible: false, handX: 0.5, handY: 0.5, gesture: 'NONE', runSpeed: 0 };
        
        let scene, camera, renderer, composer, particlesMesh, photoGroup, dummy = new THREE.Object3D();
        let raycaster = new THREE.Raycaster();
        const centerVector = new THREE.Vector2(0, 0); 
        const particlesData = [], photosData = [];
        let currentLookAt = new THREE.Vector3(0, 8, 0);
        let runTime = 0;

        function initThree() {
            try {
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x1a0000, 0.0012); 

                camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000); 
                camera.position.set(0, 12, CONFIG.cameraZ);
                camera.lookAt(0, 8, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.4; 
                container.appendChild(renderer.domElement);

                // åŠ å¼ºé‡‘è‰²å…‰ç…§ï¼Œçªå‡ºè½®å»“
                scene.add(new THREE.AmbientLight(0xffffff, 0.1));
                const l1 = new THREE.PointLight(CONFIG.colors.gold, 4.0, 200); l1.position.set(30, 40, 40); scene.add(l1);
                const l2 = new THREE.PointLight(CONFIG.colors.red, 2.5, 150); l2.position.set(-30, 10, 20); scene.add(l2);
                // é¡¶éƒ¨å¡‘å½¢å…‰
                const l3 = new THREE.DirectionalLight(0xffcc00, 1.2); l3.position.set(0, 50, 10); scene.add(l3);

                try {
                    const renderScene = new THREE.RenderPass(scene, camera);
                    // å¢å¼ºè¾‰å…‰ï¼Œè®©å®ƒçœ‹èµ·æ¥æ›´ç¥åœ£
                    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.6, 0.4, 0.88);
                    composer = new THREE.EffectComposer(renderer);
                    composer.addPass(renderScene);
                    composer.addPass(bloomPass);
                } catch(e) { log("Bloom skipped."); composer = null; }

                createHorseParticlesV2(); // ä½¿ç”¨æ–°çš„å»ºæ¨¡å‡½æ•°
                photoGroup = new THREE.Group();
                scene.add(photoGroup);

                document.addEventListener('mousemove', e => {
                    if (!STATE.handVisible && STATE.mode === 'SCATTER') updateCameraFromInput(e.clientX/window.innerWidth, e.clientY/window.innerHeight);
                });
                document.addEventListener('click', e => {
                    if(['upload-btn', 'file-input', 'start-btn'].includes(e.target.id)) return;
                    if(!STATE.handVisible && photosData.length > 0) { STATE.mode = STATE.mode === 'HORSE' ? 'SCATTER' : 'HORSE'; }
                });

                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    if(composer) composer.setSize(window.innerWidth, window.innerHeight);
                });
                document.getElementById('file-input').addEventListener('change', handleImageUpload);
                animate();
            } catch(err) { log("3D Init Error: " + err.message); }
        }

        // è¾…åŠ©å‡½æ•°ï¼šç‚¹æ˜¯å¦åœ¨æ¤­çƒä½“å†…
        function inEllipsoid(p, center, size, rotY = 0, rotZ = 0) {
            let pos = p.clone().sub(center);
            if(rotY) pos.applyAxisAngle(new THREE.Vector3(0,1,0), -rotY);
            if(rotZ) pos.applyAxisAngle(new THREE.Vector3(0,0,1), -rotZ);
            return (pos.x*pos.x)/(size.x*size.x) + (pos.y*pos.y)/(size.y*size.y) + (pos.z*pos.z)/(size.z*size.z) <= 1;
        }

        // ã€æ ¸å¿ƒä¿®æ”¹ã€‘V7.0 å…¨æ–°çš„æ•°å­¦å»ºæ¨¡å‡½æ•°
        function createHorseParticlesV2() {
            // èŠ±ç“£ç²’å­æ›´å°æ›´å¯†
            const geo = new THREE.TetrahedronGeometry(0.4, 0); 
            geo.scale(1, 1.8, 0.6);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.4, metalness: 0.6 });
            particlesMesh = new THREE.InstancedMesh(geo, mat, CONFIG.particleCount);
            const col = new THREE.Color();
            
            let count = 0;
            const center = new THREE.Vector3(0, 12, 0); // é©¬çš„ä¸­å¿ƒé«˜åº¦æå‡

            while(count < CONFIG.particleCount) {
                // åœ¨ä¸€ä¸ªå¤§èŒƒå›´å†…éšæœºå–ç‚¹
                let p = new THREE.Vector3(
                    (Math.random()-0.5) * 40,
                    Math.random() * 35,
                    (Math.random()-0.5) * 40
                );
                let valid = false;
                let partType = 0; // 0:èº¯å¹², 1:å¤´é¢ˆ, 2:è…¿, 3:é¬ƒæ¯›å°¾å·´

                // --- 1. å¥å£®èº¯å¹² (Torso) ---
                // ä¸»èº¯å¹²
                if(inEllipsoid(p, center.clone().add(new THREE.Vector3(0,0,0)), new THREE.Vector3(5, 6, 11))) { valid=true; partType=0; }
                // å®½é˜”èƒ¸è‚Œ
                if(inEllipsoid(p, center.clone().add(new THREE.Vector3(0,1,6)), new THREE.Vector3(5.5, 7, 5))) { valid=true; partType=0; }
                // ç»“å®è‡€éƒ¨
                if(inEllipsoid(p, center.clone().add(new THREE.Vector3(0,2,-7)), new THREE.Vector3(5.2, 6.5, 5.5))) { valid=true; partType=0; }

                // --- 2. æ˜‚æ‰¬å¤´é¢ˆ (Neck & Head) ---
                // é¢ˆéƒ¨ (å‘ä¸Šå‘åå€¾æ–œ)
                if(!valid && inEllipsoid(p, center.clone().add(new THREE.Vector3(0, 10, 9)), new THREE.Vector3(2.5, 8, 4), 0, -Math.PI/6)) { valid=true; partType=1; }
                // å¤´éƒ¨ (é«˜æ˜‚)
                if(!valid && inEllipsoid(p, center.clone().add(new THREE.Vector3(0, 16, 12)), new THREE.Vector3(2.2, 3.5, 4.5), 0, Math.PI/8)) { valid=true; partType=1; }
                // é¢é¢Š/å£é¼»
                 if(!valid && inEllipsoid(p, center.clone().add(new THREE.Vector3(0, 14.5, 15.5)), new THREE.Vector3(1.5, 2, 2.5))) { valid=true; partType=1; }


                // --- 3. ä¼˜ç¾å››è‚¢ (Legs - å¸¦å…³èŠ‚çš„æ•°å­¦æ¨¡æ‹Ÿ) ---
                if(!valid) {
                    const legX = 3.5; // è…¿é—´è·
                    // å‰è…¿ (ç¨å¾®å¼¯æ›²è…¾ç©º)
                    if(inEllipsoid(p, new THREE.Vector3(legX, 8, 7), new THREE.Vector3(1.8, 5, 2.5), 0, Math.PI/12) || // ä¸Šè‡‚
                       inEllipsoid(p, new THREE.Vector3(legX, 2, 8.5), new THREE.Vector3(1.2, 4, 1.5), 0, -Math.PI/8)) // å‰è‡‚
                    { valid=true; partType=2; }
                    
                    if(inEllipsoid(p, new THREE.Vector3(-legX, 8, 7), new THREE.Vector3(1.8, 5, 2.5), 0, Math.PI/12) ||
                       inEllipsoid(p, new THREE.Vector3(-legX, 2, 8.5), new THREE.Vector3(1.2, 4, 1.5), 0, -Math.PI/8))
                    { valid=true; partType=2; }

                    // åè…¿ (å……æ»¡åŠ›é‡çš„é£èŠ‚è§’åº¦)
                    if(inEllipsoid(p, new THREE.Vector3(legX, 9, -8), new THREE.Vector3(2.2, 6, 3.5), 0, -Math.PI/10) || // å¤§è…¿
                       inEllipsoid(p, new THREE.Vector3(legX, 3, -11), new THREE.Vector3(1.5, 5, 2), 0, Math.PI/6)) // å°è…¿
                    { valid=true; partType=2; }
                     if(inEllipsoid(p, new THREE.Vector3(-legX, 9, -8), new THREE.Vector3(2.2, 6, 3.5), 0, -Math.PI/10) ||
                       inEllipsoid(p, new THREE.Vector3(-legX, 3, -11), new THREE.Vector3(1.5, 5, 2), 0, Math.PI/6))
                    { valid=true; partType=2; }
                }

                // --- 4. é¬ƒæ¯›ä¸å°¾å·´ (Mane & Tail - é£˜é€¸æ„Ÿ) ---
                // é¬ƒæ¯› (é¢ˆèƒŒæ²¿çº¿)
                if(!valid && p.x > -0.5 && p.x < 0.5 && p.y > 12 && p.y < 20 && p.z > 5 && p.z < 14) {
                     // ç®€å•çš„çº¿æ€§åˆ¤æ–­åŠ ä¸Šä¸€ç‚¹éšæœºæ‰°åŠ¨
                     if (p.y > (p.z * 0.8 + 8) + (Math.random()-0.5)*2 ) { valid=true; partType=3; }
                }
                // å°¾å·´ (èº«åé£˜æ‰¬)
                if(!valid && p.z < -9 && p.y < 13 && p.y > 2) {
                    let tailCurve = Math.sin((p.z+10)*0.3) * 3; // å°¾å·´æ›²çº¿
                    if(p.x > tailCurve - 1.5 && p.x < tailCurve + 1.5 && p.y > (p.z*0.5 + 8) ) { valid=true; partType=3; }
                }


                // å¦‚æœç‚¹åœ¨æ¨¡å‹å†…ï¼Œåˆ™åˆ›å»ºç²’å­
                if(valid) {
                    // é¢œè‰²åˆ†å¸ƒï¼šé‡‘è‰²é›†ä¸­åœ¨é¬ƒæ¯›å°¾å·´å’Œå…³èŠ‚å¤„ï¼Œèº«ä½“ä¸ºæ·±çº¢
                    let isGold = false;
                    if(partType === 3 && Math.random() > 0.3) isGold = true; // é¬ƒæ¯›å°¾å·´å¤šé‡‘
                    else if (partType === 2 && p.y < 5 && Math.random() > 0.7) isGold = true; // è¹„å­é™„è¿‘
                    else if (Math.random() > 0.88) isGold = true; // å…¨èº«éšæœºæ•£å¸ƒ

                    if (isGold) col.setHex(CONFIG.colors.gold); else col.setHex(CONFIG.colors.red);
                    
                    particlesMesh.setColorAt(count, col);
                    dummy.position.copy(p);
                    // èŠ±ç“£éšæœºè§’åº¦
                    dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    // é¬ƒæ¯›å°¾å·´çš„ç²’å­ç¨å¾®å¤§ä¸€ç‚¹ï¼Œæ›´é£˜é€¸
                    let s = (partType === 3) ? (0.6 + Math.random()*0.6) : (0.4 + Math.random()*0.5);
                    dummy.scale.setScalar(s);
                    dummy.updateMatrix();
                    particlesMesh.setMatrixAt(count, dummy.matrix);
                    
                    // æ•£å¼€èŒƒå›´å¢åŠ åˆ° 120
                    particlesData.push({ idx: count, part: partType, cur: p.clone(), horsePos: p.clone(), 
                        scat: new THREE.Vector3((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120), 
                        speed: 0.015 + Math.random() * 0.025 });
                    count++;
                }
            }
            scene.add(particlesMesh);
        }

        function handleImageUpload(e) {
            const files = e.target.files; if(!files.length) return;
            Array.from(files).forEach(f => {
                const r = new FileReader();
                r.onload = ev => { const img = new Image(); img.src = ev.target.result; img.onload = () => createPhoto(img); };
                r.readAsDataURL(f);
            });
        }

        function createPhoto(img) {
            const tex = new THREE.Texture(img); tex.needsUpdate=true; tex.generateMipmaps=true; tex.encoding = THREE.sRGBEncoding;
            const aspect = img.width/img.height;
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, fog: false, toneMapped: false });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(6*aspect, 6), mat); // ç…§ç‰‡ç¨å¾®å¤§ä¸€ç‚¹
            const frame = new THREE.Mesh(new THREE.BoxGeometry(6*aspect+0.2, 6.2, 0.1), new THREE.MeshStandardMaterial({color:0xffffff, roughness: 0.3}));
            mesh.position.z = 0.06; frame.add(mesh);
            const ty = Math.random()*25 + 5;
            frame.position.set(0, ty, 25);
            frame.userData = { tree: new THREE.Vector3((Math.random()-0.5)*35, ty, (Math.random()-0.5)*30), scat: new THREE.Vector3((Math.random()-0.5)*110, (Math.random()-0.5)*100, (Math.random()-0.5)*110), cur: frame.position.clone(), focus: false };
            photoGroup.add(frame); photosData.push(frame);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            let targetState = STATE.mode;
            if (STATE.gesture === 'VICTORY') {
                targetState = 'RUNNING'; STATE.runSpeed = Math.min(STATE.runSpeed + 0.03, 1.2); runTime += 0.25;
            } else {
                STATE.runSpeed = Math.max(STATE.runSpeed - 0.03, 0); 
                if(targetState !== 'SCATTER') targetState = 'HORSE';
                runTime += 0.04; // å‘¼å¸/æ…¢è·‘é€Ÿåº¦
            }

            for(let i=0; i<CONFIG.particleCount; i++) {
                const d = particlesData[i]; let tgt;
                if (targetState === 'SCATTER') tgt = d.scat;
                else {
                    tgt = d.horsePos.clone();
                    // æ•´ä½“å¥”è·‘èµ·ä¼
                    let bodyWave = Math.sin(runTime * 2) * 0.8 * (0.2 + STATE.runSpeed*0.8);
                    tgt.y += bodyWave;

                    if (d.part === 2) { // è…¿éƒ¨åŠ¨ç”» (ç®€åŒ–ç‰ˆ)
                        // æ ¹æ®Zè½´ä½ç½®ç®€å•åˆ¤æ–­å‰åè…¿
                        const isFront = d.horsePos.z > 0;
                        const phase = isFront ? 0 : Math.PI;
                        // å¥”è·‘å¹…åº¦
                        const runAmp = STATE.runSpeed * 4; 
                        tgt.z += Math.sin(runTime*2 + phase) * runAmp;
                        tgt.y += Math.max(0, Math.cos(runTime*2 + phase) * runAmp * 0.5);
                    } else if (d.part === 3) { // é¬ƒæ¯›å°¾å·´é£˜åŠ¨
                        tgt.x += Math.sin(time*3 + d.idx*0.1) * 0.2 * (1+STATE.runSpeed*3);
                        tgt.y += Math.cos(time*2 + d.idx*0.1) * 0.2 * (1+STATE.runSpeed*2);
                        // å¥”è·‘æ—¶å‘åé£˜
                        if(STATE.runSpeed > 0.1) tgt.z -= STATE.runSpeed * (Math.random()*2); 
                    }
                }
                if(targetState === 'SCATTER') d.cur.y += Math.sin(time + i)*0.01;
                
                d.cur.lerp(tgt, d.speed); dummy.position.copy(d.cur);
                dummy.rotation.x += 0.01 + STATE.runSpeed*0.05; // å¥”è·‘æ—¶èŠ±ç“£æ—‹è½¬åŠ å¿«
                dummy.rotation.y += 0.01;
                dummy.updateMatrix(); particlesMesh.setMatrixAt(i, dummy.matrix);
            }
            particlesMesh.instanceMatrix.needsUpdate=true;
            
            photosData.forEach(p => {
                const d = p.userData; let tgt = (targetState === 'SCATTER') ? d.scat : d.tree; let scale = 1;
                if(d.focus) {
                    const v = new THREE.Vector3(0,0,-15).applyQuaternion(camera.quaternion); tgt = camera.position.clone().add(v);
                    p.lookAt(camera.position); scale=3.0; 
                } else {
                    p.lookAt(camera.position);
                    if(STATE.runSpeed > 0.1) tgt.z += Math.sin(time*8)*0.15; // å¥”è·‘æ—¶ç…§ç‰‡éœ‡åŠ¨
                }
                d.cur.lerp(tgt, 0.04); p.position.copy(d.cur); p.scale.lerp(new THREE.Vector3(scale,scale,scale), 0.1);
            });

            if(STATE.mode==='SCATTER' && STATE.handVisible) {
                updateCameraFromInput(STATE.handX, STATE.handY);
            } else {
                // å›å½’è§†è§’
                camera.position.lerp(new THREE.Vector3(0, 14, CONFIG.cameraZ), 0.03);
                let shake = (Math.random()-0.5) * STATE.runSpeed * 0.8;
                currentLookAt.lerp(new THREE.Vector3(0, 8 + shake, 0), 0.05);
                camera.lookAt(currentLookAt);
            }
            if(composer) composer.render(); else renderer.render(scene, camera);
        }

        function updateCameraFromInput(x, y) {
            const theta = (x-0.5) * 4 * Math.PI; const phi = (1-y) * Math.PI * 0.5 + 0.2; 
            const r = CONFIG.cameraZ * 1.1; 
            const cx = r * Math.sin(theta) * Math.sin(phi); const cz = r * Math.cos(theta) * Math.sin(phi); const cy = r * Math.cos(phi) + 10;
            camera.position.lerp(new THREE.Vector3(cx, cy, cz), 0.05); camera.lookAt(0, 10, 0);
        }

        async function startCamera() {
            log("Init AI (UNPKG)..."); const video = document.getElementsByClassName('input_video')[0];
            try {
                if(typeof Hands === 'undefined') throw new Error("Hands lib missing");
                const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
                hands.onResults(onResults);
                const camera = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 480, height: 360 });
                await camera.start(); document.getElementById('gesture-status').innerText = "AI Active!"; log("Camera Started");
            } catch(e) { log("Cam Fail: " + e.message); document.getElementById('gesture-status').innerText = "Cam Failed. Mouse Mode."; }
        }

        function onResults(res) {
            const status = document.getElementById('gesture-status');
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                STATE.handVisible = true; const lm = res.multiHandLandmarks[0];
                STATE.handX = STATE.handX * 0.8 + (1 - lm[0].x) * 0.2; STATE.handY = STATE.handY * 0.8 + lm[0].y * 0.2;
                
                const wrist = lm[0]; const iTip = lm[8], mTip = lm[12], rTip = lm[16], pTip = lm[20];
                const iBase = lm[5], mBase = lm[9], rBase = lm[13], pBase = lm[17];
                const isIndexUp = iTip.y < iBase.y; const isMiddleUp = mTip.y < mBase.y;
                const isRingDown = rTip.y > rBase.y; const isPinkyDown = pTip.y > pBase.y;
                const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05; 
                
                let openCount = 0;
                [8,12,16,20].forEach((t,i) => { if(lm[t].y < lm[[5,9,13,17][i]].y) openCount++; });

                if (pinch) {
                    STATE.gesture = 'PINCH'; status.innerText = "ğŸ‘Œ æåˆ: æŠ“å– (Grab)"; raycastGrab();
                } else if (isIndexUp && isMiddleUp && isRingDown && isPinkyDown && !pinch) {
                    STATE.gesture = 'VICTORY'; STATE.mode = 'HORSE'; status.innerText = "âœŒï¸ å‰ªåˆ€æ‰‹: å¥”è·‘ (RUN!)";
                } else if (openCount >= 4) {
                    STATE.gesture = 'OPEN'; STATE.mode = 'SCATTER'; resetPhoto(); status.innerText = "ğŸ– å¼ å¼€: æ¼«æ¸¸ (Scatter)";
                } else {
                    STATE.gesture = 'FIST'; STATE.mode = 'HORSE'; status.innerText = "âœŠ æ¡æ‹³: åœæ­¢ (Stop)";
                }
            } else { STATE.handVisible = false; status.innerText = "No Hand Detected"; }
        }

        function raycastGrab() {
            if(STATE.mode === 'RUNNING' || photosData.length === 0) return; 
            raycaster.setFromCamera(centerVector, camera);
            const intersects = raycaster.intersectObjects(photoGroup.children, true);
            if (intersects.length > 0) { const targetFrame = intersects[0].object.parent; if(targetFrame) { activatePhoto(targetFrame); return; } }
            let closest = null; let minAngle = Infinity;
            const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
            photosData.forEach(p => {
                const toPhoto = p.position.clone().sub(camera.position).normalize();
                const angle = camDir.angleTo(toPhoto); 
                if(angle < 0.4 && angle < minAngle) { minAngle = angle; closest = p; }
            });
            if(closest) activatePhoto(closest);
        }

        function activatePhoto(p) { resetPhoto(); STATE.mode='ZOOM'; p.userData.focus=true; document.getElementById('gesture-status').innerText = "Got it!"; }
        function resetPhoto() { photosData.forEach(p=>p.userData.focus=false); }
    </script>
</body>
</html>
